{
     "algorithm": "```",
     "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n\n    def rank_based_selection(rankings):\n        # Calculate selection probabilities based on rankings\n        ranks = np.max(rankings) + 1 - rankings\n        selection_probs = ranks / np.sum(ranks)\n        selected_index = np.random.choice(range(len(rankings)), p=selection_probs)\n        return selected_index\n\n    def uniform_crossover(parent1, parent2):\n        # Create a child with genes selected randomly from either parent\n        mask = np.random.randint(0, 2, size=len(parent1))\n        child = np.where(mask, parent1, parent2)\n        return child\n\n    def bit_flip_mutation(individual, mutation_rate=0.05):\n        # Flip bits in the individual with a given mutation rate\n        mutation_mask = np.random.rand(len(individual)) < mutation_rate\n        individual[mutation_mask] = 1 - individual[mutation_mask]\n        return individual\n\n    def greedy_repair(individual, W, C):\n        # Repair the individual by removing items until the weight is under capacity\n        while np.dot(individual, W) > C:\n            item_weights = individual * W\n            # Remove the item with the highest weight\n            heaviest = np.argmax(item_weights)\n            individual[heaviest] = 0\n        return individual\n\n    def create_new_individual(pops, W, C):\n        parent1_index = rank_based_selection(pops['rankings'])\n        parent2_index = rank_based_selection(pops['rankings'])\n        parent1 = pops['individuals'][parent1_index]\n        parent2 = pops['individuals'][parent2_index]\n        child = uniform_crossover(parent1, parent2)\n        child = bit_flip_mutation(child)\n        child = greedy_repair(child, W, C)\n        return child\n\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    \n    for i in range(POP_SIZE):\n        new_pops[i] = create_new_individual(pops, W, C)\n    \n    return new_pops",
     "objective": 0.98666,
     "other_inf": null
}