[
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n\n    def rank_based_selection(rankings):\n        # Calculate selection probabilities based on rankings\n        ranks = np.max(rankings) + 1 - rankings\n        selection_probs = ranks / np.sum(ranks)\n        selected_index = np.random.choice(range(len(rankings)), p=selection_probs)\n        return selected_index\n\n    def uniform_crossover(parent1, parent2):\n        # Create a child with genes selected randomly from either parent\n        mask = np.random.randint(0, 2, size=len(parent1))\n        child = np.where(mask, parent1, parent2)\n        return child\n\n    def bit_flip_mutation(individual, mutation_rate=0.05):\n        # Flip bits in the individual with a given mutation rate\n        mutation_mask = np.random.rand(len(individual)) < mutation_rate\n        individual[mutation_mask] = 1 - individual[mutation_mask]\n        return individual\n\n    def greedy_repair(individual, W, C):\n        # Repair the individual by removing items until the weight is under capacity\n        while np.dot(individual, W) > C:\n            item_weights = individual * W\n            # Remove the item with the highest weight\n            heaviest = np.argmax(item_weights)\n            individual[heaviest] = 0\n        return individual\n\n    def create_new_individual(pops, W, C):\n        parent1_index = rank_based_selection(pops['rankings'])\n        parent2_index = rank_based_selection(pops['rankings'])\n        parent1 = pops['individuals'][parent1_index]\n        parent2 = pops['individuals'][parent2_index]\n        child = uniform_crossover(parent1, parent2)\n        child = bit_flip_mutation(child)\n        child = greedy_repair(child, W, C)\n        return child\n\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    \n    for i in range(POP_SIZE):\n        new_pops[i] = create_new_individual(pops, W, C)\n    \n    return new_pops",
          "objective": 0.98666,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n    \n    def rank_based_selection(pop, rankings):\n        \"\"\"Select one individual using rank-based selection.\"\"\"\n        probabilities = 1 / (rankings + 1)\n        probabilities /= probabilities.sum()\n        selected_idx = np.random.choice(len(pop), p=probabilities)\n        return pop[selected_idx]\n\n    def single_point_crossover(parent1, parent2):\n        \"\"\"Perform single point crossover between two parents.\"\"\"\n        crossover_point = np.random.randint(1, N_P)\n        child = np.concatenate([parent1[:crossover_point], parent2[crossover_point:]])\n        return child\n\n    def bit_flip_mutation(individual, mutation_rate=0.05):\n        \"\"\"Perform bit flip mutation on an individual.\"\"\"\n        for i in range(N_P):\n            if np.random.rand() < mutation_rate:\n                individual[i] = 1 - individual[i]\n        return individual\n\n    def greedy_repair(individual, weights, capacity):\n        \"\"\"Repair an individual using a greedy strategy.\"\"\"\n        while np.dot(individual, weights) > capacity:\n            item_weights = individual * weights\n            heaviest = np.argmax(item_weights)\n            individual[heaviest] = 0\n        return individual\n\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        parent1 = rank_based_selection(pops['individuals'], pops['rankings'])\n        parent2 = rank_based_selection(pops['individuals'], pops['rankings'])\n        child = single_point_crossover(parent1, parent2)\n        child = bit_flip_mutation(child)\n        child = greedy_repair(child, W, C)\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.98631,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n\n    def uniform_crossover(parent1, parent2):\n        # Uniform crossover\n        mask = np.random.randint(2, size=N_P)\n        return np.where(mask, parent1, parent2)\n\n    def mutate(individual):\n        # Mutate with a probability of 1/N_P\n        for i in range(N_P):\n            if np.random.rand() < 1.0 / N_P:\n                individual[i] = 1 - individual[i]\n        return individual\n\n    def repair(individual):\n        # Repair the individual if it violates the weight constraint\n        while np.dot(individual, W) > C:\n            overweight_items = np.where(individual * W > 0)[0]\n            if overweight_items.size == 0:\n                break\n            drop_item = np.random.choice(overweight_items)\n            individual[drop_item] = 0\n        return individual\n\n    def rank_based_selection(ranked_individuals):\n        # Rank-based selection\n        probabilities = 1 / (np.arange(POP_SIZE) + 1)\n        probabilities /= probabilities.sum()\n        selected_index = np.random.choice(POP_SIZE, p=probabilities)\n        return pops['individuals'][selected_index]\n\n    def create_new_individual():\n        # Create a new individual by crossover and mutation\n        parent1 = rank_based_selection(pops['individuals'])\n        parent2 = rank_based_selection(pops['individuals'])\n        child = uniform_crossover(parent1, parent2)\n        child = mutate(child)\n        child = repair(child)\n        return child\n\n    # Generate new population\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        new_pops[i] = create_new_individual()\n\n    return new_pops",
          "objective": 0.98623,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n    \n    def crossover(parent1, parent2):\n        # Single point crossover\n        point = np.random.randint(1, N_P)\n        return np.concatenate((parent1[:point], parent2[point:]))\n\n    def mutate(individual):\n        # Randomly flip one gene\n        mutation_point = np.random.randint(N_P)\n        individual[mutation_point] = 1 - individual[mutation_point]\n        return individual\n\n    def repair(individual):\n        # Repair the individual if it violates the weight constraint\n        while np.dot(individual, W) > C:\n            # Randomly drop items until the weight is within the limit\n            overweight_items = np.where((individual == 1) & (W > 0))[0]\n            if overweight_items.size == 0:\n                break\n            drop_item = np.random.choice(overweight_items)\n            individual[drop_item] = 0\n        return individual\n\n    def select_parents(ranked_individuals):\n        # Tournament selection\n        tournament_size = 2\n        selected_indices = np.random.choice(POP_SIZE, size=tournament_size, replace=False)\n        tournament = ranked_individuals[selected_indices]\n        winner_index = selected_indices[np.argmin(pops['rankings'][selected_indices])]\n        return pops['individuals'][winner_index]\n\n    def create_new_individual():\n        # Create a new individual by crossover and mutation\n        parent1 = select_parents(pops['individuals'])\n        parent2 = select_parents(pops['individuals'])\n        child = crossover(parent1, parent2)\n        child = mutate(child)\n        child = repair(child)\n        return child\n\n    # Generate new population\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        new_pops[i] = create_new_individual()\n\n    return new_pops",
          "objective": 0.98583,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    # Novel reproduction function using crossover and mutation without time-consuming search strategies.\n    \n    def crossover(parent1, parent2):\n        # Single-point crossover\n        point = np.random.randint(1, N_P)\n        child = np.hstack((parent1[:point], parent2[point:]))\n        return child\n\n    def mutate(individual):\n        # Randomly flips one gene (item inclusion/exclusion)\n        point = np.random.randint(N_P)\n        individual[point] = 1 - individual[point]\n        return individual\n\n    def repair(individual):\n        # Repair strategy to ensure compliance with weight constraint\n        while np.dot(individual, W) > C:\n            items = np.where(individual == 1)[0]\n            if items.size == 0:\n                break\n            individual[np.random.choice(items)] = 0\n        return individual\n\n    def select_parents(ranked_individuals):\n        # Tournament selection\n        tournament_size = 2\n        selected_indices = np.random.choice(range(POP_SIZE), size=tournament_size, replace=False)\n        selected = ranked_individuals[selected_indices]\n        best = min(selected, key=lambda x: pops['rankings'][x])\n        return pops['individuals'][best]\n\n    # Main steps to generate the next population\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    ranked_individuals = np.argsort(pops['rankings'])\n    for i in range(POP_SIZE):\n        parent1 = select_parents(ranked_individuals)\n        parent2 = select_parents(ranked_individuals)\n        child = crossover(parent1, parent2)\n        if np.random.rand() < 0.1:  # Mutation probability\n            child = mutate(child)\n        child = repair(child)\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.98485,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n\n    # Backbone idea: Use tournament selection, crossover, mutation, and repair to create a new population.\n    # New algorithm: (Use a greedy heuristic to fill the knapsack based on the ratio of profit to weight, followed by random mutation and repair.)\n    \n    def greedy_fill(individual, W, V, C):\n        # Calculate the ratio of profit to weight for each item\n        ratio = np.sum(V, axis=1) / W\n        # Sort items by ratio in descending order\n        item_indices = np.argsort(ratio)[::-1]\n        # Initialize knapsack\n        knapsack = np.zeros(N_P, dtype=np.int32)\n        current_weight = 0\n        # Fill the knapsack with items based on the profit to weight ratio until full\n        for idx in item_indices:\n            if current_weight + W[idx] <= C:\n                knapsack[idx] = 1\n                current_weight += W[idx]\n            if current_weight == C:\n                break\n        return knapsack\n\n    def mutate(individual, mutation_rate=0.1):\n        # Randomly mutate the individual\n        for i in range(len(individual)):\n            if np.random.rand() < mutation_rate:\n                individual[i] = 1 - individual[i]\n        return individual\n\n    def repair(individual, W, C):\n        # Repair the individual if it exceeds the weight constraint\n        while np.dot(individual, W) > C:\n            nonzero_indices = np.nonzero(individual)[0]\n            if len(nonzero_indices) == 0:\n                break\n            individual[np.random.choice(nonzero_indices)] = 0\n        return individual\n\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        # Create a new individual using the greedy heuristic\n        individual = greedy_fill(pops['individuals'][i], W, V, C)\n        # Mutate the new individual\n        individual = mutate(individual)\n        # Repair the new individual if necessary\n        individual = repair(individual, W, C)\n        new_pops[i] = individual\n\n    return new_pops",
          "objective": 0.98412,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    \"\"\"\n    (Algorithm: Greedy repair-based reproduction with random weighted selection and bit-flipping mutation)\n    Main steps: Select individuals based on weighted randomness, perform bit-flipping mutation, and greedily repair to satisfy weight constraints.\n    \"\"\"\n    import numpy as np\n\n    # Create a new population array\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n\n    # Weighted random selection based on rankings\n    def weighted_random_selection(rankings):\n        inverse_rankings = 1 / (1 + rankings)\n        probabilities = inverse_rankings / inverse_rankings.sum()\n        selected_index = np.random.choice(len(rankings), p=probabilities)\n        return selected_index\n\n    # Bit-flipping mutation\n    def bit_flipping_mutation(individual, mutation_rate=0.1):\n        mutation_mask = np.random.rand(N_P) < mutation_rate\n        individual[mutation_mask] = 1 - individual[mutation_mask]\n        return individual\n\n    # Greedy repair function\n    def greedy_repair(individual, W, C):\n        while np.dot(individual, W) > C:\n            # Find items that can be removed\n            candidate_indices = np.where(individual == 1)[0]\n            # Sort by weight to remove heavier items first\n            candidate_weights = W[candidate_indices]\n            sorted_indices = candidate_indices[np.argsort(-candidate_weights)]\n            # Remove the heaviest item\n            individual[sorted_indices[0]] = 0\n        return individual\n\n    # Reproduction process\n    for i in range(POP_SIZE):\n        # Select an individual based on weighted randomness\n        selected_index = weighted_random_selection(pops['rankings'])\n        individual = pops['individuals'][selected_index].copy()\n        # Apply mutation\n        individual = bit_flipping_mutation(individual)\n        # Repair the individual to satisfy the weight constraint\n        individual = greedy_repair(individual, W, C)\n        # Add the new individual to the population\n        new_pops[i] = individual\n\n    return new_pops",
          "objective": 0.98361,
          "other_inf": null
     },
     {
          "algorithm": "My new algorithm will use a blend crossover that combines multiple parents and a bit-flip mutation with a greedy repair method.",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    # (The backbone idea is to use genetic operators (crossover, mutation, and repair) to evolve the population while maintaining feasibility.)\n    # {My new algorithm will use a blend crossover that combines multiple parents and a bit-flip mutation with a greedy repair method.}\n    \n    import numpy as np\n    \n    # Blend crossover that combines genes from multiple parents\n    def blend_crossover(parents):\n        return np.any(parents, axis=0).astype(np.int32)\n\n    # Bit-flip mutation\n    def bit_flip_mutation(individual):\n        mutation_points = np.random.rand(N_P) < 0.1  # Mutation probability\n        individual[mutation_points] = 1 - individual[mutation_points]\n        return individual\n\n    # Greedy repair method\n    def greedy_repair(individual):\n        while np.dot(individual, W) > C:\n            item_weights = individual * W\n            heaviest = np.argmax(item_weights)\n            individual[heaviest] = 0\n        return individual\n    \n    # Rank-based selection of parents\n    def select_parents(ranked_individuals, num_parents=3):\n        probabilities = 1 / (1 + ranked_individuals)\n        probabilities /= probabilities.sum()\n        selected_indices = np.random.choice(POP_SIZE, size=num_parents, replace=False, p=probabilities)\n        return pops['individuals'][selected_indices]\n\n    # Generate the next population\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    ranked_individuals = np.argsort(pops['rankings'])\n    \n    for i in range(POP_SIZE):\n        parents = select_parents(ranked_individuals)\n        child = blend_crossover(parents)\n        child = bit_flip_mutation(child)\n        child = greedy_repair(child)\n        new_pops[i] = child\n    \n    return new_pops",
          "objective": 0.9823,
          "other_inf": null
     },
     {
          "algorithm": "'individuals': new_pops, 'rankings': np.empty(POP_SIZE)",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n    \n    def tournament_selection(pop, rankings, k=3):\n        \"\"\"Select one individual using k-tournament selection.\"\"\"\n        selected_idx = np.random.choice(len(pop), k, replace=False)\n        return pop[selected_idx[np.argmin(rankings[selected_idx])]]\n\n    def crossover(parent1, parent2):\n        \"\"\"Perform uniform crossover between two parents.\"\"\"\n        crossover_mask = np.random.randint(0, 2, size=parent1.shape)\n        child = np.where(crossover_mask == 1, parent1, parent2)\n        return child\n\n    def mutation(individual, mutation_rate=0.1):\n        \"\"\"Mutate an individual with a given mutation rate.\"\"\"\n        mutation_mask = np.random.rand(N_P) < mutation_rate\n        individual[mutation_mask] = 1 - individual[mutation_mask]\n        return individual\n\n    def repair(individual, weights, capacity):\n        \"\"\"Repair an individual so that it satisfies the weight constraint.\"\"\"\n        while np.dot(individual, weights) > capacity:\n            nonzero_indices = np.nonzero(individual)[0]\n            individual[np.random.choice(nonzero_indices)] = 0\n        return individual\n\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        parent1 = tournament_selection(pops['individuals'], pops['rankings'])\n        parent2 = tournament_selection(pops['individuals'], pops['rankings'])\n        child = crossover(parent1, parent2)\n        child = mutation(child)\n        child = repair(child, W, C)\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.91692,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n\n    def tournament_selection(rankings, k=2):\n        \"\"\"Selects individuals for crossover using tournament selection.\"\"\"\n        selected_indices = np.random.choice(len(rankings), k)\n        selected_rankings = rankings[selected_indices]\n        return selected_indices[np.argmin(selected_rankings)]\n\n    def crossover(parent1, parent2):\n        \"\"\"Performs uniform crossover on two parents.\"\"\"\n        mask = np.random.rand(N_P) < 0.5\n        child = np.where(mask, parent1, parent2)\n        return child\n\n    def mutation(individual, mutation_rate=0.1):\n        \"\"\"Mutates an individual with the given mutation rate.\"\"\"\n        for i in range(N_P):\n            if np.random.rand() < mutation_rate:\n                individual[i] = 1 - individual[i]\n        return individual\n\n    def repair(individual):\n        \"\"\"Repairs an individual if it violates the weight constraint.\"\"\"\n        while np.dot(individual, W) > C:\n            # Randomly drop items until the weight constraint is met\n            nonzero_indices = np.nonzero(individual)[0]\n            individual[np.random.choice(nonzero_indices)] = 0\n        return individual\n\n    def generate_new_individual():\n        \"\"\"Generates a new individual through selection, crossover, and mutation.\"\"\"\n        parent1_idx = tournament_selection(pops['rankings'])\n        parent2_idx = tournament_selection(pops['rankings'])\n        child = crossover(pops['individuals'][parent1_idx], pops['individuals'][parent2_idx])\n        child = mutation(child)\n        child = repair(child)\n        return child\n\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        new_pops[i] = generate_new_individual()\n\n    return new_pops",
          "objective": 0.90721,
          "other_inf": null
     }
]