[
     {
          "algorithm": "The new algorithm combines greedy selection based on value-to-weight ratio with random sampling and ensures weight constraints are met.",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    # {The new algorithm combines greedy selection based on value-to-weight ratio with random sampling and ensures weight constraints are met.}\n\n    import numpy as np\n\n    # Calculate value-to-weight ratio for each item\n    ratios = np.max(V / W[:, np.newaxis], axis=1)\n\n    # Sort items by their ratio in descending order\n    sorted_indices = np.argsort(-ratios)\n\n    def greedy_individual():\n        # Initialize an empty knapsack\n        individual = np.zeros(N_P, dtype=np.int32)\n        current_weight = 0\n\n        # Add items based on the sorted value-to-weight ratio until the knapsack is full\n        for idx in sorted_indices:\n            if current_weight + W[idx] <= C:\n                individual[idx] = 1\n                current_weight += W[idx]\n        return individual\n\n    def random_sampling():\n        # Initialize an empty knapsack\n        individual = np.zeros(N_P, dtype=np.int32)\n        available_indices = np.arange(N_P)\n        current_weight = 0\n\n        # Randomly add items until the knapsack is full or no items can be added\n        while current_weight <= C and available_indices.size > 0:\n            idx = np.random.choice(available_indices)\n            if current_weight + W[idx] <= C:\n                individual[idx] = 1\n                current_weight += W[idx]\n            available_indices = available_indices[available_indices != idx]\n\n        return individual\n\n    # Generate new population\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        if np.random.rand() < 0.5:\n            new_pops[i] = greedy_individual()\n        else:\n            new_pops[i] = random_sampling()\n\n    return new_pops",
          "objective": 0.98978,
          "other_inf": null
     },
     {
          "algorithm": "An algorithm using rank-based selection, single-point crossover, and mutation with a reverse greedy repair mechanism.",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    # {An algorithm using rank-based selection, single-point crossover, and mutation with a reverse greedy repair mechanism.}\n    import numpy as np\n    \n    # Rank-based selection\n    def rank_based_selection(pop, rankings):\n        # Calculate selection probabilities inversely proportional to ranking\n        selection_probs = 1 / (rankings + 1)\n        selection_probs /= selection_probs.sum()\n        selected_indices = np.random.choice(POP_SIZE, size=POP_SIZE, p=selection_probs)\n        return pop[selected_indices]\n\n    # Single-point crossover\n    def single_point_crossover(parent1, parent2):\n        crossover_point = np.random.randint(1, N_P)\n        child = np.concatenate([parent1[:crossover_point], parent2[crossover_point:]])\n        return child\n\n    # Mutation\n    def mutation(individual, mutation_rate=0.01):\n        mutation_indices = np.random.choice(N_P, size=int(N_P * mutation_rate), replace=False)\n        individual[mutation_indices] = 1 - individual[mutation_indices]\n        return individual\n\n    # Reverse greedy repair\n    def reverse_greedy_repair(individual, weights, capacity, values):\n        # Start by removing items until under capacity\n        while np.dot(weights, individual) > capacity:\n            included_items = np.where(individual == 1)[0]\n            if included_items.size == 0:\n                break\n            individual[included_items[-1]] = 0\n        # Then add items based on value/weight ratio until no more can be added\n        ratio = np.sum(values, axis=1) / weights\n        sorted_indices = np.argsort(-ratio)\n        for i in sorted_indices:\n            if individual[i] == 0 and np.dot(weights, individual) + weights[i] <= capacity:\n                individual[i] = 1\n        return individual\n\n    # Initialize new population\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    \n    # Perform rank-based selection\n    parents = rank_based_selection(pops['individuals'], pops['rankings'])\n    \n    # Generate new population\n    for i in range(0, POP_SIZE, 2):\n        # Select parents for crossover\n        parent1, parent2 = parents[i % POP_SIZE], parents[(i + 1) % POP_SIZE]\n        # Perform crossover and mutation\n        child1 = single_point_crossover(parent1, parent2)\n        child2 = single_point_crossover(parent2, parent1)\n        child1 = mutation(child1)\n        child2 = mutation(child2)\n        # Repair children\n        child1 = reverse_greedy_repair(child1, W, C, V)\n        child2 = reverse_greedy_repair(child2, W, C, V)\n        # Add children to new population\n        new_pops[i] = child1\n        if i + 1 < POP_SIZE:\n            new_pops[i + 1] = child2\n    \n    return new_pops",
          "objective": 0.9894,
          "other_inf": null
     },
     {
          "algorithm": "Use tournament selection, uniform crossover, bit-flip mutation, and greedy repair based on profit-to-weight ratio.",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    # New algorithm: {Use tournament selection, uniform crossover, bit-flip mutation, and greedy repair based on profit-to-weight ratio.}\n\n    def tournament_selection(pop, rankings, k=3):\n        # Select k individuals randomly and return the best one based on rankings\n        selected_indices = np.random.choice(len(pop), k, replace=False)\n        best_idx = selected_indices[np.argmin(rankings[selected_indices])]\n        return pop[best_idx]\n\n    def uniform_crossover(parent1, parent2):\n        # Perform uniform crossover between two parents\n        mask = np.random.randint(0, 2, size=N_P).astype(bool)\n        child = np.where(mask, parent1, parent2)\n        return child\n\n    def bit_flip_mutation(individual):\n        # Perform bit-flip mutation on the individual\n        mutation_rate = 1.0 / N_P\n        for i in range(N_P):\n            if np.random.rand() < mutation_rate:\n                individual[i] = 1 - individual[i]\n        return individual\n\n    def greedy_repair(individual):\n        # Repair the individual by adding items with the highest profit-to-weight ratio until the weight is under capacity\n        if np.dot(individual, W) > C:\n            individual[:] = 0  # Reset individual\n            profit_weight_ratio = V.sum(axis=1) / W  # Sum profits for all objectives\n            item_indices = np.argsort(-profit_weight_ratio)\n            current_weight = 0\n            for i in item_indices:\n                if current_weight + W[i] <= C:\n                    individual[i] = 1\n                    current_weight += W[i]\n        return individual\n\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        parent1 = tournament_selection(pops['individuals'], pops['rankings'])\n        parent2 = tournament_selection(pops['individuals'], pops['rankings'])\n        child = uniform_crossover(parent1, parent2)\n        child = bit_flip_mutation(child)\n        child = greedy_repair(child)\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.9887,
          "other_inf": null
     },
     {
          "algorithm": "Algorithm using rank-based selection, single-point crossover, mutation with decreasing probability, and greedy repair based on profit-to-weight ratio.",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    # {Algorithm using rank-based selection, single-point crossover, mutation with decreasing probability, and greedy repair based on profit-to-weight ratio.}\n    import numpy as np\n\n    # Rank-based selection\n    def rank_based_selection(pop, rankings):\n        # Calculate selection probabilities inversely proportional to rankings\n        selection_probs = 1 / (rankings + 1)\n        selection_probs /= selection_probs.sum()\n        selected_indices = np.random.choice(len(pop), size=POP_SIZE, p=selection_probs)\n        return pop[selected_indices]\n\n    # Single-point crossover\n    def single_point_crossover(parent1, parent2):\n        crossover_point = np.random.randint(1, N_P)  # Choose crossover point\n        child = np.concatenate([parent1[:crossover_point], parent2[crossover_point:]])\n        return child\n\n    # Mutation with decreasing probability\n    def mutation_with_decreasing_probability(individual, initial_mutation_rate=0.05):\n        mutation_rate = initial_mutation_rate\n        for i in range(N_P):\n            if np.random.rand() < mutation_rate:\n                individual[i] = 1 - individual[i]\n            mutation_rate *= 0.95  # Decrease mutation rate for each gene\n        return individual\n\n    # Greedy repair based on profit-to-weight ratio\n    def greedy_repair(individual, weights, capacity, values):\n        profit_weight_ratio = np.sum(values, axis=1) / weights\n        sorted_indices = np.argsort(-profit_weight_ratio)\n        weight_sum = np.dot(weights, individual)\n        for i in sorted_indices:\n            if weight_sum <= capacity:\n                break\n            if individual[i] == 1:\n                individual[i] = 0\n                weight_sum -= weights[i]\n        for i in sorted_indices:\n            if weight_sum + weights[i] <= capacity and individual[i] == 0:\n                individual[i] = 1\n                weight_sum += weights[i]\n        return individual\n\n    # Initialize new population array\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n\n    # Generate new population\n    selected_parents = rank_based_selection(pops['individuals'], pops['rankings'])\n    for i in range(POP_SIZE // 2):  # Perform crossover for half the population\n        # Select parents for crossover\n        parent1_idx, parent2_idx = np.random.choice(POP_SIZE, 2, replace=False)\n        parent1 = selected_parents[parent1_idx]\n        parent2 = selected_parents[parent2_idx]\n        # Perform crossover and mutation\n        child1 = single_point_crossover(parent1, parent2)\n        child2 = single_point_crossover(parent2, parent1)\n        child1 = mutation_with_decreasing_probability(child1)\n        child2 = mutation_with_decreasing_probability(child2)\n        # Repair children to satisfy the weight constraint\n        child1 = greedy_repair(child1, W, C, V)\n        child2 = greedy_repair(child2, W, C, V)\n        # Add children to the new population\n        new_pops[2*i] = child1\n        new_pops[2*i+1] = child2\n\n    # If POP_SIZE is odd, add one more individual\n    if POP_SIZE % 2 == 1:\n        parent = selected_parents[-1]\n        child = mutation_with_decreasing_probability(parent.copy())\n        child = greedy_repair(child, W, C, V)\n        new_pops[-1] = child\n\n    return new_pops",
          "objective": 0.98869,
          "other_inf": null
     },
     {
          "algorithm": "Use rank-based selection, single-point crossover, inversion mutation, and greedy repair based on a modified profit-to-weight ratio considering ranking.",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    # New algorithm: {Use rank-based selection, single-point crossover, inversion mutation, and greedy repair based on a modified profit-to-weight ratio considering ranking.}\n\n    def rank_based_selection(pop, rankings):\n        # Select individuals based on their rankings\n        probabilities = 1 / (rankings + 1)\n        probabilities /= probabilities.sum()\n        selected_index = np.random.choice(len(pop), p=probabilities)\n        return pop[selected_index]\n\n    def single_point_crossover(parent1, parent2):\n        # Perform single-point crossover between two parents\n        point = np.random.randint(1, N_P)\n        child = np.concatenate([parent1[:point], parent2[point:]])\n        return child\n\n    def inversion_mutation(individual):\n        # Perform inversion mutation on the individual\n        start, end = sorted(np.random.choice(range(N_P), 2, replace=False))\n        individual[start:end] = individual[start:end][::-1]\n        return individual\n\n    def modified_greedy_repair(individual, rankings):\n        # Repair the individual by adding items with a modified profit-to-weight ratio considering ranking\n        if np.dot(individual, W) > C:\n            individual[:] = 0  # Reset individual\n            profit_weight_ratio = V.sum(axis=1) / W\n            # Modify the ratio by multiplying with the inverse of ranking\n            modified_ratio = profit_weight_ratio * (1 / (rankings.mean() + 1))\n            item_indices = np.argsort(-modified_ratio)\n            current_weight = 0\n            for i in item_indices:\n                if current_weight + W[i] <= C:\n                    individual[i] = 1\n                    current_weight += W[i]\n        return individual\n\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        parent1 = rank_based_selection(pops['individuals'], pops['rankings'])\n        parent2 = rank_based_selection(pops['individuals'], pops['rankings'])\n        child = single_point_crossover(parent1, parent2)\n        child = inversion_mutation(child)\n        child = modified_greedy_repair(child, pops['rankings'])\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.98855,
          "other_inf": null
     },
     {
          "algorithm": "Algorithm using tournament selection, uniform crossover, bit-flip mutation, and greedy repair based on value density.",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    # {Algorithm using tournament selection, uniform crossover, bit-flip mutation, and greedy repair based on value density.}\n    import numpy as np\n\n    # Tournament selection\n    def tournament_selection(pop, rankings, tournament_size=3):\n        new_pop = []\n        for _ in range(POP_SIZE):\n            # Randomly select tournament_size individuals\n            tournament = np.random.choice(len(pop), tournament_size, replace=False)\n            # Find the best individual in the tournament\n            best_individual_idx = tournament[np.argmin(rankings[tournament])]\n            new_pop.append(pop[best_individual_idx])\n        return np.array(new_pop)\n\n    # Uniform crossover\n    def uniform_crossover(parent1, parent2):\n        mask = np.random.rand(N_P) < 0.5  # 50% chance for each gene\n        child = np.where(mask, parent1, parent2)\n        return child\n\n    # Bit-flip mutation\n    def bit_flip_mutation(individual, mutation_rate=0.01):\n        for i in range(N_P):\n            if np.random.rand() < mutation_rate:\n                individual[i] = 1 - individual[i]\n        return individual\n\n    # Greedy repair based on value density\n    def greedy_repair(individual, weights, capacity, values):\n        value_density = np.sum(values, axis=1) / weights\n        sorted_indices = np.argsort(-value_density)\n        weight_sum = np.dot(weights, individual)\n        for i in sorted_indices:\n            if weight_sum <= capacity:\n                break\n            if individual[i] == 1:\n                individual[i] = 0\n                weight_sum -= weights[i]\n        for i in sorted_indices:\n            if weight_sum + weights[i] <= capacity and individual[i] == 0:\n                individual[i] = 1\n                weight_sum += weights[i]\n        return individual\n\n    # Initialize new population array\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    \n    # Generate new population\n    selected_parents = tournament_selection(pops['individuals'], pops['rankings'])\n    for i in range(POP_SIZE):\n        # Select parents for crossover\n        parent1_idx = np.random.randint(0, POP_SIZE)\n        parent2_idx = np.random.randint(0, POP_SIZE)\n        parent1 = selected_parents[parent1_idx]\n        parent2 = selected_parents[parent2_idx]\n        # Perform crossover and mutation\n        child = uniform_crossover(parent1, parent2)\n        child = bit_flip_mutation(child)\n        # Repair child to satisfy the weight constraint\n        child = greedy_repair(child, W, C, V)\n        # Add child to the new population\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.98852,
          "other_inf": null
     },
     {
          "algorithm": "An algorithm using roulette wheel selection, single-point crossover, inversion mutation, and a greedy repair mechanism based on combined value/weight ratio.",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    # {An algorithm using roulette wheel selection, single-point crossover, inversion mutation, and a greedy repair mechanism based on combined value/weight ratio.}\n    import numpy as np\n\n    def roulette_wheel_selection(pop, rankings):\n        # Calculate selection probabilities inversely proportional to rankings.\n        min_rank = np.min(rankings)\n        adjusted_rankings = rankings - min_rank + 1\n        probabilities = 1.0 / adjusted_rankings\n        probabilities /= probabilities.sum()\n        selected_indices = np.random.choice(POP_SIZE, size=POP_SIZE, p=probabilities)\n        return pop[selected_indices]\n\n    def single_point_crossover(parent1, parent2):\n        # Perform single-point crossover between two parents.\n        point = np.random.randint(1, N_P)\n        child = np.concatenate([parent1[:point], parent2[point:]])\n        return child\n\n    def inversion_mutation(individual):\n        # Perform inversion mutation on the individual.\n        point1, point2 = np.sort(np.random.choice(range(N_P), 2, replace=False))\n        individual[point1:point2] = individual[point1:point2][::-1]\n        return individual\n\n    def greedy_repair(individual, weights, capacity, values):\n        # Repair the individual based on combined value/weight ratio.\n        combined_value = np.dot(values, np.ones(values.shape[1]))\n        value_density = combined_value / weights\n        sorted_indices = np.argsort(-value_density)\n        weight = np.dot(individual, weights)\n        for i in sorted_indices:\n            if weight <= capacity:\n                break\n            if individual[i] == 1:\n                individual[i] = 0\n                weight -= weights[i]\n        for i in sorted_indices:\n            if weight >= capacity:\n                break\n            if individual[i] == 0 and weight + weights[i] <= capacity:\n                individual[i] = 1\n                weight += weights[i]\n        return individual\n\n    # Initialize new population array.\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    # Perform roulette wheel selection to get parents.\n    parents = roulette_wheel_selection(pops['individuals'], pops['rankings'])\n    # Generate new population.\n    for i in range(POP_SIZE):\n        # Select parents for crossover.\n        parent1_idx = np.random.randint(0, POP_SIZE)\n        parent2_idx = np.random.randint(0, POP_SIZE)\n        parent1 = parents[parent1_idx]\n        parent2 = parents[parent2_idx]\n        # Perform crossover and mutation.\n        child = single_point_crossover(parent1, parent2)\n        child = inversion_mutation(child)\n        # Repair child to satisfy the weight constraint.\n        child = greedy_repair(child, W, C, V)\n        # Add child to the new population.\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.98842,
          "other_inf": null
     },
     {
          "algorithm": "An algorithm using tournament selection, uniform crossover, and bit-flipping mutation with a greedy repair mechanism.",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    # {An algorithm using tournament selection, uniform crossover, and bit-flipping mutation with a greedy repair mechanism.}\n    import numpy as np\n\n    def tournament_selection(pop, rankings, tournament_size=3):\n        # Select individuals based on tournament selection.\n        selected_indices = []\n        for _ in range(POP_SIZE):\n            participants = np.random.choice(POP_SIZE, tournament_size, replace=False)\n            best_participant = participants[np.argmin(rankings[participants])]\n            selected_indices.append(best_participant)\n        return pop[selected_indices]\n\n    def uniform_crossover(parent1, parent2):\n        # Perform uniform crossover between two parents.\n        mask = np.random.randint(0, 2, size=N_P)\n        child = np.where(mask == 1, parent1, parent2)\n        return child\n\n    def bit_flipping_mutation(individual, mutation_rate=0.05):\n        # Perform bit-flipping mutation on the individual.\n        mutation_mask = np.random.rand(N_P) < mutation_rate\n        individual[mutation_mask] = 1 - individual[mutation_mask]\n        return individual\n\n    def greedy_repair(individual, weights, capacity, values):\n        # Repair the individual based on a greedy approach.\n        combined_value_weight = np.vstack((values.sum(axis=1), weights)).T\n        sorted_items = np.argsort(-combined_value_weight[:, 0] / combined_value_weight[:, 1])\n        weight = np.dot(individual, weights)\n        for i in sorted_items:\n            if weight <= capacity:\n                break\n            if individual[i] == 1:\n                individual[i] = 0\n                weight -= weights[i]\n        for i in sorted_items:\n            if weight >= capacity:\n                break\n            if individual[i] == 0 and weight + weights[i] <= capacity:\n                individual[i] = 1\n                weight += weights[i]\n        return individual\n\n    # Initialize new population array.\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    # Perform tournament selection to get parents.\n    parents = tournament_selection(pops['individuals'], pops['rankings'])\n    # Generate new population.\n    for i in range(0, POP_SIZE, 2):\n        # Select parents for crossover.\n        parent1, parent2 = parents[i % POP_SIZE], parents[(i+1) % POP_SIZE]\n        # Perform crossover and mutation.\n        child1 = uniform_crossover(parent1, parent2)\n        child2 = uniform_crossover(parent2, parent1)\n        child1 = bit_flipping_mutation(child1)\n        child2 = bit_flipping_mutation(child2)\n        # Repair children to satisfy the weight constraint.\n        child1 = greedy_repair(child1, W, C, V)\n        child2 = greedy_repair(child2, W, C, V)\n        # Add children to the new population.\n        new_pops[i] = child1\n        if i + 1 < POP_SIZE:\n            new_pops[i + 1] = child2\n\n    return new_pops",
          "objective": 0.98822,
          "other_inf": null
     },
     {
          "algorithm": "Algorithm using tournament selection, uniform crossover, bit-flip mutation, and greedy repair based on maximum profit.",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    # {Algorithm using tournament selection, uniform crossover, bit-flip mutation, and greedy repair based on maximum profit.}\n    import numpy as np\n    \n    # Tournament selection\n    def tournament_selection(pop, rankings, tournament_size=2):\n        selected_indices = []\n        for _ in range(POP_SIZE):\n            participants = np.random.choice(len(pop), tournament_size, replace=False)\n            winner = participants[np.argmin(rankings[participants])]\n            selected_indices.append(winner)\n        return pop[selected_indices]\n\n    # Uniform crossover\n    def uniform_crossover(parent1, parent2):\n        mask = np.random.randint(0, 2, size=N_P)\n        child = np.where(mask, parent1, parent2)\n        return child\n\n    # Bit-flip mutation\n    def bit_flip_mutation(individual, mutation_rate=0.01):\n        for i in range(N_P):\n            if np.random.rand() < mutation_rate:\n                individual[i] = 1 - individual[i]\n        return individual\n\n    # Greedy repair based on maximum profit\n    def greedy_repair(individual, weights, capacity, values):\n        total_values = np.sum(values, axis=1)\n        profit_weight_ratio = total_values / weights\n        sorted_indices = np.argsort(-profit_weight_ratio)\n        weight_sum = np.dot(weights, individual)\n        for i in sorted_indices:\n            if weight_sum <= capacity:\n                break\n            if individual[i] == 1:\n                individual[i] = 0\n                weight_sum -= weights[i]\n        for i in sorted_indices:\n            if weight_sum + weights[i] <= capacity and individual[i] == 0:\n                individual[i] = 1\n                weight_sum += weights[i]\n        return individual\n\n    # Initialize new population array\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n\n    # Generate new population\n    selected_parents = tournament_selection(pops['individuals'], pops['rankings'])\n    for i in range(0, POP_SIZE, 2):\n        # Select parents for crossover\n        parent1_idx, parent2_idx = np.random.choice(POP_SIZE, 2, replace=False)\n        parent1 = selected_parents[parent1_idx]\n        parent2 = selected_parents[parent2_idx]\n        # Perform crossover and mutation\n        child1 = uniform_crossover(parent1, parent2)\n        child2 = uniform_crossover(parent2, parent1)\n        child1 = bit_flip_mutation(child1)\n        child2 = bit_flip_mutation(child2)\n        # Repair children to satisfy the weight constraint\n        child1 = greedy_repair(child1, W, C, V)\n        child2 = greedy_repair(child2, W, C, V)\n        # Add children to the new population\n        new_pops[i] = child1\n        new_pops[i+1] = child2\n\n    # If POP_SIZE is odd, add one more individual\n    if POP_SIZE % 2 == 1:\n        parent = selected_parents[-1]\n        child = bit_flip_mutation(parent.copy())\n        child = greedy_repair(child, W, C, V)\n        new_pops[-1] = child\n\n    return new_pops",
          "objective": 0.98799,
          "other_inf": null
     },
     {
          "algorithm": "An algorithm using tournament selection, uniform crossover, and bit-flip mutation with a heuristic-based repair mechanism.",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    # {An algorithm using tournament selection, uniform crossover, and bit-flip mutation with a heuristic-based repair mechanism.}\n    import numpy as np\n    \n    # Tournament selection\n    def tournament_selection(pop, rankings, tournament_size=3):\n        selected_indices = []\n        for _ in range(POP_SIZE):\n            participants = np.random.choice(POP_SIZE, tournament_size, replace=False)\n            best_participant = participants[np.argmin(rankings[participants])]\n            selected_indices.append(best_participant)\n        return pop[selected_indices]\n\n    # Uniform crossover\n    def uniform_crossover(parent1, parent2):\n        mask = np.random.randint(0, 2, size=N_P)\n        child = np.where(mask, parent1, parent2)\n        return child\n\n    # Bit-flip mutation\n    def bit_flip_mutation(individual, mutation_rate=0.01):\n        for i in range(N_P):\n            if np.random.rand() < mutation_rate:\n                individual[i] = 1 - individual[i]\n        return individual\n\n    # Heuristic-based repair mechanism\n    def heuristic_repair(individual, weights, capacity, values):\n        current_weight = np.dot(weights, individual)\n        while current_weight > capacity:\n            # Find items to potentially remove (items currently in the knapsack)\n            in_knapsack = np.where(individual == 1)[0]\n            # Calculate efficiency (value/weight ratio) for these items\n            efficiency = np.sum(values[in_knapsack], axis=1) / weights[in_knapsack]\n            # Find the least efficient item\n            least_efficient = in_knapsack[np.argmin(efficiency)]\n            # Remove the least efficient item from the knapsack\n            individual[least_efficient] = 0\n            current_weight -= weights[least_efficient]\n        return individual\n\n    # Initialize new population\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    \n    # Perform tournament selection\n    parents = tournament_selection(pops['individuals'], pops['rankings'])\n    \n    # Generate new population\n    for i in range(0, POP_SIZE, 2):\n        # Select parents for crossover\n        parent1, parent2 = parents[i % POP_SIZE], parents[(i + 1) % POP_SIZE]\n        # Perform crossover and mutation\n        child1 = uniform_crossover(parent1, parent2)\n        child2 = uniform_crossover(parent2, parent1)\n        child1 = bit_flip_mutation(child1)\n        child2 = bit_flip_mutation(child2)\n        # Repair children\n        child1 = heuristic_repair(child1, W, C, V)\n        child2 = heuristic_repair(child2, W, C, V)\n        # Add children to new population\n        new_pops[i] = child1\n        if i + 1 < POP_SIZE:\n            new_pops[i + 1] = child2\n    \n    return new_pops",
          "objective": 0.98798,
          "other_inf": null
     }
]