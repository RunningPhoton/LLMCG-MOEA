[
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n    \n    def crossover(parent1, parent2):\n        # Single point crossover\n        point = np.random.randint(1, N_P)\n        return np.concatenate((parent1[:point], parent2[point:]))\n\n    def mutate(individual):\n        # Randomly flip one gene\n        mutation_point = np.random.randint(N_P)\n        individual[mutation_point] = 1 - individual[mutation_point]\n        return individual\n\n    def repair(individual):\n        # Repair the individual if it violates the weight constraint\n        while np.dot(individual, W) > C:\n            # Randomly drop items until the weight is within the limit\n            overweight_items = np.where((individual == 1) & (W > 0))[0]\n            if overweight_items.size == 0:\n                break\n            drop_item = np.random.choice(overweight_items)\n            individual[drop_item] = 0\n        return individual\n\n    def select_parents(ranked_individuals):\n        # Tournament selection\n        tournament_size = 2\n        selected_indices = np.random.choice(POP_SIZE, size=tournament_size, replace=False)\n        tournament = ranked_individuals[selected_indices]\n        winner_index = selected_indices[np.argmin(pops['rankings'][selected_indices])]\n        return pops['individuals'][winner_index]\n\n    def create_new_individual():\n        # Create a new individual by crossover and mutation\n        parent1 = select_parents(pops['individuals'])\n        parent2 = select_parents(pops['individuals'])\n        child = crossover(parent1, parent2)\n        child = mutate(child)\n        child = repair(child)\n        return child\n\n    # Generate new population\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        new_pops[i] = create_new_individual()\n\n    return new_pops",
          "objective": 0.98583,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    # Novel reproduction function using crossover and mutation without time-consuming search strategies.\n    \n    def crossover(parent1, parent2):\n        # Single-point crossover\n        point = np.random.randint(1, N_P)\n        child = np.hstack((parent1[:point], parent2[point:]))\n        return child\n\n    def mutate(individual):\n        # Randomly flips one gene (item inclusion/exclusion)\n        point = np.random.randint(N_P)\n        individual[point] = 1 - individual[point]\n        return individual\n\n    def repair(individual):\n        # Repair strategy to ensure compliance with weight constraint\n        while np.dot(individual, W) > C:\n            items = np.where(individual == 1)[0]\n            if items.size == 0:\n                break\n            individual[np.random.choice(items)] = 0\n        return individual\n\n    def select_parents(ranked_individuals):\n        # Tournament selection\n        tournament_size = 2\n        selected_indices = np.random.choice(range(POP_SIZE), size=tournament_size, replace=False)\n        selected = ranked_individuals[selected_indices]\n        best = min(selected, key=lambda x: pops['rankings'][x])\n        return pops['individuals'][best]\n\n    # Main steps to generate the next population\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    ranked_individuals = np.argsort(pops['rankings'])\n    for i in range(POP_SIZE):\n        parent1 = select_parents(ranked_individuals)\n        parent2 = select_parents(ranked_individuals)\n        child = crossover(parent1, parent2)\n        if np.random.rand() < 0.1:  # Mutation probability\n            child = mutate(child)\n        child = repair(child)\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.98485,
          "other_inf": null
     },
     {
          "algorithm": "'individuals': new_pops, 'rankings': np.empty(POP_SIZE)",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n    \n    def tournament_selection(pop, rankings, k=3):\n        \"\"\"Select one individual using k-tournament selection.\"\"\"\n        selected_idx = np.random.choice(len(pop), k, replace=False)\n        return pop[selected_idx[np.argmin(rankings[selected_idx])]]\n\n    def crossover(parent1, parent2):\n        \"\"\"Perform uniform crossover between two parents.\"\"\"\n        crossover_mask = np.random.randint(0, 2, size=parent1.shape)\n        child = np.where(crossover_mask == 1, parent1, parent2)\n        return child\n\n    def mutation(individual, mutation_rate=0.1):\n        \"\"\"Mutate an individual with a given mutation rate.\"\"\"\n        mutation_mask = np.random.rand(N_P) < mutation_rate\n        individual[mutation_mask] = 1 - individual[mutation_mask]\n        return individual\n\n    def repair(individual, weights, capacity):\n        \"\"\"Repair an individual so that it satisfies the weight constraint.\"\"\"\n        while np.dot(individual, weights) > capacity:\n            nonzero_indices = np.nonzero(individual)[0]\n            individual[np.random.choice(nonzero_indices)] = 0\n        return individual\n\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        parent1 = tournament_selection(pops['individuals'], pops['rankings'])\n        parent2 = tournament_selection(pops['individuals'], pops['rankings'])\n        child = crossover(parent1, parent2)\n        child = mutation(child)\n        child = repair(child, W, C)\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.91692,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n\n    def tournament_selection(rankings, k=2):\n        \"\"\"Selects individuals for crossover using tournament selection.\"\"\"\n        selected_indices = np.random.choice(len(rankings), k)\n        selected_rankings = rankings[selected_indices]\n        return selected_indices[np.argmin(selected_rankings)]\n\n    def crossover(parent1, parent2):\n        \"\"\"Performs uniform crossover on two parents.\"\"\"\n        mask = np.random.rand(N_P) < 0.5\n        child = np.where(mask, parent1, parent2)\n        return child\n\n    def mutation(individual, mutation_rate=0.1):\n        \"\"\"Mutates an individual with the given mutation rate.\"\"\"\n        for i in range(N_P):\n            if np.random.rand() < mutation_rate:\n                individual[i] = 1 - individual[i]\n        return individual\n\n    def repair(individual):\n        \"\"\"Repairs an individual if it violates the weight constraint.\"\"\"\n        while np.dot(individual, W) > C:\n            # Randomly drop items until the weight constraint is met\n            nonzero_indices = np.nonzero(individual)[0]\n            individual[np.random.choice(nonzero_indices)] = 0\n        return individual\n\n    def generate_new_individual():\n        \"\"\"Generates a new individual through selection, crossover, and mutation.\"\"\"\n        parent1_idx = tournament_selection(pops['rankings'])\n        parent2_idx = tournament_selection(pops['rankings'])\n        child = crossover(pops['individuals'][parent1_idx], pops['individuals'][parent2_idx])\n        child = mutation(child)\n        child = repair(child)\n        return child\n\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        new_pops[i] = generate_new_individual()\n\n    return new_pops",
          "objective": 0.90721,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n    \n    def tournament_selection(rankings, tournament_size):\n        \"\"\"Selects an individual using tournament selection.\"\"\"\n        selected_indices = np.random.choice(range(len(rankings)), tournament_size, replace=False)\n        selected_rankings = rankings[selected_indices]\n        winner_index = selected_indices[np.argmin(selected_rankings)]\n        return winner_index\n\n    def crossover(parent1, parent2):\n        \"\"\"Performs uniform crossover on two parents.\"\"\"\n        child = np.zeros(N_P, dtype=np.int32)\n        for i in range(N_P):\n            child[i] = parent1[i] if np.random.rand() < 0.5 else parent2[i]\n        return child\n\n    def mutate(individual, mutation_rate):\n        \"\"\"Mutates an individual by flipping bits with a certain probability.\"\"\"\n        for i in range(N_P):\n            if np.random.rand() < mutation_rate:\n                individual[i] = 1 - individual[i]\n        return individual\n\n    def repair(individual, W, C):\n        \"\"\"Repairs an individual so that it complies with the weight constraint.\"\"\"\n        while np.dot(individual, W) > C:\n            non_zero_indices = np.where(individual == 1)[0]\n            drop_index = np.random.choice(non_zero_indices)\n            individual[drop_index] = 0\n        return individual\n\n    def create_new_individual(rankings, individuals, W, C, mutation_rate=0.1):\n        \"\"\"Creates a new individual through selection, crossover, mutation, and repair.\"\"\"\n        parent1_index = tournament_selection(rankings, 2)\n        parent2_index = tournament_selection(rankings, 2)\n        parent1 = individuals[parent1_index]\n        parent2 = individuals[parent2_index]\n        child = crossover(parent1, parent2)\n        child = mutate(child, mutation_rate)\n        child = repair(child, W, C)\n        return child\n\n    # Main reproduction function\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    rankings = pops['rankings']\n    individuals = pops['individuals']\n    \n    for i in range(POP_SIZE):\n        new_pops[i] = create_new_individual(rankings, individuals, W, C)\n    \n    return new_pops",
          "objective": 0.90677,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n    \n    def tournament_selection(population, rankings, tournament_size=3):\n        # Select random individuals for the tournament\n        selected_indices = np.random.choice(len(population), tournament_size, replace=False)\n        selected_individuals = rankings[selected_indices]\n        # Find the best individual among the selected\n        winner_index = selected_indices[np.argmin(selected_individuals)]\n        return population[winner_index]\n    \n    def crossover(parent1, parent2):\n        # Single point crossover\n        crossover_point = np.random.randint(1, N_P)\n        child = np.hstack((parent1[:crossover_point], parent2[crossover_point:]))\n        return child\n    \n    def mutate(individual, mutation_rate=0.1):\n        # Random mutation\n        for i in range(N_P):\n            if np.random.rand() < mutation_rate:\n                individual[i] = 1 - individual[i]\n        return individual\n    \n    def repair(individual, weights, capacity):\n        # Repair the individual if it violates the capacity constraint\n        while np.dot(individual, weights) > capacity:\n            # Randomly remove items until the knapsack is not overloaded\n            overloaded_items = np.where((individual == 1) & (weights > 0))[0]\n            item_to_remove = np.random.choice(overloaded_items)\n            individual[item_to_remove] = 0\n        return individual\n    \n    def create_new_individual(population, rankings):\n        # Create a new individual using tournament selection, crossover, and mutation\n        parent1 = tournament_selection(population, rankings)\n        parent2 = tournament_selection(population, rankings)\n        child = crossover(parent1, parent2)\n        child = mutate(child)\n        child = repair(child, W, C)\n        return child\n    \n    # Main reproduction function\n    def reproduce(population, rankings, pop_size):\n        new_population = np.empty((pop_size, N_P), dtype=np.int32)\n        for i in range(pop_size):\n            new_population[i] = create_new_individual(population, rankings)\n        return new_population\n    \n    # Extract individuals and rankings from the population dictionary\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n    \n    # Generate the next generation\n    new_pops = reproduce(individuals, rankings, POP_SIZE)\n    \n    return new_pops",
          "objective": 0.90398,
          "other_inf": null
     },
     {
          "algorithm": "'individuals': new_pops, 'rankings': np.zeros(POP_SIZE)",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n\n    def tournament_selection(population, rankings, tournament_size=3):\n        selected_indices = []\n        for _ in range(POP_SIZE):\n            participants = np.random.choice(range(len(population)), tournament_size, replace=False)\n            winner_index = participants[np.argmin(rankings[participants])]\n            selected_indices.append(winner_index)\n        return np.array(selected_indices)\n\n    def crossover(parent1, parent2):\n        crossover_point = np.random.randint(1, N_P)\n        child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        return child\n\n    def mutate(individual, mutation_rate=0.1):\n        for i in range(N_P):\n            if np.random.rand() < mutation_rate:\n                individual[i] = 1 - individual[i]\n        return individual\n\n    def repair(individual):\n        while np.dot(individual, W) > C:\n            items_to_remove = np.where(individual == 1)[0]\n            if items_to_remove.size == 0:\n                break\n            individual[np.random.choice(items_to_remove)] = 0\n        return individual\n\n    def generate_offspring(population, rankings):\n        selected_indices = tournament_selection(population, rankings)\n        offspring = []\n        for i in range(0, POP_SIZE, 2):\n            parent1 = population[selected_indices[i]]\n            parent2 = population[selected_indices[i + 1] if i + 1 < POP_SIZE else selected_indices[0]]\n            child1 = crossover(parent1, parent2)\n            child2 = crossover(parent2, parent1)\n            child1 = mutate(child1)\n            child2 = mutate(child2)\n            child1 = repair(child1)\n            child2 = repair(child2)\n            offspring.append(child1)\n            offspring.append(child2)\n        return np.array(offspring)\n\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n    new_pops = generate_offspring(individuals, rankings)\n\n    return new_pops",
          "objective": 0.90323,
          "other_inf": null
     },
     {
          "algorithm": "'individuals': new_pops",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n    \n    def tournament_selection(rankings, tournament_size=2):\n        selected_indices = np.random.choice(range(len(rankings)), tournament_size, replace=False)\n        selected_rankings = rankings[selected_indices]\n        winner_index = selected_indices[np.argmin(selected_rankings)]\n        return winner_index\n\n    def crossover(parent1, parent2):\n        crossover_point = np.random.randint(1, N_P)\n        child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        return child\n\n    def mutate(individual, mutation_rate=0.1):\n        for i in range(len(individual)):\n            if np.random.rand() < mutation_rate:\n                individual[i] = 1 - individual[i]\n        return individual\n\n    def repair(individual, W, C):\n        while np.dot(individual, W) > C:\n            nonzero_indices = np.nonzero(individual)[0]\n            if len(nonzero_indices) == 0:\n                break\n            individual[np.random.choice(nonzero_indices)] = 0\n        return individual\n\n    def create_new_individual(pops, W, C):\n        parent1_index = tournament_selection(pops['rankings'])\n        parent2_index = tournament_selection(pops['rankings'])\n        parent1 = pops['individuals'][parent1_index]\n        parent2 = pops['individuals'][parent2_index]\n        child = crossover(parent1, parent2)\n        child = mutate(child)\n        child = repair(child, W, C)\n        return child\n\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    \n    for i in range(POP_SIZE):\n        new_pops[i] = create_new_individual(pops, W, C)\n    \n    return new_pops",
          "objective": 0.89856,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n\n    def tournament_selection(population, rankings, tournament_size=2):\n        \"\"\"Select an individual using tournament selection.\"\"\"\n        selected_indices = np.random.choice(len(rankings), tournament_size, replace=False)\n        selected = np.argmin(rankings[selected_indices])\n        return population[selected_indices[selected]]\n\n    def crossover(parent1, parent2):\n        \"\"\"Perform single-point crossover.\"\"\"\n        crossover_point = np.random.randint(1, N_P)\n        child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        return child\n\n    def mutation(individual, mutation_rate=0.1):\n        \"\"\"Perform mutation with a given mutation rate.\"\"\"\n        for i in range(N_P):\n            if np.random.rand() < mutation_rate:\n                individual[i] = 1 - individual[i]\n        return individual\n\n    def repair(individual):\n        \"\"\"Repair the individual if it violates the weight constraint.\"\"\"\n        while np.sum(individual * W) > C:\n            # Randomly remove items until the weight constraint is satisfied\n            nonzero_indices = np.nonzero(individual)[0]\n            if nonzero_indices.size == 0:\n                break\n            individual[np.random.choice(nonzero_indices)] = 0\n        return individual\n\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        # Select parents\n        parent1 = tournament_selection(pops['individuals'], pops['rankings'])\n        parent2 = tournament_selection(pops['individuals'], pops['rankings'])\n        # Generate offspring\n        child = crossover(parent1, parent2)\n        child = mutation(child)\n        child = repair(child)\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.89757,
          "other_inf": null
     },
     {
          "algorithm": "'individuals': new_pops",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n    \n    def tournament_selection(population, tournament_size):\n        # Select random individuals for the tournament\n        tournament = np.random.choice(population, tournament_size)\n        # Find the best individual in the tournament\n        best_individual = min(tournament, key=lambda ind: pops['rankings'][ind])\n        return best_individual\n\n    def crossover(parent1, parent2):\n        # Single point crossover\n        crossover_point = np.random.randint(1, N_P)\n        child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        return child\n\n    def mutate(individual, mutation_rate):\n        # Randomly mutate each gene with a given mutation rate\n        for i in range(N_P):\n            if np.random.rand() < mutation_rate:\n                individual[i] = 1 - individual[i]\n        return individual\n\n    def repair(individual):\n        # Repair the individual if it violates the weight constraint\n        while np.dot(individual, W) > C:\n            # Randomly remove items until the weight is under the capacity\n            overweight_items = np.where((individual == 1) & (W > 0))[0]\n            if overweight_items.size == 0:\n                break\n            item_to_remove = np.random.choice(overweight_items)\n            individual[item_to_remove] = 0\n        return individual\n\n    def create_new_individual():\n        # Tournament selection for parents\n        parent1_index = tournament_selection(range(POP_SIZE), 2)\n        parent2_index = tournament_selection(range(POP_SIZE), 2)\n        # Crossover to create a new child\n        child = crossover(pops['individuals'][parent1_index], pops['individuals'][parent2_index])\n        # Mutation of the child\n        child = mutate(child, 0.1)\n        # Repair the child if it violates the weight constraint\n        child = repair(child)\n        return child\n\n    # Generate new population\n    new_pops = np.array([create_new_individual() for _ in range(POP_SIZE)], dtype=np.int32)\n    \n    return new_pops",
          "objective": 0.89496,
          "other_inf": null
     }
]