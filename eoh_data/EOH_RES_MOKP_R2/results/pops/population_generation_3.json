[
     {
          "algorithm": "The new algorithm combines greedy selection based on value-to-weight ratio with random sampling and ensures weight constraints are met.",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    # {The new algorithm combines greedy selection based on value-to-weight ratio with random sampling and ensures weight constraints are met.}\n\n    import numpy as np\n\n    # Calculate value-to-weight ratio for each item\n    ratios = np.max(V / W[:, np.newaxis], axis=1)\n\n    # Sort items by their ratio in descending order\n    sorted_indices = np.argsort(-ratios)\n\n    def greedy_individual():\n        # Initialize an empty knapsack\n        individual = np.zeros(N_P, dtype=np.int32)\n        current_weight = 0\n\n        # Add items based on the sorted value-to-weight ratio until the knapsack is full\n        for idx in sorted_indices:\n            if current_weight + W[idx] <= C:\n                individual[idx] = 1\n                current_weight += W[idx]\n        return individual\n\n    def random_sampling():\n        # Initialize an empty knapsack\n        individual = np.zeros(N_P, dtype=np.int32)\n        available_indices = np.arange(N_P)\n        current_weight = 0\n\n        # Randomly add items until the knapsack is full or no items can be added\n        while current_weight <= C and available_indices.size > 0:\n            idx = np.random.choice(available_indices)\n            if current_weight + W[idx] <= C:\n                individual[idx] = 1\n                current_weight += W[idx]\n            available_indices = available_indices[available_indices != idx]\n\n        return individual\n\n    # Generate new population\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        if np.random.rand() < 0.5:\n            new_pops[i] = greedy_individual()\n        else:\n            new_pops[i] = random_sampling()\n\n    return new_pops",
          "objective": 0.98978,
          "other_inf": null
     },
     {
          "algorithm": "Use roulette wheel selection based on rankings, two-point crossover, non-uniform mutation, and greedy repair based on maximum profit-to-weight ratio.",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    # New algorithm: {Use roulette wheel selection based on rankings, two-point crossover, non-uniform mutation, and greedy repair based on maximum profit-to-weight ratio.}\n\n    def roulette_wheel_selection(pop, rankings):\n        # Calculate selection probabilities inversely proportional to rankings\n        max_rank = np.max(rankings)\n        adjusted_fitness = max_rank - rankings + 1\n        probabilities = adjusted_fitness / np.sum(adjusted_fitness)\n        selected_idx = np.random.choice(len(pop), p=probabilities)\n        return pop[selected_idx]\n\n    def two_point_crossover(parent1, parent2):\n        # Perform two-point crossover between two parents\n        points = np.sort(np.random.choice(range(1, N_P), 2, replace=False))\n        child = np.concatenate([parent1[:points[0]], parent2[points[0]:points[1]], parent1[points[1]:]])\n        return child\n\n    def non_uniform_mutation(individual, generation, max_generations):\n        # Perform non-uniform mutation that decreases the mutation range over generations\n        for i in range(N_P):\n            if np.random.rand() < 1.0 / N_P:\n                delta = (1 - (generation / max_generations)) ** 2\n                individual[i] = 1 - individual[i] if np.random.rand() < delta else individual[i]\n        return individual\n\n    def greedy_repair(individual):\n        # Repair the individual by adding items with the highest profit-to-weight ratio until the weight is under capacity\n        if np.dot(individual, W) > C:\n            individual[:] = 0  # Reset individual\n            profit_weight_ratio = np.max(V, axis=1) / W\n            item_indices = np.argsort(-profit_weight_ratio)\n            current_weight = 0\n            for i in item_indices:\n                if current_weight + W[i] <= C:\n                    individual[i] = 1\n                    current_weight += W[i]\n        return individual\n\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    max_generations = 100  # Example value, can be adjusted based on the algorithm's performance\n    current_generation = 0  # This should be passed to the function or managed externally\n    for i in range(POP_SIZE):\n        parent1 = roulette_wheel_selection(pops['individuals'], pops['rankings'])\n        parent2 = roulette_wheel_selection(pops['individuals'], pops['rankings'])\n        child = two_point_crossover(parent1, parent2)\n        child = non_uniform_mutation(child, current_generation, max_generations)\n        child = greedy_repair(child)\n        new_pops[i] = child\n\n    # Update the generation counter if managed internally\n    current_generation = (current_generation + 1) % max_generations\n\n    return new_pops",
          "objective": 0.9872,
          "other_inf": null
     },
     {
          "algorithm": "An algorithm using tournament selection, uniform crossover, and bit-flip mutation with a greedy repair mechanism.",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    # {An algorithm using tournament selection, uniform crossover, and bit-flip mutation with a greedy repair mechanism.}\n    import numpy as np\n\n    def tournament_selection(pop, rankings, tournament_size=3):\n        # Select individuals using tournament selection.\n        selected = []\n        for _ in range(POP_SIZE):\n            contenders_idx = np.random.choice(range(POP_SIZE), tournament_size, replace=False)\n            contenders_rankings = rankings[contenders_idx]\n            winner_idx = contenders_idx[np.argmin(contenders_rankings)]\n            selected.append(pop[winner_idx])\n        return np.array(selected)\n\n    def uniform_crossover(parent1, parent2, crossover_rate=0.5):\n        # Perform uniform crossover between two parents.\n        mask = np.random.rand(N_P) < crossover_rate\n        child = np.where(mask, parent1, parent2)\n        return child\n\n    def bit_flip_mutation(individual, mutation_rate=0.05):\n        # Perform bit-flip mutation on the individual.\n        mutation_mask = np.random.rand(N_P) < mutation_rate\n        individual[mutation_mask] = 1 - individual[mutation_mask]\n        return individual\n\n    def greedy_repair(individual, weights, capacity, values):\n        # Repair the individual greedily based on the value/weight ratio.\n        ratio = values / weights\n        while np.dot(individual, weights) > capacity:\n            included_items = np.where(individual == 1)[0]\n            if included_items.size == 0:\n                break\n            included_ratios = ratio[included_items]\n            item_to_remove = included_items[np.argmin(included_ratios)]\n            individual[item_to_remove] = 0\n        return individual\n\n    # Initialize new population array.\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    # Perform tournament selection to get parents.\n    parents = tournament_selection(pops['individuals'], pops['rankings'])\n    # Generate new population.\n    for i in range(0, POP_SIZE, 2):\n        # Select parents for crossover.\n        parent1, parent2 = parents[i % POP_SIZE], parents[(i+1) % POP_SIZE]\n        # Perform crossover and mutation.\n        child1 = uniform_crossover(parent1, parent2)\n        child2 = uniform_crossover(parent2, parent1)\n        child1 = bit_flip_mutation(child1)\n        child2 = bit_flip_mutation(child2)\n        # Repair children to satisfy the weight constraint.\n        child1 = greedy_repair(child1, W, C, np.sum(V, axis=1))\n        child2 = greedy_repair(child2, W, C, np.sum(V, axis=1))\n        # Add children to the new population.\n        new_pops[i] = child1\n        if i + 1 < POP_SIZE:\n            new_pops[i + 1] = child2\n\n    return new_pops",
          "objective": 0.98707,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n    \n    def tournament_selection(pop, rankings, tournament_size=3):\n        \"\"\"Select one individual using tournament selection.\"\"\"\n        selected_indices = np.random.choice(len(pop), tournament_size, replace=False)\n        selected_rankings = rankings[selected_indices]\n        winner_idx = selected_indices[np.argmin(selected_rankings)]\n        return pop[winner_idx]\n    \n    def uniform_crossover(parent1, parent2):\n        \"\"\"Perform uniform crossover between two parents.\"\"\"\n        mask = np.random.rand(N_P) < 0.5\n        child = np.where(mask, parent1, parent2)\n        return child\n    \n    def mutation(individual, mutation_rate=0.01):\n        \"\"\"Perform mutation on an individual with a given mutation rate.\"\"\"\n        mutation_mask = np.random.rand(N_P) < mutation_rate\n        individual[mutation_mask] = 1 - individual[mutation_mask]\n        return individual\n    \n    def repair(individual, weights, capacity):\n        \"\"\"Repair an individual to meet the weight constraint.\"\"\"\n        while np.dot(individual, weights) > capacity:\n            non_zero_indices = np.nonzero(individual)[0]\n            if non_zero_indices.size == 0:\n                break\n            random_item = np.random.choice(non_zero_indices)\n            individual[random_item] = 0\n        return individual\n    \n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        parent1 = tournament_selection(pops['individuals'], pops['rankings'])\n        parent2 = tournament_selection(pops['individuals'], pops['rankings'])\n        child = uniform_crossover(parent1, parent2)\n        child = mutation(child)\n        child = repair(child, W, C)\n        new_pops[i] = child\n    \n    return new_pops",
          "objective": 0.98679,
          "other_inf": null
     },
     {
          "algorithm": "Uniform crossover combined with rank-based selection and a mutation strategy that favors flipping bits of items with lower weight-to-profit ratios, followed by a repair function that ensures the weight constraint is met by removing items with lower profit-to-weight ratios first.",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n    \n    # Backbone idea: Iteratively create a new population using selection, crossover, mutation, and repair strategies.\n    # New algorithm description: {Uniform crossover combined with rank-based selection and a mutation strategy that favors flipping bits of items with lower weight-to-profit ratios, followed by a repair function that ensures the weight constraint is met by removing items with lower profit-to-weight ratios first.}\n    \n    def rank_based_selection(pop, rankings):\n        probabilities = 1 / (rankings + 1)\n        probabilities /= probabilities.sum()\n        selected_idx = np.random.choice(len(pop), p=probabilities)\n        return pop[selected_idx]\n    \n    def uniform_crossover(parent1, parent2):\n        mask = np.random.randint(0, 2, size=N_P)\n        child = np.where(mask == 1, parent1, parent2)\n        return child\n    \n    def profit_weight_ratio_mutation(individual):\n        profit_weight_ratio = np.min(V, axis=1) / W\n        mutation_probabilities = 1 - profit_weight_ratio / np.sum(profit_weight_ratio)\n        mutation_probabilities /= np.sum(mutation_probabilities)\n        for i in range(N_P):\n            if np.random.rand() < mutation_probabilities[i]:\n                individual[i] = 1 - individual[i]\n        return individual\n    \n    def profit_to_weight_repair(individual):\n        profit_weight_ratio = np.min(V, axis=1) / W\n        while np.dot(individual, W) > C:\n            item_ratios = individual * profit_weight_ratio\n            lowest_ratio_item = np.argmin(item_ratios + (item_ratios == 0) * np.inf)\n            individual[lowest_ratio_item] = 0\n        return individual\n    \n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        parent1 = rank_based_selection(pops['individuals'], pops['rankings'])\n        parent2 = rank_based_selection(pops['individuals'], pops['rankings'])\n        child = uniform_crossover(parent1, parent2)\n        child = profit_weight_ratio_mutation(child)\n        child = profit_to_weight_repair(child)\n        new_pops[i] = child\n    \n    return new_pops",
          "objective": 0.98675,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n    \n    def tournament_selection(pop, rankings, tournament_size=3):\n        \"\"\"Select one individual using tournament selection.\"\"\"\n        selected_indices = np.random.choice(len(pop), tournament_size, replace=False)\n        selected_rankings = rankings[selected_indices]\n        winner_idx = selected_indices[np.argmin(selected_rankings)]\n        return pop[winner_idx]\n\n    def uniform_crossover(parent1, parent2):\n        \"\"\"Perform uniform crossover between two parents.\"\"\"\n        mask = np.random.randint(0, 2, size=N_P)\n        child = np.where(mask, parent1, parent2)\n        return child\n\n    def mutation(individual, mutation_rate=0.01):\n        \"\"\"Perform mutation on an individual.\"\"\"\n        mutation_indices = np.random.rand(N_P) < mutation_rate\n        individual[mutation_indices] = 1 - individual[mutation_indices]\n        return individual\n\n    def repair(individual, weights, capacity):\n        \"\"\"Repair an individual if it violates the weight constraint.\"\"\"\n        while np.dot(individual, weights) > capacity:\n            nonzero_indices = np.nonzero(individual)[0]\n            if nonzero_indices.size == 0:\n                break\n            random_idx = np.random.choice(nonzero_indices)\n            individual[random_idx] = 0\n        return individual\n\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        parent1 = tournament_selection(pops['individuals'], pops['rankings'])\n        parent2 = tournament_selection(pops['individuals'], pops['rankings'])\n        child = uniform_crossover(parent1, parent2)\n        child = mutation(child)\n        child = repair(child, W, C)\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.98671,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n\n    def rank_based_selection(rankings):\n        # Calculate selection probabilities based on rankings\n        ranks = np.max(rankings) + 1 - rankings\n        selection_probs = ranks / np.sum(ranks)\n        selected_index = np.random.choice(range(len(rankings)), p=selection_probs)\n        return selected_index\n\n    def uniform_crossover(parent1, parent2):\n        # Create a child with genes selected randomly from either parent\n        mask = np.random.randint(0, 2, size=len(parent1))\n        child = np.where(mask, parent1, parent2)\n        return child\n\n    def bit_flip_mutation(individual, mutation_rate=0.05):\n        # Flip bits in the individual with a given mutation rate\n        mutation_mask = np.random.rand(len(individual)) < mutation_rate\n        individual[mutation_mask] = 1 - individual[mutation_mask]\n        return individual\n\n    def greedy_repair(individual, W, C):\n        # Repair the individual by removing items until the weight is under capacity\n        while np.dot(individual, W) > C:\n            item_weights = individual * W\n            # Remove the item with the highest weight\n            heaviest = np.argmax(item_weights)\n            individual[heaviest] = 0\n        return individual\n\n    def create_new_individual(pops, W, C):\n        parent1_index = rank_based_selection(pops['rankings'])\n        parent2_index = rank_based_selection(pops['rankings'])\n        parent1 = pops['individuals'][parent1_index]\n        parent2 = pops['individuals'][parent2_index]\n        child = uniform_crossover(parent1, parent2)\n        child = bit_flip_mutation(child)\n        child = greedy_repair(child, W, C)\n        return child\n\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    \n    for i in range(POP_SIZE):\n        new_pops[i] = create_new_individual(pops, W, C)\n    \n    return new_pops",
          "objective": 0.98666,
          "other_inf": null
     },
     {
          "algorithm": "A new algorithm using greedy selection, single-point crossover, and bit-flip mutation followed by a greedy repair mechanism.",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    # {A new algorithm using greedy selection, single-point crossover, and bit-flip mutation followed by a greedy repair mechanism.}\n    import numpy as np\n\n    def greedy_selection(pop, rankings):\n        # Select the top-ranked individuals.\n        sorted_indices = np.argsort(rankings)\n        return pop[sorted_indices[:POP_SIZE // 2]]\n\n    def single_point_crossover(parent1, parent2):\n        # Perform single-point crossover between two parents.\n        crossover_point = np.random.randint(1, N_P)\n        child = np.hstack((parent1[:crossover_point], parent2[crossover_point:]))\n        return child\n\n    def bit_flip_mutation(individual, mutation_rate=0.05):\n        # Perform bit-flip mutation on the individual.\n        for i in range(N_P):\n            if np.random.rand() < mutation_rate:\n                individual[i] = 1 - individual[i]\n        return individual\n\n    def greedy_repair(individual, weights, capacity, values):\n        # Repair the individual greedily based on the value/weight ratio.\n        ratio = values / weights\n        while np.dot(individual, weights) > capacity:\n            # Find items to potentially remove (those included in the knapsack).\n            included_items = np.where(individual == 1)[0]\n            if included_items.size == 0:\n                break\n            # Calculate the value/weight ratio of included items.\n            included_ratios = ratio[included_items]\n            # Find the item with the smallest ratio to remove.\n            item_to_remove = included_items[np.argmin(included_ratios)]\n            individual[item_to_remove] = 0\n        return individual\n\n    # Initialize new population array.\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    # Perform greedy selection to get top individuals.\n    selected = greedy_selection(pops['individuals'], pops['rankings'])\n    # Generate new population.\n    for i in range(0, POP_SIZE, 2):\n        # Select parents for crossover.\n        parent1 = selected[np.random.randint(0, selected.shape[0])]\n        parent2 = selected[np.random.randint(0, selected.shape[0])]\n        # Perform crossover and mutation.\n        child1 = single_point_crossover(parent1, parent2)\n        child2 = single_point_crossover(parent2, parent1)\n        child1 = bit_flip_mutation(child1)\n        child2 = bit_flip_mutation(child2)\n        # Repair children to satisfy the weight constraint.\n        child1 = greedy_repair(child1, W, C, np.sum(V, axis=1))\n        child2 = greedy_repair(child2, W, C, np.sum(V, axis=1))\n        # Add children to the new population.\n        new_pops[i] = child1\n        if i + 1 < POP_SIZE:\n            new_pops[i + 1] = child2\n\n    return new_pops",
          "objective": 0.98648,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n    \n    def rank_based_selection(pop, rankings):\n        \"\"\"Select one individual using rank-based selection.\"\"\"\n        probabilities = 1 / (rankings + 1)\n        probabilities /= probabilities.sum()\n        selected_idx = np.random.choice(len(pop), p=probabilities)\n        return pop[selected_idx]\n\n    def single_point_crossover(parent1, parent2):\n        \"\"\"Perform single point crossover between two parents.\"\"\"\n        crossover_point = np.random.randint(1, N_P)\n        child = np.concatenate([parent1[:crossover_point], parent2[crossover_point:]])\n        return child\n\n    def bit_flip_mutation(individual, mutation_rate=0.05):\n        \"\"\"Perform bit flip mutation on an individual.\"\"\"\n        for i in range(N_P):\n            if np.random.rand() < mutation_rate:\n                individual[i] = 1 - individual[i]\n        return individual\n\n    def greedy_repair(individual, weights, capacity):\n        \"\"\"Repair an individual using a greedy strategy.\"\"\"\n        while np.dot(individual, weights) > capacity:\n            item_weights = individual * weights\n            heaviest = np.argmax(item_weights)\n            individual[heaviest] = 0\n        return individual\n\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        parent1 = rank_based_selection(pops['individuals'], pops['rankings'])\n        parent2 = rank_based_selection(pops['individuals'], pops['rankings'])\n        child = single_point_crossover(parent1, parent2)\n        child = bit_flip_mutation(child)\n        child = greedy_repair(child, W, C)\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.98631,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n\n    def uniform_crossover(parent1, parent2):\n        # Uniform crossover\n        mask = np.random.randint(2, size=N_P)\n        return np.where(mask, parent1, parent2)\n\n    def mutate(individual):\n        # Mutate with a probability of 1/N_P\n        for i in range(N_P):\n            if np.random.rand() < 1.0 / N_P:\n                individual[i] = 1 - individual[i]\n        return individual\n\n    def repair(individual):\n        # Repair the individual if it violates the weight constraint\n        while np.dot(individual, W) > C:\n            overweight_items = np.where(individual * W > 0)[0]\n            if overweight_items.size == 0:\n                break\n            drop_item = np.random.choice(overweight_items)\n            individual[drop_item] = 0\n        return individual\n\n    def rank_based_selection(ranked_individuals):\n        # Rank-based selection\n        probabilities = 1 / (np.arange(POP_SIZE) + 1)\n        probabilities /= probabilities.sum()\n        selected_index = np.random.choice(POP_SIZE, p=probabilities)\n        return pops['individuals'][selected_index]\n\n    def create_new_individual():\n        # Create a new individual by crossover and mutation\n        parent1 = rank_based_selection(pops['individuals'])\n        parent2 = rank_based_selection(pops['individuals'])\n        child = uniform_crossover(parent1, parent2)\n        child = mutate(child)\n        child = repair(child)\n        return child\n\n    # Generate new population\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        new_pops[i] = create_new_individual()\n\n    return new_pops",
          "objective": 0.98623,
          "other_inf": null
     }
]