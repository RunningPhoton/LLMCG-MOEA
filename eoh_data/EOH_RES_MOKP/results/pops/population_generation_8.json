[
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n    \n    # Initialize the new population array\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    \n    # Get individuals and their rankings from input population data\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n    \n    # Calculate multi-objective profit-weight ratio (considering all profit dimensions)\n    # Aggregate profit per item as the mean across multiple objectives\n    aggregate_profits = V.mean(axis=1)\n    profit_weight_ratio = aggregate_profits / W\n    \n    # Sort items based on profit-weight ratio in descending order\n    sorted_indices = np.argsort(-profit_weight_ratio)\n    \n    top_individuals_count = POP_SIZE // 2\n    \n    # Half of the new population comes from top individuals of the current population\n    top_individuals_sorted_by_rank = individuals[np.argsort(rankings)[:top_individuals_count]]\n    new_pops[:top_individuals_count] = top_individuals_sorted_by_rank.copy()\n    \n    # Remainder of the population is filled by a new knapsack filling strategy\n    for i in range(top_individuals_count, POP_SIZE):\n        current_weight = 0\n        knapsack = np.zeros(N_P, dtype=np.int32)\n        \n        # Attempt to fill the knapsack using sorted item indices based on profit/weight ratio\n        for idx in sorted_indices:\n            item_weight = W[idx]\n            if current_weight + item_weight <= C:\n                knapsack[idx] = 1\n                current_weight += item_weight\n            if current_weight >= C:\n                break\n        \n        # Mutation: Introduce variability by toggling random items with low probability\n        mutation_prob = 0.05  # lower probability of mutation for more stability\n        for j in range(N_P):\n            if np.random.rand() < mutation_prob:\n                proposed_change = 1 - knapsack[j]\n                potential_weight_change = W[j] if proposed_change == 1 else -W[j]\n                if current_weight + potential_weight_change <= C:\n                    knapsack[j] = proposed_change\n                    current_weight += potential_weight_change\n        \n        new_pops[i] = knapsack\n    \n    return new_pops",
          "objective": 0.98799,
          "other_inf": null
     },
     {
          "algorithm": "Utilize Fitness Proportional Selection for parents, Bitwise Crossover for child generation,\n    #  and a Greedy Knapsack Solver for weight constraint enforcement using value-weight ratio guidance.",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n    \n    # {Utilize Fitness Proportional Selection for parents, Bitwise Crossover for child generation,\n    #  and a Greedy Knapsack Solver for weight constraint enforcement using value-weight ratio guidance.}\n    \n    individuals = pops['individuals']\n    rankings = pops['rankings']\n\n    # Fitness proportional selection\n    def fitness_proportional_selection():\n        fitness_scores = 1.0 / (1.0 + rankings)\n        probabilities = fitness_scores / np.sum(fitness_scores)\n        # Select two individuals according to their fitness probabilities\n        selected_indices = np.random.choice(POP_SIZE, size=2, p=probabilities, replace=False)\n        return individuals[selected_indices[0]], individuals[selected_indices[1]]\n\n    # Bitwise crossover operation\n    def bitwise_crossover(parent1, parent2):\n        # Random crossover points\n        crossover_mask = np.random.randint(0, 2, size=N_P, dtype=bool)\n        child = np.where(crossover_mask, parent1, parent2)\n        return child\n\n    # Greedy knapsack solver based on item value-weight ratio\n    def greedy_knapsack_solver(individual):\n        value_weight_ratio = np.sum(V, axis=1) / W  # sum across all profits for simplicity\n        item_indices = np.argsort(-value_weight_ratio)  # maximize value/weight ratio, descending order\n        knapsack_weight = 0\n        solution = np.zeros(N_P, dtype=int)\n        for idx in item_indices:\n            if individual[idx] == 1 and knapsack_weight + W[idx] <= C:\n                solution[idx] = 1\n                knapsack_weight += W[idx]\n        return solution\n\n    # Mutation\n    def mutate(child):\n        mutation_rate = 0.01  # Small mutation chance\n        for i in range(N_P):\n            if np.random.rand() < mutation_rate:\n                child[i] = 1 - child[i]  # Flip bit\n        return child\n\n    new_pops = np.zeros_like(individuals)\n    \n    for i in range(POP_SIZE):\n        # Select parents\n        parent1, parent2 = fitness_proportional_selection()\n        # Generate a new child\n        child = bitwise_crossover(parent1, parent2)\n        # Possibly mutate the child\n        child = mutate(child)\n        # Repair child to fit knapsack constraints\n        child = greedy_knapsack_solver(child)\n        # Store in new population\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.98798,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n    \n    # Extract individuals and their rankings\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n    \n    # New population placeholder\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    \n    # Calculate utilities for each item based on a combined score of all profit values divided by weight\n    utilities = np.sum(V / W[:, None], axis=1)\n    \n    # Sort items by their utility in descending order for prioritized packing\n    sorted_items = np.argsort(-utilities)\n    \n    # Strategy:\n    # Use a hybrid approach of elite-preservation and utility-based item selection\n    for i in range(POP_SIZE):\n        # Elite preservation: carry over top ranked individuals directly to new population\n        if i < POP_SIZE // 2:\n            best_individuals = np.argsort(rankings)[:POP_SIZE // 2]\n            new_pops[i] = individuals[best_individuals[i % (POP_SIZE // 2)]].copy()\n        else:\n            # Utility-based item selection for remaining half of the population\n            current_weight = 0\n            new_individual = np.zeros(N_P, dtype=np.int32)\n            \n            # Try to add the highest utility items while the weight limit is not reached\n            for item in sorted_items:\n                if current_weight + W[item] <= C:\n                    new_individual[item] = 1\n                    current_weight += W[item]\n            \n            # Introduce mutation for diversity: randomly switch an item with a fixed probability\n            # This is a simple mutation without additional complexity\n            mutation_probability = 0.05\n            for j in range(N_P):\n                if np.random.rand() < mutation_probability:\n                    # Toggle item index j and check weight constraint\n                    candidate_individual = new_individual.copy()\n                    candidate_individual[j] = 1 - candidate_individual[j]\n                    if np.sum(candidate_individual * W) <= C:\n                        new_individual = candidate_individual\n            \n            new_pops[i] = new_individual\n    \n    return new_pops",
          "objective": 0.98765,
          "other_inf": null
     },
     {
          "algorithm": "Utilize a tournament selection for robust parent selection, apply a uniform crossover, and enforce constraints by item value-density sorting for repair",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n    \n    # Extract the essentials from the dictionary\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n\n    # Destination array for new population\n    new_pops = np.zeros_like(individuals)\n\n    # Backbone idea: Parent selection, crossover mechanism, mutation for diversity, and a mechanism to enforce constraints.\n    # New algorithm: {Utilize a tournament selection for robust parent selection, apply a uniform crossover, and enforce constraints by item value-density sorting for repair}.\n\n    # Calculate value density (value/weight ratio) for repair purposes\n    value_density = V.sum(axis=1) / W\n    sorted_density_indices = np.argsort(-value_density)  # sort indices descending order by value density\n\n    def tournament_selection(k=3):\n        \"\"\" Select one individual using tournament selection. \"\"\"\n        selected_indices = np.random.randint(0, POP_SIZE, k)\n        best_index = selected_indices[np.argmin(rankings[selected_indices])]\n        return individuals[best_index]\n    \n    def uniform_crossover(parent1, parent2):\n        \"\"\" Perform uniform crossover between two parents. \"\"\"\n        mask = np.random.randint(0, 2, size=N_P, dtype=bool)\n        child = np.where(mask, parent1, parent2)\n        return child\n    \n    def repair(individual):\n        \"\"\" Repair individual to meet the knapsack constraint using value-density approach. \"\"\"\n        if np.dot(individual, W) > C:\n            # Begin with an empty knapsack\n            repaired = np.zeros_like(individual)\n            for idx in sorted_density_indices:\n                # Include the item if it does not exceed capacity\n                if individual[idx] == 1 and np.dot(repaired, W) + W[idx] <= C:\n                    repaired[idx] = 1\n            return repaired\n        return individual\n    \n    for i in range(POP_SIZE):\n        parent1 = tournament_selection()\n        parent2 = tournament_selection()\n        child = uniform_crossover(parent1, parent2)\n\n        # Mutation: Randomly flip a bit with a low probability\n        mutation_prob = 0.02\n        mutation_mask = np.random.rand(N_P) < mutation_prob\n        child[mutation_mask] = 1 - child[mutation_mask]\n\n        # Repair the child to ensure it adheres to the weight constraint while seeking optimality\n        child = repair(child)\n\n        # Store in new population\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.98746,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n    \n    # Create an initial structure for the new generation\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    \n    individuals = pops['individuals']\n    rankings = pops['rankings']\n\n    # Use a greedy algorithm inspired slot filling based on profit to weight ratio\n    # Calculate profit to weight ratios\n    profit_to_weight_ratios = np.array([np.sum(V[i] / W[i]) if W[i] > 0 else 0 for i in range(N_P)])\n    \n    # Sort items by descending profit to weight ratio\n    item_order = np.argsort(-profit_to_weight_ratios)\n    \n    for i in range(POP_SIZE):\n        if i < POP_SIZE // 2:\n            # Directly copy half of best individuals based on rankings\n            new_pops[i] = individuals[np.argsort(rankings)[i]].copy()\n        else:\n            # Initialize an empty knapsack\n            knapsack = np.zeros(N_P, dtype=np.int32)\n            current_weight = 0\n\n            # Try to add items in the order of their effective profit/weight ratio\n            for item in item_order:\n                if current_weight + W[item] <= C:\n                    knapsack[item] = 1\n                    current_weight += W[item]\n                \n                # Break if adding more items would exceed capacity\n                if current_weight >= C:\n                    break\n            \n            # Simple mutation: randomly toggle an item in or out with a low probability\n            mutation_rate = 0.1\n            for j in range(N_P):\n                if np.random.rand() < mutation_rate:\n                    proposed_knapsack = knapsack.copy()\n                    proposed_knapsack[j] = 1 - proposed_knapsack[j]\n                    if np.sum(proposed_knapsack * W) <= C:  # Ensure feasibility\n                        knapsack = proposed_knapsack\n\n            new_pops[i] = knapsack\n\n    return new_pops",
          "objective": 0.9872,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n    new_pops = np.zeros_like(individuals)\n\n    # Strategy: Random Immigrant approach with adaptive mutation based on weighted value density and constraint repair.\n\n    # Calculate value density and sort by this metric\n    total_values = V.sum(axis=1)\n    value_density = total_values / W\n    sorted_items_by_density = np.argsort(-value_density)\n\n    def adaptive_mutation(individual, rate=0.05):\n        \"\"\" Mutate individual with a probability based on performance rank. \"\"\"\n        mutation_chance = np.random.rand(N_P)\n        higher_chance_indices = mutation_chance < rate\n        individual[higher_chance_indices] = 1 - individual[higher_chance_indices]\n        return individual\n\n    def repair(individual):\n        \"\"\" Ensure individual is within the weight constraint using the densest items. \"\"\"\n        if np.dot(individual, W) > C:\n            repaired = np.zeros_like(individual)\n            current_weight = 0\n            for idx in sorted_items_by_density:\n                if current_weight + W[idx] <= C:\n                    repaired[idx] = individual[idx]\n                    current_weight += W[idx] * individual[idx]\n                if current_weight >= C:\n                    break\n            return repaired\n        return individual\n\n    def random_immigrant(rate=0.1):\n        \"\"\" Introduce new random solutions to maintain diversity. \"\"\"\n        return np.random.randint(0, 2, size=N_P)\n\n    for i in range(POP_SIZE):\n        if np.random.rand() < 0.1:  # 10% random immigrants\n            new_individual = random_immigrant()\n        else:\n            # Select individual based on rank (prob inversely proportional to rank)\n            probabilities = 1 / (rankings + 1)\n            probabilities /= probabilities.sum()\n            index = np.random.choice(POP_SIZE, p=probabilities)\n            selected_individual = individuals[index]\n            new_individual = adaptive_mutation(selected_individual.copy(), rate=0.02 * (1 + rankings[index]))\n\n        # Repair the mutated (or randomly created) individual\n        new_individual = repair(new_individual)\n\n        new_pops[i] = new_individual\n\n    return new_pops",
          "objective": 0.98679,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n    \n    def calculate_fitness(individual, V):\n        \"\"\"Calculate the fitness of an individual based on the value matrix.\"\"\"\n        return np.sum(individual[:, np.newaxis] * V, axis=0)\n    \n    def check_weight(individual, W, C):\n        \"\"\"Check if the weight of an individual does not exceed the capacity.\"\"\"\n        return np.sum(individual * W) <= C\n    \n    def select_parents_by_ranking(pops):\n        \"\"\"Select parent indices based on weighted probability inversely related to ranking.\"\"\"\n        weights = 1 / (1 + pops['rankings'])\n        weights /= np.sum(weights)\n        selected_idx = np.random.choice(POP_SIZE, size=2, p=weights, replace=False)\n        return pops['individuals'][selected_idx[0]], pops['individuals'][selected_idx[1]]\n\n    # Generate new population\n    new_pops = np.zeros_like(pops['individuals'])\n    \n    for i in range(POP_SIZE):\n        parent1, parent2 = select_parents_by_ranking(pops)\n        \n        # Crossover: Uniform crossover\n        mask = np.random.randint(2, size=N_P)\n        child = np.where(mask, parent1, parent2)\n        \n        # Mutation: Flip a random bit with low probability\n        if np.random.rand() < 0.1:\n            mutation_point = np.random.randint(N_P)\n            child[mutation_point] = 1 - child[mutation_point]\n        \n        # Ensure weight constraint compliance\n        while not check_weight(child, W, C):\n            included_items = np.where(child == 1)[0]\n            if included_items.size == 0:\n                break\n            drop_idx = np.random.choice(included_items)\n            child[drop_idx] = 0\n        \n        new_pops[i, :] = child\n    \n    return new_pops",
          "objective": 0.98638,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n\n    # Access current population's individuals and rankings\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n\n    # Initialize new population container\n    new_pops = np.zeros_like(individuals)\n\n    # Utility to calculate individual profit-weight ratio\n    def profit_weight_ratio(individual):\n        total_value = np.dot(V, individual)  # Dot product accounts for multiple profit values accumulation\n        total_weight = np.dot(W, individual)\n        return np.sum(total_value) / total_weight if total_weight > 0 else 0\n\n    # Utility for knapsack feasibility check and resolution\n    def resolve_knapsack(individual):\n        total_weight = np.dot(W, individual)\n        while total_weight > C and any(individual):\n            # Randomly remove items until the knapsack is no longer overflowing\n            to_remove = np.flatnonzero(individual)\n            item = np.random.choice(to_remove)\n            individual[item] = 0\n            total_weight -= W[item]\n        return individual\n\n    # Generate new population\n    for idx in range(POP_SIZE):\n        # Select two random individuals based on their ranking probabilities\n        prob_selection = 1 / (1.0 + rankings)\n        probs = prob_selection / np.sum(prob_selection)\n        parent_indices = np.random.choice(POP_SIZE, size=2, p=probs, replace=False)\n        parent1, parent2 = individuals[parent_indices[0]], individuals[parent_indices[1]]\n\n        # Recombine parents using Uniform Crossover\n        mask = np.random.randint(0, 2, size=N_P)\n        child = np.where(mask, parent1, parent2)\n\n        # Mutate the child with a bit-flipping procedure\n        mutation_prob = 0.02\n        mutation_mask = np.random.rand(N_P) < mutation_prob\n        child = np.where(mutation_mask, 1 - child, child)\n\n        # Resolve knapsack constraint\n        child = resolve_knapsack(child)\n\n        # Assign the resolved child to the new population\n        new_pops[idx] = child\n\n    return new_pops",
          "objective": 0.98625,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n    \n    # Helper function to calculate fitness values for the population\n    def calculate_fitness(individual, V):\n        return np.sum(individual[:, np.newaxis] * V, axis=0)\n    \n    # Helper function to check if weight limit isn't exceeded\n    def check_weight(individual, W, C):\n        return np.sum(individual * W) <= C\n    \n    # Helper for roulette wheel selection\n    def roulette_selection(pops):\n        max_rank = np.max(pops['rankings'])\n        adjusted_fitness = max_rank + 1 - pops['rankings']\n        total_fitness = np.sum(adjusted_fitness)\n        pick = np.random.rand() * total_fitness\n        current = 0\n        for i in range(len(adjusted_fitness)):\n            current += adjusted_fitness[i]\n            if current > pick:\n                return pops['individuals'][i]\n    \n    # Creating new population array\n    new_pops = np.zeros_like(pops['individuals'])\n    \n    for i in range(POP_SIZE):\n        # Select parents\n        parent1 = roulette_selection(pops)\n        parent2 = roulette_selection(pops)\n        \n        # Crossover - Uniform crossover\n        mask = np.random.randint(2, size=N_P)\n        child = np.where(mask == 1, parent1, parent2)\n        \n        # Mutation - flip a single bit\n        mutation_idx = np.random.randint(N_P)\n        child[mutation_idx] = 1 - child[mutation_idx]\n        \n        # Check and repair for weight constraint\n        while not check_weight(child, W, C):\n            overweight_indexes = np.where(child * W > 0)[0]\n            if len(overweight_indexes) > 0:\n                child[np.random.choice(overweight_indexes)] = 0\n            else:\n                break\n        \n        new_pops[i] = child\n    \n    return new_pops",
          "objective": 0.98623,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n\n    def crossover(a, b):\n        # Two-point crossover\n        cx1, cx2 = sorted(np.random.choice(range(1, N_P), 2, replace=False))\n        child = np.concatenate([a[:cx1], b[cx1:cx2], a[cx2:]])\n        return child\n\n    def mutation(indiv):\n        # Randomly mutate based on mutation rate\n        mutation_rate = 1 / N_P\n        for i in range(N_P):\n            if np.random.rand() < mutation_rate:\n                indiv[i] = 1 - indiv[i]\n        return indiv\n\n    def fix_individual(indiv):\n        while np.dot(indiv, W) > C:\n            overweight_items = np.where(indiv == 1)[0]\n            if overweight_items.size > 0:\n                indiv[np.random.choice(overweight_items)] = 0\n            else:\n                break\n        return indiv\n\n    def select_by_ranked_tournament():\n        tournament_size = 2\n        indices = np.random.choice(range(POP_SIZE), tournament_size, replace=False)\n        subset = pops['rankings'][indices]\n        winner_idx = indices[np.argmin(subset)]\n        return pops['individuals'][winner_idx]\n\n    # Initialize new population\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=int)\n\n    for i in range(POP_SIZE):\n        # Select parents via tournaments based on their ranking\n        parent1 = select_by_ranked_tournament()\n        parent2 = select_by_ranked_tournament()\n        \n        # Crossover to produce a new child\n        child = crossover(parent1, parent2)\n        \n        # Mutate the child produced\n        child = mutation(child)\n        \n        # Fix the individual if it violates the knapsack constraint\n        child = fix_individual(child)\n        \n        # Store in new population\n        new_pops[i, :] = child\n\n    return new_pops",
          "objective": 0.98618,
          "other_inf": null
     }
]