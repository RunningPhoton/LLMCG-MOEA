[
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n    \n    # Get individuals and rankings from input population\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n    \n    # Create a new empty population\n    new_pops = np.zeros_like(individuals)\n    \n    # Fitness function to score each individual based on their total profit and penalty for exceeding weight\n    def fitness(individual):\n        total_weight = np.dot(individual, W)\n        total_profits = np.dot(individual, V)\n        if total_weight > C:\n            return -1  # Heavy penalty if above capacity\n        return np.sum(total_profits)  # Sum of profits as fitness\n\n    # Roulette wheel selection based on rankings\n    def roulette_selection():\n        max_rank = np.max(rankings)\n        inverse_rankings = max_rank - rankings + 1  # Invert rankings for selection probability\n        probabilities = inverse_rankings / np.sum(inverse_rankings)\n        selected_index = np.random.choice(POP_SIZE, p=probabilities)\n        return individuals[selected_index]\n\n    # Perform crossover between two parents to generate a single child\n    def crossover(parent1, parent2):\n        cut_point = np.random.randint(0, N_P)\n        child = np.concatenate([parent1[:cut_point], parent2[cut_point:]])\n        return child\n\n    # Mutation process for generated offspring\n    def mutate(individual):\n        mutation_rate = 0.1\n        for i in range(N_P):\n            if np.random.rand() < mutation_rate:\n                individual[i] = 1 - individual[i]\n                # After mutation, check and fix if the weight exceeds capacity\n                if np.dot(individual, W) > C:\n                    individual[i] = 1 - individual[i]  # revert mutation\n        return individual\n\n    # Main loop to generate new population\n    for i in range(POP_SIZE):\n        # Selection of parents\n        parent1 = roulette_selection()\n        parent2 = roulette_selection()\n        \n        # Crossover to create a child\n        child = crossover(parent1, parent2)\n        \n        # Mutation of the child\n        child = mutate(child)\n        \n        # Fitness evaluation and potential repair\n        while np.dot(child, W) > C:\n            # Randomly set items to 0 until the total weight is under or equal the capacity\n            idxs = np.where(child == 1)[0]\n            if len(idxs) > 0:  # make sure there is something to remove\n                drop_idx = np.random.choice(idxs)\n                child[drop_idx] = 0\n        \n        # Storing the new individual in the new population\n        new_pops[i] = child\n    \n    return new_pops",
          "objective": 0.98583,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n\n    def calculate_fitness(individual, V):\n        return np.sum(individual[:, np.newaxis] * V, axis=0)\n    \n    def check_weight(individual, W, C):\n        return np.sum(individual * W) <= C\n    \n    def tournament_selection(pops, tournament_size=2):\n        indices = np.random.randint(0, pops['individuals'].shape[0], tournament_size)\n        subset = pops['rankings'][indices]\n        winner_idx = indices[np.argmin(subset)]\n        return pops['individuals'][winner_idx]\n\n    # Create new population array\n    new_pops = np.zeros_like(pops['individuals'])\n    \n    for i in range(POP_SIZE):\n        parent1 = tournament_selection(pops)\n        parent2 = tournament_selection(pops)\n        \n        # Crossover: one-point crossover\n        point = np.random.randint(1, N_P)\n        child = np.hstack((parent1[:point], parent2[point:]))\n        \n        # Mutation: flip one random bit\n        mutation_point = np.random.randint(N_P)\n        child[mutation_point] = 1 - child[mutation_point]\n        \n        # Repair mechanism to respect weight constraints\n        while not check_weight(child, W, C):\n            # If overweight, randomly drop an included item\n            included_items = np.where(child == 1)[0]\n            if included_items.size > 0:\n                drop_idx = np.random.choice(included_items)\n                child[drop_idx] = 0\n            else:\n                break\n        \n        new_pops[i, :] = child\n\n    return new_pops",
          "objective": 0.98571,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    # Import necessary library\n    import numpy as np\n\n    # The function uses a controlled propagation strategy enhancing diversity while ensuring weight constraint adherence.\n    # Initialize new population\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    \n    # Rankings from the previous generation\n    rankings = pops['rankings']\n    # Sort indices by rankings (lower is better)\n    sorted_indices = np.argsort(rankings)\n    \n    # Elite preservation - top 10% automatically pass to new generation\n    elite_threshold = int(0.1 * POP_SIZE)\n    for i in range(elite_threshold):\n        new_pops[i] = pops['individuals'][sorted_indices[i]]\n    \n    # Generate the rest of the new population\n    for i in range(elite_threshold, POP_SIZE):\n        # Select two random parents with a preference for lower ranked (better) individuals\n        parents_indices = np.random.choice(sorted_indices[:POP_SIZE // 2], 2, replace=False)\n        parent1 = pops['individuals'][parents_indices[0]]\n        parent2 = pops['individuals'][parents_indices[1]]\n        \n        # Uniform crossover to generate a child\n        mask = np.random.randint(2, size=N_P)\n        child = mask * parent1 + (1 - mask) * parent2\n        \n        # Local adjustment mutation: Randomly change a bit with low probability\n        mutation_index = np.random.randint(N_P)\n        child[mutation_index] = 1 - child[mutation_index]\n        \n        # Repair strategy to handle weight exceedance\n        while np.dot(child, W) > C:\n            heavy_items = np.where((child == 1) & (W > W.mean()))[0]\n            if heavy_items.size > 0:\n                # Preferentially drop heavy items first to quickly resolve capacity issues\n                child[np.random.choice(heavy_items)] = 0\n            else:\n                # If no heavy items, randomly drop any item\n                child[np.random.choice(np.where(child == 1)[0])] = 0\n        \n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.98563,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n    \n    # Individuals and rankings from the current population.\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n    \n    # Initialize new population.\n    new_pops = np.zeros_like(individuals)\n    \n    # Phenotypic Crowding: Individual selection based on feature diversity.\n    def select_diverse_individuals():\n        diversity_scores = np.zeros(POP_SIZE)\n        for i in range(POP_SIZE):\n            for j in range(POP_SIZE):\n                if i != j:\n                    diversity_scores[i] += np.sum(np.abs(individuals[i] - individuals[j]))\n        sorted_indices = np.argsort(-diversity_scores)  # Sort by descending diversity score\n        return individuals[sorted_indices[:POP_SIZE // 2]]  # Select half of the most diverse\n    \n    # Weighted Sum Fitness Evaluation based on both weight and value.\n    def fitness(individual):\n        return np.dot(individual, np.sum(V, axis=1)) / (np.dot(individual, W) + 1)\n\n    # One-point crossover adapted with diversity awareness by considering feature positions.\n    def crossover(parent1, parent2):\n        point = np.random.randint(1, N_P)\n        if np.random.rand() > 0.5:\n            return np.concatenate([parent1[:point], parent2[point:]])\n        else:\n            return np.concatenate([parent2[:point], parent1[point:]])\n\n    # Mutation with adjusted probabilities based on item value-to-weight ratios.\n    def mutate(individual):\n        value_weights = np.sum(V, axis=1) / W\n        mutation_probs = value_weights / np.max(value_weights)\n        mutation_threshold = np.random.rand(N_P)\n        for i in range(N_P):\n            if mutation_threshold[i] < mutation_probs[i] * 0.1:\n                individual[i] = 1 - individual[i]\n        return individual\n                \n    # Validation to ensure compliance with the knapsack constraint.\n    def validate(individual):\n        while np.dot(individual, W) > C:\n            overweight_indices = np.where(individual == 1)[0]\n            item_to_remove = np.random.choice(overweight_indices)\n            individual[item_to_remove] = 0\n        return individual\n\n    # Get a subset of diverse individuals from the current population.\n    diverse_individuals = select_diverse_individuals()\n    \n    # Generate new individuals.\n    for i in range(POP_SIZE):\n        parent1_idx, parent2_idx = np.random.choice(len(diverse_individuals), 2, replace=False)\n        parent1, parent2 = diverse_individuals[parent1_idx], diverse_individuals[parent2_idx]\n        child = crossover(parent1, parent2)\n        child = mutate(child)\n        child = validate(child)\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.98343,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n    \n    individuals = pops['individuals']\n    rankings = pops['rankings']\n\n    new_pops = np.zeros_like(individuals)\n\n    # Blending crossover mixes parent attributes more thoroughly\n    def blend_crossover(parent1, parent2):\n        blend_alpha = 0.5  # Control how much from parent1 and parent2\n        child = np.where(np.random.rand(N_P) < blend_alpha, parent1, parent2)\n        return child\n    \n    # Stochastic universal selection based on rank \n    def sus_selection():\n        selected_indices = np.zeros(POP_SIZE, dtype=int)\n        total_rank = np.sum(rankings)\n        point_interval = total_rank / POP_SIZE\n        start_point = np.random.uniform(0, point_interval)\n        points = [start_point + i * point_interval for i in range(POP_SIZE)]\n        current_member = 0\n        local_sum = rankings[0]\n        for idx in range(POP_SIZE):\n            while local_sum < points[idx]:\n                current_member += 1\n                local_sum += rankings[current_member]\n            selected_indices[idx] = current_member\n        return individuals[selected_indices]\n    \n    # Implement a controlled mutation that might depend on item values\n    def controlled_mutate(individual):\n        mutation_rate = 0.05\n        value_weights = np.sum(V, axis=1) / np.max(np.sum(V, axis=1))\n        random_thresholds = np.random.rand(N_P)\n        for i in range(N_P):\n            if random_thresholds[i] < mutation_rate * value_weights[i]:\n                individual[i] = 1 - individual[i]\n        return individual\n    \n    # Validate weight constraint\n    def weight_validate(individual):\n        while np.dot(individual, W) > C:\n            overload_indices = np.nonzero(individual * W)[0]\n            if overload_indices.size > 0:\n                rand_idx = np.random.choice(overload_indices)\n                individual[rand_idx] = 0\n        return individual\n\n    # Generating new population based on SUS and controlled mutation\n    selected_parents = sus_selection()\n    parents_paired = np.random.permutation(POP_SIZE)  # Random pairings\n    for i in range(0, POP_SIZE, 2):\n        idx1, idx2 = parents_paired[i], parents_paired[(i+1) % POP_SIZE]\n        parent1, parent2 = selected_parents[idx1], selected_parents[idx2]\n        offspring1 = blend_crossover(parent1, parent2)\n        offspring2 = blend_crossover(parent2, parent1)\n        offspring1 = controlled_mutate(offspring1)\n        offspring2 = controlled_mutate(offspring2)\n        new_pops[i] = weight_validate(offspring1)\n        if i + 1 < POP_SIZE:\n            new_pops[i + 1] = weight_validate(offspring2)\n\n    return new_pops",
          "objective": 0.9813,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n    \n    # Extract the current individuals and their rankings\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n    \n    # Initialize the new population array\n    new_pops = np.zeros_like(individuals)\n    \n    # Weighted roulette wheel selection based on inverse rankings (fitness proportionate selection)\n    total_fitness = np.sum(1 / (rankings + 1))  # Avoid division by zero in case of zero ranking\n    selection_probs = (1 / (rankings + 1)) / total_fitness\n    \n    # Reproduction with randomized greedy crossover and fitness-based mutation\n    for i in range(POP_SIZE):\n        # Select two parents based on their probabilities\n        parents = np.random.choice(POP_SIZE, 2, p=selection_probs, replace=False)\n        parent1 = individuals[parents[0]]\n        parent2 = individuals[parents[1]]\n        \n        # Initialize child\n        child = np.zeros(N_P, dtype=np.int32)\n        \n        # Greedy crossover: item by item decide from which parent to take based on a biased coin flip\n        for j in range(N_P):\n            if np.random.random() < 0.5:\n                child[j] = parent1[j]\n            else:\n                child[j] = parent2[j]\n\n        # Mutation based on individual item profitability and capacity fulfilment\n        # More profitable items have lower probability of being toggled off if included, higher if excluded\n        profit_per_item = np.sum(V, axis=1)  # Summing across all objective profits per item\n        max_profit = np.max(profit_per_item)\n        profit_normalized = profit_per_item / max_profit\n        \n        for j in range(N_P):\n            mutation_probability = np.random.random()\n            if child[j] == 1:\n                # If item is included, turn it off more rarely if it's more profitable\n                if mutation_probability < 0.02 * (1 - profit_normalized[j]):\n                    child[j] = 0\n            else:\n                # If item is excluded, turn it on more likely if it's more profitable\n                if mutation_probability < 0.1 * profit_normalized[j]:\n                    child[j] = 1\n        \n        # Ensure the generated child respects the maximum capacity limit\n        while np.dot(child, W) > C:           \n            # Randomly remove items until within the capacity limit\n            ones_indices = np.where(child == 1)[0]\n            if ones_indices.size > 0:\n                remove_idx = np.random.choice(ones_indices)\n                child[remove_idx] = 0\n            else:\n                break  # No items to remove; though highly unlikely since child is overweight\n\n        # Place the generated child in the new population\n        new_pops[i] = child\n    \n    return new_pops",
          "objective": 0.97838,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n\n    new_pops = np.zeros_like(individuals)\n\n    # Modifier function to adjust child based on weighted sum of profits\n    def adjust_by_profits(child):\n        profit_weights = np.sum(V, axis=1) / np.max(np.sum(V, axis=1))\n        for i in range(N_P):\n            if np.random.rand() < profit_weights[i]:\n                child[i] = 1 if np.dot(W, child) + W[i] <= C else 0\n\n    # Inversion mutation for generating diversity\n    def inversion_mutation(child):\n        if np.random.rand() < 0.1:  # Mutation probability\n            start, end = sorted(np.random.choice(N_P, 2, replace=False))\n            child[start:end+1] = np.flip(child[start:end+1])\n        return child\n\n    # Parent selection using exponential ranking\n    def exponential_ranking_selection():\n        probabilities = np.exp(-rankings / np.max(rankings))\n        probabilities /= probabilities.sum()\n        selected_index = np.random.choice(POP_SIZE, p=probabilities)\n        return individuals[selected_index]\n\n    # Generate new population\n    for i in range(POP_SIZE):\n        parent1 = exponential_ranking_selection()\n        parent2 = exponential_ranking_selection()\n\n        # Crossover - Uniform Crossover\n        mask = np.random.rand(N_P) < 0.5\n        child = np.where(mask, parent1, parent2)\n\n        # Applying inversion mutation\n        child = inversion_mutation(child)\n\n        # Adjust child considering profits\n        adjust_by_profits(child)\n\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.97533,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n\n    def fitness(individual):\n        # Calculating the weighted profit which is the sum of weights for selected items\n        total_weight = np.dot(individual, W)\n        total_profit = np.dot(individual, V)\n        if total_weight <= C:\n            return sum(total_profit)  # Add multi-objective profits\n        else:\n            # This return is for invalid solutions, which would be filtered out.\n            return -1\n\n    # Get current individuals and rankings\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n\n    # Select individuals based on ranking (elitism):\n    # Keeping the best half of the population based on rankings\n    top_half = individuals[rankings.argsort()][:POP_SIZE // 2]\n\n    # Generate new population from existing top performing half:\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n\n    # Uniform crossover and mutation:\n    # Each individual in the new population is generated by randomly mixing two parents from top_half and occasionally flipping one bit to introduce randomness\n    for i in range(POP_SIZE):\n        parent1, parent2 = top_half[np.random.choice(len(top_half), 2, replace=False)]\n        crossover_point = np.random.randint(1, N_P)\n        child = np.concatenate([parent1[:crossover_point], parent2[crossover_point:]])\n\n        # Mutation with a probability of 0.05\n        if np.random.rand() < 0.05:\n            mutation_point = np.random.randint(N_P)\n            child[mutation_point] = 1 - child[mutation_point]  # Flip the bit\n\n        # Ensuring that child complies with weight constraint\n        while np.dot(child, W) > C:\n            # Randomly drop items until within weight limit\n            overweight_indices = np.where(child == 1)[0]\n            drop_index = np.random.choice(overweight_indices)\n            child[drop_index] = 0\n\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.97304,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n\n    # Helper function to compute multi-objective fitness of an individual\n    def multi_objective_fitness(individual):\n        total_weight = np.dot(individual, W)\n        total_profits = np.dot(individual, V)\n        if total_weight > C:\n            return -1  # Penalize for exceeding the weight limit\n        else:\n            # Here, sum of all profits represents this individual's objective value\n            return np.sum(total_profits)\n\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n    \n    # Sort individuals by their multi-objective fitness\n    fitness_scores = np.array([multi_objective_fitness(ind) for ind in individuals])\n    sorted_indices = np.argsort(-fitness_scores)  # negative for descending sort\n    \n    # Select the top 50% of the individuals based on fitness scores\n    top_individuals = individuals[sorted_indices][:POP_SIZE // 2]\n\n    # Initialize new population array\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    \n    # Generate new individuals using tournament selection and crossover\n    for i in range(POP_SIZE):\n        # Tournament selection among top individuals\n        idx1, idx2 = np.random.choice(len(top_individuals), 2, replace=False)\n        parent1 = top_individuals[idx1]\n        parent2 = top_individuals[idx2]\n        \n        # Single-point crossover\n        cut_point = np.random.randint(1, N_P)\n        child = np.concatenate((parent1[:cut_point], parent2[cut_point:]))\n        \n        # Mutation: flip one random bit in the child with a probability of 0.05\n        if np.random.rand() < 0.05:\n            mutation_point = np.random.randint(N_P)\n            child[mutation_point] = 1 - child[mutation_point]\n\n        # Ensure the child does not exceed the max weight capacity\n        while np.dot(child, W) > C:\n            overweight_idxs = np.where(child == 1)[0]\n            child[np.random.choice(overweight_idxs)] = 0\n        \n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.97227,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n\n    # Compute multi-objective fitness considering both total profits and weights penalties\n    def multi_objective_fitness(individual):\n        total_weight = np.dot(individual, W)\n        total_profits = np.dot(individual, V)\n        score = np.sum(total_profits, axis=1) if total_weight <= C else np.sum(total_profits) - (total_weight - C) * 100\n        return score\n\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n\n    # Generate probability array for selection based on rankings (inverse ranking probability)\n    probabilities = 1. / (rankings + 1)\n    probabilities /= probabilities.sum()\n    \n    # Parents selection based on their probabilities inversely proportional to their rankings\n    selected_indices = np.random.choice(POP_SIZE, size=POP_SIZE, p=probabilities)\n    selected_parents = individuals[selected_indices]\n\n    # Generate new population with crossover and mutation\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(0, POP_SIZE, 2):\n        if i + 1 >= POP_SIZE:\n            break\n        parent1, parent2 = selected_parents[i], selected_parents[i+1]\n\n        # Uniform crossover\n        mask = np.random.randint(0, 2, size=N_P)\n        child1 = np.where(mask == 1, parent1, parent2)\n        child2 = np.where(mask == 1, parent2, parent1)\n\n        # Mutations with a mutation rate of 0.05\n        mutation_mask1 = np.random.rand(N_P) < 0.05\n        mutation_mask2 = np.random.rand(N_P) < 0.05\n        child1 = np.where(mutation_mask1, 1 - child1, child1)\n        child2 = np.where(mutation_mask2, 1 - child2, child2)\n\n        # Repair function to ensure child does not exceed weight limit\n        def repair(child):\n            while np.dot(child, W) > C:\n                overweight_idxs = np.where(child == 1)[0]\n                if len(overweight_idxs) == 0:\n                    break\n                child[np.random.choice(overweight_idxs)] = 0\n            return child\n        \n        child1 = repair(child1)\n        child2 = repair(child2)\n        \n        new_pops[i] = child1\n        if i + 1 < POP_SIZE:\n            new_pops[i + 1] = child2\n\n    return new_pops",
          "objective": 0.96957,
          "other_inf": null
     }
]