[
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n\n    def calculate_fitness(individual, V):\n        return np.sum(individual[:, np.newaxis] * V, axis=0)\n    \n    def check_weight(individual, W, C):\n        return np.sum(individual * W) <= C\n    \n    def tournament_selection(pops, tournament_size=2):\n        indices = np.random.randint(0, pops['individuals'].shape[0], tournament_size)\n        subset = pops['rankings'][indices]\n        winner_idx = indices[np.argmin(subset)]\n        return pops['individuals'][winner_idx]\n\n    # Create new population array\n    new_pops = np.zeros_like(pops['individuals'])\n    \n    for i in range(POP_SIZE):\n        parent1 = tournament_selection(pops)\n        parent2 = tournament_selection(pops)\n        \n        # Crossover: one-point crossover\n        point = np.random.randint(1, N_P)\n        child = np.hstack((parent1[:point], parent2[point:]))\n        \n        # Mutation: flip one random bit\n        mutation_point = np.random.randint(N_P)\n        child[mutation_point] = 1 - child[mutation_point]\n        \n        # Repair mechanism to respect weight constraints\n        while not check_weight(child, W, C):\n            # If overweight, randomly drop an included item\n            included_items = np.where(child == 1)[0]\n            if included_items.size > 0:\n                drop_idx = np.random.choice(included_items)\n                child[drop_idx] = 0\n            else:\n                break\n        \n        new_pops[i, :] = child\n\n    return new_pops",
          "objective": 0.98571,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n\n    def fitness(individual):\n        # Calculating the weighted profit which is the sum of weights for selected items\n        total_weight = np.dot(individual, W)\n        total_profit = np.dot(individual, V)\n        if total_weight <= C:\n            return sum(total_profit)  # Add multi-objective profits\n        else:\n            # This return is for invalid solutions, which would be filtered out.\n            return -1\n\n    # Get current individuals and rankings\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n\n    # Select individuals based on ranking (elitism):\n    # Keeping the best half of the population based on rankings\n    top_half = individuals[rankings.argsort()][:POP_SIZE // 2]\n\n    # Generate new population from existing top performing half:\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n\n    # Uniform crossover and mutation:\n    # Each individual in the new population is generated by randomly mixing two parents from top_half and occasionally flipping one bit to introduce randomness\n    for i in range(POP_SIZE):\n        parent1, parent2 = top_half[np.random.choice(len(top_half), 2, replace=False)]\n        crossover_point = np.random.randint(1, N_P)\n        child = np.concatenate([parent1[:crossover_point], parent2[crossover_point:]])\n\n        # Mutation with a probability of 0.05\n        if np.random.rand() < 0.05:\n            mutation_point = np.random.randint(N_P)\n            child[mutation_point] = 1 - child[mutation_point]  # Flip the bit\n\n        # Ensuring that child complies with weight constraint\n        while np.dot(child, W) > C:\n            # Randomly drop items until within weight limit\n            overweight_indices = np.where(child == 1)[0]\n            drop_index = np.random.choice(overweight_indices)\n            child[drop_index] = 0\n\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.97304,
          "other_inf": null
     },
     {
          "algorithm": "The novel reproduction function adopts random mutation-based crossover mechanisms, producing offspring by mixing parent genes and altering them slightly while considering non-dominance and weight constraints through elitism and heuristic mutation strategies.",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n    \n    individuals = pops['individuals']\n    rankings = pops['rankings']\n    \n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    \n    # Select elite individuals\n    elite_count = POP_SIZE // 5  # Taking top 20% as elite\n    elite_indices = np.argsort(rankings)[:elite_count]\n    elites = individuals[elite_indices]\n    \n    # Fill part of the new population with elites\n    new_pops[:elite_count] = elites.copy()\n    \n    # Mutation and crossover to create new individuals\n    for i in range(elite_count, POP_SIZE):\n        # Pick two different random parents from elite set\n        parents_indices = np.random.choice(elite_indices, 2, replace=False)\n        parent1 = individuals[parents_indices[0]]\n        parent2 = individuals[parents_indices[1]]\n        \n        # Single-point crossover\n        point = np.random.randint(1, N_P)\n        child = np.hstack((parent1[:point], parent2[point:]))\n\n        # Mutation: random flip of bits with low probability\n        mutation_prob = 0.05\n        for j in range(N_P):\n            if np.random.random() < mutation_prob:\n                child[j] = 1 - child[j]\n\n        # Ensure child respects the knapsack capacity constraint\n        while np.dot(child, W) > C:\n            # Identify items to potentially remove (randomly find set bits and try turning some off)\n            nonzero_indices = np.where(child == 1)[0]\n            if len(nonzero_indices) == 0:\n                break\n            child[np.random.choice(nonzero_indices)] = 0\n        \n        new_pops[i] = child\n    \n    return new_pops",
          "objective": 0.96594,
          "other_inf": null
     },
     {
          "algorithm": "A novel reproduction function for a multi-objective knapsack problem using mutation-based strategy that emphasizes lightweight cross mutations and elite retention for generating the next generation with adherence to weight constraints.",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n    \n    # Extract individuals and rankings\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n    \n    # Initialize new population\n    new_pops = np.zeros_like(individuals)\n\n    # Elite selection: top 10% unchanged\n    elite_size = int(0.1 * POP_SIZE)\n    elite_indices = np.argsort(rankings)[:elite_size]\n    new_pops[:elite_size] = individuals[elite_indices]\n\n    # Generation of new individuals for non-elite 90%\n    for i in range(elite_size, POP_SIZE):\n        # Select two different parents from the top 50% based on rankings\n        potential_parents = np.argsort(rankings)[:POP_SIZE // 2]\n        parent1, parent2 = np.random.choice(potential_parents, 2, replace=False)\n\n        # Cross Mutation: mix genes of both parents, introduce random mutations\n        child = np.where(np.random.rand(N_P) < 0.5, individuals[parent1], individuals[parent2])\n        mutation_mask = np.random.rand(N_P) < 0.1  # mutation rate of 10%\n        child = np.where(mutation_mask, 1 - child, child)\n\n        # Resolve weight constraint violations\n        while np.dot(W, child) > C:\n            # Randomly drop items until within capacity\n            indices_to_drop = np.where(child == 1)[0]\n            if len(indices_to_drop) > 0:\n                dropped_index = np.random.choice(indices_to_drop)\n                child[dropped_index] = 0\n            else:\n                break\n\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.9256,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n    \n    individuals = pops['individuals']\n    rankings = pops['rankings']\n    \n    # Allocate space for the new population\n    new_pops = np.zeros_like(individuals)\n    \n    # Tournament selection based on rankings to keep diversity\n    def tournament_selection():\n        candidates = np.random.choice(POP_SIZE, size=2, replace=False)\n        if rankings[candidates[0]] < rankings[candidates[1]]:\n            return individuals[candidates[0]]\n        else:\n            return individuals[candidates[1]]\n    \n    # Crossover operation to generate new offspring\n    def crossover(parent1, parent2):\n        crossover_point = np.random.randint(0, N_P)\n        child = np.concatenate([parent1[:crossover_point], parent2[crossover_point:]])\n        return child\n    \n    # Mutation operation to maintain genetic diversity\n    def mutate(individual):\n        mutation_prob = 0.1\n        for i in range(N_P):\n            if np.random.rand() < mutation_prob:\n                individual[i] = 1 - individual[i]\n        return individual\n    \n    # Ensure the generated individual respects the knapsack constraint\n    def validate(individual):\n        while np.dot(individual, W) > C:\n            # Randomly deselect items until the weight is under capacity\n            positive_indices = np.where(individual == 1)[0]\n            if positive_indices.size > 0:\n                deselect_index = np.random.choice(positive_indices)\n                individual[deselect_index] = 0\n        return individual\n    \n    # Generate new population\n    for i in range(POP_SIZE):\n        parent1 = tournament_selection()\n        parent2 = tournament_selection()\n        child = crossover(parent1, parent2)\n        child = mutate(child)\n        child = validate(child)\n        new_pops[i] = child\n    \n    return new_pops",
          "objective": 0.90102,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n    \n    def mutate(individual):\n        mutation_rate = 0.1\n        for i in range(len(individual)):\n            if np.random.rand() < mutation_rate:\n                individual[i] = 1 - individual[i]\n        return individual\n\n    def repair(individual):\n        while np.dot(individual, W) > C:\n            overweight_items = [index for index in range(len(individual)) if individual[index] > 0]\n            drop_index = np.random.choice(overweight_items)\n            individual[drop_index] = 0\n        return individual\n    \n    def create_new_individual():\n        return np.random.randint(2, size=N_P)\n\n    def crossover(parent1, parent2):\n        crossover_point = np.random.randint(1, N_P)\n        child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        return child\n    \n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    fitness = 1 / (1 + pops['rankings'])\n    fitness /= fitness.sum()\n    selected_indices = np.random.choice(a=POP_SIZE, size=POP_SIZE, replace=True, p=fitness)\n    selected_individuals = pops['individuals'][selected_indices, :]\n    \n    for i in range(0, POP_SIZE, 2):\n        if i + 1 < POP_SIZE:\n            parent1, parent2 = selected_individuals[i], selected_individuals[i+1]\n            child1 = crossover(parent1, parent2)\n            child2 = crossover(parent2, parent1)\n            child1 = mutate(child1)\n            child2 = mutate(child2)\n            new_pops[i] = repair(child1)\n            new_pops[i+1] = repair(child2)\n        else:\n            new_pops[i] = repair(create_new_individual())\n    \n    return new_pops",
          "objective": 0.89855,
          "other_inf": null
     },
     {
          "algorithm": "Design a novel reproduction function for the multi-objective knapsack problem using a deterministic crowding genetic algorithm approach combined with a mutation strategy that adapts to the weight constraints to maintain population diversity while ensuring feasibility.",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n    new_pops = np.zeros_like(individuals)\n\n    # Tournament selection based on rankings and deterministic crowding\n    for i in range(POP_SIZE):\n        candidate1 = np.random.choice(POP_SIZE)\n        candidate2 = np.random.choice(POP_SIZE)\n        \n        if rankings[candidate1] < rankings[candidate2]:\n            winner = candidate1\n        else:\n            winner = candidate2\n        \n        # Clone the winner to the new population\n        new_pops[i] = np.copy(individuals[winner])\n        \n        # Mutation: Randomly flip bits with a probability decreasing with item weight\n        mutation_rate = 0.1\n        for j in range(N_P):\n            if np.random.rand() < mutation_rate * (1 - W[j] / C):\n                new_pops[i, j] = 1 - new_pops[i, j]\n\n        # Repair mechanism to ensure the knapsack does not exceed capacity\n        while np.dot(new_pops[i], W) > C:\n            # Randomly drop items until the weight is within the limit\n            overweight_items = np.where(new_pops[i] * W > 0)[0]\n            if overweight_items.size > 0:\n                item_to_remove = np.random.choice(overweight_items)\n                new_pops[i, item_to_remove] = 0\n            else:\n                break\n\n    return new_pops",
          "objective": 0.89696,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n    \n    def repair(individual, weights, capacity):\n        # Ensure compatibility with weight constraint by removing items until within the capacity limit\n        while np.sum(individual * weights) > capacity:\n            heavy_items = np.where((individual * weights) > 0)[0]\n            individual[np.random.choice(heavy_items)] = 0\n        return individual\n\n    def crossover(parent1, parent2):\n        # Single point crossover\n        point = np.random.randint(N_P)\n        child = np.concatenate([parent1[:point], parent2[point:]])\n        return child\n\n    def mutate(individual, mutation_rate=0.1):\n        # Simple mutation which flips bits with a certain mutation rate\n        mutation_mask = np.random.rand(N_P) < mutation_rate\n        individual[mutation_mask] = 1 - individual[mutation_mask]\n        return individual\n\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n    \n    # Select parents based on ranking: better ranked individuals are more likely to be parents\n    probabilities = 1 / (rankings + 1)  # Make probabilities inversely related to the ranks\n    probabilities /= probabilities.sum()  # Normalize to form a probability distribution\n\n    new_population = []\n\n    while len(new_population) < POP_SIZE:\n        # Tournament selection for parents\n        parents_indices = np.random.choice(len(individuals), size=2, p=probabilities, replace=True)\n        parent1, parent2 = individuals[parents_indices[0]], individuals[parents_indices[1]]\n\n        # Crossover to create a child\n        child = crossover(parent1, parent2)\n\n        # Mutate the child\n        child = mutate(child)\n\n        # Repair the child\n        child = repair(child, W, C)\n\n        # Add the repaired child to the new population\n        new_population.append(child)\n\n    new_pops = np.array(new_population, dtype=np.int32)\n    return new_pops",
          "objective": 0.89399,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n    \n    # Extracting individuals and rankings\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n    \n    # Initialize new population array\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    \n    # Tournament selection based on ranking\n    def tournament_selection(k=2):\n        selected_indices = np.random.choice(POP_SIZE, k, replace=False)\n        selected_rankings = rankings[selected_indices]\n        return individuals[selected_indices[np.argmin(selected_rankings)]]\n\n    # Single point crossover\n    def crossover(parent1, parent2):\n        if np.random.rand() < 0.9:  # Crossover probability\n            point = np.random.randint(1, N_P)\n            child = np.concatenate([parent1[:point], parent2[point:]])\n        else:\n            child = parent1.copy()\n        return child\n\n    # Mutation with mutation probability ensuring weights are within limits\n    def mutate(individual):\n        mutation_prob = 0.1\n        for i in range(N_P):\n            if np.random.rand() < mutation_prob:\n                individual[i] = 1 - individual[i]  # Flip bit\n                \n                # Check if the new individual exceeds the weight\n                if np.dot(individual, W) > C:\n                    individual[i] = 1 - individual[i]  # Revert if exceeded\n        return individual\n\n    # Generate new population\n    for i in range(POP_SIZE):\n        # Select parents\n        parent1 = tournament_selection()\n        parent2 = tournament_selection()\n        \n        # Crossover parents to create a new child\n        child = crossover(parent1, parent2)\n        \n        # Mutate the child\n        child = mutate(child)\n        \n        # Assign child to new population\n        new_pops[i, :] = child\n    \n    return new_pops",
          "objective": 0.8403,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n    \n    def calculate_total_weight(individual):\n        return np.sum(individual * W)\n    \n    def calculate_total_value(individual, value_dimension):\n        return np.sum(individual[:, None] * V, axis=0)[value_dimension]\n\n    def mutate(individual, mutation_rate=0.1):\n        mutation_mask = np.random.rand(N_P) < mutation_rate\n        new_individual = np.copy(individual)\n        new_individual[mutation_mask] = 1 - new_individual[mutation_mask]\n        if calculate_total_weight(new_individual) <= C:\n            return new_individual\n        return individual\n    \n    def crossover(parent1, parent2):\n        crossover_point = np.random.randint(1, N_P)\n        child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        if calculate_total_weight(child) <= C:\n            return child\n        return parent1 if calculate_total_value(parent1, 0) > calculate_total_value(parent2, 0) else parent2\n    \n    individuals = pops['individuals']\n    rankings = pops['rankings']\n    new_pops = np.zeros_like(individuals)\n    \n    # Selection process\n    sorted_indices = np.argsort(rankings)\n    elite_size = POP_SIZE // 5  # Elites are directly passed to the new population\n    new_pops[:elite_size] = individuals[sorted_indices[:elite_size]]\n    \n    # Generate new individuals via crossover and mutation\n    for i in range(elite_size, POP_SIZE):\n        parent1_idx = np.random.choice(sorted_indices[:POP_SIZE // 2])\n        parent2_idx = np.random.choice(sorted_indices[:POP_SIZE // 2])\n        parent1 = individuals[parent1_idx]\n        parent2 = individuals[parent2_idx]\n        child = crossover(parent1, parent2)\n        child = mutate(child)\n        new_pops[i] = child\n    \n    return new_pops",
          "objective": 0.74739,
          "other_inf": null
     }
]