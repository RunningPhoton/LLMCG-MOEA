[
     {
          "algorithm": "Utilize Fitness Proportional Selection for parents, Bitwise Crossover for child generation,\n    #  and a Greedy Knapsack Solver for weight constraint enforcement using value-weight ratio guidance.",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n    \n    # {Utilize Fitness Proportional Selection for parents, Bitwise Crossover for child generation,\n    #  and a Greedy Knapsack Solver for weight constraint enforcement using value-weight ratio guidance.}\n    \n    individuals = pops['individuals']\n    rankings = pops['rankings']\n\n    # Fitness proportional selection\n    def fitness_proportional_selection():\n        fitness_scores = 1.0 / (1.0 + rankings)\n        probabilities = fitness_scores / np.sum(fitness_scores)\n        # Select two individuals according to their fitness probabilities\n        selected_indices = np.random.choice(POP_SIZE, size=2, p=probabilities, replace=False)\n        return individuals[selected_indices[0]], individuals[selected_indices[1]]\n\n    # Bitwise crossover operation\n    def bitwise_crossover(parent1, parent2):\n        # Random crossover points\n        crossover_mask = np.random.randint(0, 2, size=N_P, dtype=bool)\n        child = np.where(crossover_mask, parent1, parent2)\n        return child\n\n    # Greedy knapsack solver based on item value-weight ratio\n    def greedy_knapsack_solver(individual):\n        value_weight_ratio = np.sum(V, axis=1) / W  # sum across all profits for simplicity\n        item_indices = np.argsort(-value_weight_ratio)  # maximize value/weight ratio, descending order\n        knapsack_weight = 0\n        solution = np.zeros(N_P, dtype=int)\n        for idx in item_indices:\n            if individual[idx] == 1 and knapsack_weight + W[idx] <= C:\n                solution[idx] = 1\n                knapsack_weight += W[idx]\n        return solution\n\n    # Mutation\n    def mutate(child):\n        mutation_rate = 0.01  # Small mutation chance\n        for i in range(N_P):\n            if np.random.rand() < mutation_rate:\n                child[i] = 1 - child[i]  # Flip bit\n        return child\n\n    new_pops = np.zeros_like(individuals)\n    \n    for i in range(POP_SIZE):\n        # Select parents\n        parent1, parent2 = fitness_proportional_selection()\n        # Generate a new child\n        child = bitwise_crossover(parent1, parent2)\n        # Possibly mutate the child\n        child = mutate(child)\n        # Repair child to fit knapsack constraints\n        child = greedy_knapsack_solver(child)\n        # Store in new population\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.98798,
          "other_inf": null
     },
     {
          "algorithm": "Utilize a tournament selection for robust parent selection, apply a uniform crossover, and enforce constraints by item value-density sorting for repair",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n    \n    # Extract the essentials from the dictionary\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n\n    # Destination array for new population\n    new_pops = np.zeros_like(individuals)\n\n    # Backbone idea: Parent selection, crossover mechanism, mutation for diversity, and a mechanism to enforce constraints.\n    # New algorithm: {Utilize a tournament selection for robust parent selection, apply a uniform crossover, and enforce constraints by item value-density sorting for repair}.\n\n    # Calculate value density (value/weight ratio) for repair purposes\n    value_density = V.sum(axis=1) / W\n    sorted_density_indices = np.argsort(-value_density)  # sort indices descending order by value density\n\n    def tournament_selection(k=3):\n        \"\"\" Select one individual using tournament selection. \"\"\"\n        selected_indices = np.random.randint(0, POP_SIZE, k)\n        best_index = selected_indices[np.argmin(rankings[selected_indices])]\n        return individuals[best_index]\n    \n    def uniform_crossover(parent1, parent2):\n        \"\"\" Perform uniform crossover between two parents. \"\"\"\n        mask = np.random.randint(0, 2, size=N_P, dtype=bool)\n        child = np.where(mask, parent1, parent2)\n        return child\n    \n    def repair(individual):\n        \"\"\" Repair individual to meet the knapsack constraint using value-density approach. \"\"\"\n        if np.dot(individual, W) > C:\n            # Begin with an empty knapsack\n            repaired = np.zeros_like(individual)\n            for idx in sorted_density_indices:\n                # Include the item if it does not exceed capacity\n                if individual[idx] == 1 and np.dot(repaired, W) + W[idx] <= C:\n                    repaired[idx] = 1\n            return repaired\n        return individual\n    \n    for i in range(POP_SIZE):\n        parent1 = tournament_selection()\n        parent2 = tournament_selection()\n        child = uniform_crossover(parent1, parent2)\n\n        # Mutation: Randomly flip a bit with a low probability\n        mutation_prob = 0.02\n        mutation_mask = np.random.rand(N_P) < mutation_prob\n        child[mutation_mask] = 1 - child[mutation_mask]\n\n        # Repair the child to ensure it adheres to the weight constraint while seeking optimality\n        child = repair(child)\n\n        # Store in new population\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.98746,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n    \n    # Create an initial structure for the new generation\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    \n    individuals = pops['individuals']\n    rankings = pops['rankings']\n\n    # Use a greedy algorithm inspired slot filling based on profit to weight ratio\n    # Calculate profit to weight ratios\n    profit_to_weight_ratios = np.array([np.sum(V[i] / W[i]) if W[i] > 0 else 0 for i in range(N_P)])\n    \n    # Sort items by descending profit to weight ratio\n    item_order = np.argsort(-profit_to_weight_ratios)\n    \n    for i in range(POP_SIZE):\n        if i < POP_SIZE // 2:\n            # Directly copy half of best individuals based on rankings\n            new_pops[i] = individuals[np.argsort(rankings)[i]].copy()\n        else:\n            # Initialize an empty knapsack\n            knapsack = np.zeros(N_P, dtype=np.int32)\n            current_weight = 0\n\n            # Try to add items in the order of their effective profit/weight ratio\n            for item in item_order:\n                if current_weight + W[item] <= C:\n                    knapsack[item] = 1\n                    current_weight += W[item]\n                \n                # Break if adding more items would exceed capacity\n                if current_weight >= C:\n                    break\n            \n            # Simple mutation: randomly toggle an item in or out with a low probability\n            mutation_rate = 0.1\n            for j in range(N_P):\n                if np.random.rand() < mutation_rate:\n                    proposed_knapsack = knapsack.copy()\n                    proposed_knapsack[j] = 1 - proposed_knapsack[j]\n                    if np.sum(proposed_knapsack * W) <= C:  # Ensure feasibility\n                        knapsack = proposed_knapsack\n\n            new_pops[i] = knapsack\n\n    return new_pops",
          "objective": 0.9872,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n    \n    def calculate_fitness(individual, V):\n        \"\"\"Calculate the fitness of an individual based on the value matrix.\"\"\"\n        return np.sum(individual[:, np.newaxis] * V, axis=0)\n    \n    def check_weight(individual, W, C):\n        \"\"\"Check if the weight of an individual does not exceed the capacity.\"\"\"\n        return np.sum(individual * W) <= C\n    \n    def select_parents_by_ranking(pops):\n        \"\"\"Select parent indices based on weighted probability inversely related to ranking.\"\"\"\n        weights = 1 / (1 + pops['rankings'])\n        weights /= np.sum(weights)\n        selected_idx = np.random.choice(POP_SIZE, size=2, p=weights, replace=False)\n        return pops['individuals'][selected_idx[0]], pops['individuals'][selected_idx[1]]\n\n    # Generate new population\n    new_pops = np.zeros_like(pops['individuals'])\n    \n    for i in range(POP_SIZE):\n        parent1, parent2 = select_parents_by_ranking(pops)\n        \n        # Crossover: Uniform crossover\n        mask = np.random.randint(2, size=N_P)\n        child = np.where(mask, parent1, parent2)\n        \n        # Mutation: Flip a random bit with low probability\n        if np.random.rand() < 0.1:\n            mutation_point = np.random.randint(N_P)\n            child[mutation_point] = 1 - child[mutation_point]\n        \n        # Ensure weight constraint compliance\n        while not check_weight(child, W, C):\n            included_items = np.where(child == 1)[0]\n            if included_items.size == 0:\n                break\n            drop_idx = np.random.choice(included_items)\n            child[drop_idx] = 0\n        \n        new_pops[i, :] = child\n    \n    return new_pops",
          "objective": 0.98638,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n\n    def crossover(a, b):\n        # Two-point crossover\n        cx1, cx2 = sorted(np.random.choice(range(1, N_P), 2, replace=False))\n        child = np.concatenate([a[:cx1], b[cx1:cx2], a[cx2:]])\n        return child\n\n    def mutation(indiv):\n        # Randomly mutate based on mutation rate\n        mutation_rate = 1 / N_P\n        for i in range(N_P):\n            if np.random.rand() < mutation_rate:\n                indiv[i] = 1 - indiv[i]\n        return indiv\n\n    def fix_individual(indiv):\n        while np.dot(indiv, W) > C:\n            overweight_items = np.where(indiv == 1)[0]\n            if overweight_items.size > 0:\n                indiv[np.random.choice(overweight_items)] = 0\n            else:\n                break\n        return indiv\n\n    def select_by_ranked_tournament():\n        tournament_size = 2\n        indices = np.random.choice(range(POP_SIZE), tournament_size, replace=False)\n        subset = pops['rankings'][indices]\n        winner_idx = indices[np.argmin(subset)]\n        return pops['individuals'][winner_idx]\n\n    # Initialize new population\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=int)\n\n    for i in range(POP_SIZE):\n        # Select parents via tournaments based on their ranking\n        parent1 = select_by_ranked_tournament()\n        parent2 = select_by_ranked_tournament()\n        \n        # Crossover to produce a new child\n        child = crossover(parent1, parent2)\n        \n        # Mutate the child produced\n        child = mutation(child)\n        \n        # Fix the individual if it violates the knapsack constraint\n        child = fix_individual(child)\n        \n        # Store in new population\n        new_pops[i, :] = child\n\n    return new_pops",
          "objective": 0.98618,
          "other_inf": null
     },
     {
          "algorithm": "Stochastically select parents to contribute gene subsets, prioritize based on a custom metric combining weight and value, ensure mutations don't violate constraints.",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n\n    new_pops = np.zeros_like(individuals)\n\n    # Common backbone idea analysis:\n    # - Selection based on fitness (either directly or weighted)\n    # - Reproduction involving combination and/or mutation of parent genes\n    # - Maintenance of problem constraints through repair or controlled generation.\n\n    # Using a novel mechanism that involves stochastic acceptance combined with priority-based item selection:\n    # {Stochastically select parents to contribute gene subsets, prioritize based on a custom metric combining weight and value, ensure mutations don't violate constraints.}\n\n    # Compute a priority score for each item\n    profits_sum = V.sum(axis=1)\n    priority_scores = profits_sum / W  # Larger is better\n    item_order = np.argsort(-priority_scores)\n\n    def stochastically_accept_items():\n        knapsack = np.zeros(N_P, dtype=np.int32)\n        current_weight = 0\n        \n        # Traverse through items based on priority\n        for item in item_order:\n            if current_weight + W[item] <= C:\n                # Simulate a probabilistic acceptance\n                acceptance_probability = min(1, 0.5 + 0.5 * (profits_sum[item] / profits_sum.max()))\n                if np.random.rand() < acceptance_probability:\n                    knapsack[item] = 1\n                    current_weight += W[item]\n        return knapsack\n\n    # Mutation function: flip an item's state with a small probability\n    def mutate(knapsack, mutation_rate=0.05):\n        for j in range(N_P):\n            if np.random.rand() < mutation_rate:\n                potential_knapsack = knapsack.copy()\n                potential_knapsack[j] = 1 - knapsack[j]\n                if np.sum(potential_knapsack * W) <= C:\n                    knapsack = potential_knapsack\n        return knapsack\n\n    for i in range(POP_SIZE):\n        knapsack = stochastically_accept_items()\n        knapsack = mutate(knapsack)\n        new_pops[i] = knapsack\n\n    return new_pops",
          "objective": 0.98601,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n\n    # Extract the current population and rankings\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n    \n    # Define new population array\n    new_pops = np.zeros_like(individuals)\n    \n    # Function to ensure weight constraint compliance\n    def enforce_constraint(individual):\n        while np.dot(individual, W) > C:\n            overweight_items = np.where(individual > 0)[0]\n            heaviest = np.argmax(W[overweight_items])\n            individual[overweight_items[heaviest]] = 0\n        return individual\n\n    # Function to perform disruption-based crossover\n    def disrupt_crossover(parent1, parent2, disruption_rate=0.25):\n        mask = np.random.rand(N_P) > disruption_rate\n        child = np.where(mask, parent1, parent2)\n        return child\n    \n    # Advanced mutation targeting lesser contributing items first\n    def advanced_mutation(individual, rate=0.1):\n        # Consider items based on their profit-to-weight ratio\n        value_ratios = np.sum(V, axis=1) / W\n        # Sort items according to their value ratios in ascending to mimic removing lower value first\n        sorted_indices = np.argsort(value_ratios)\n        mutations = np.random.rand(N_P) < rate\n        for idx in sorted_indices:\n            if mutations[idx]:\n                individual[idx] = 1 - individual[idx]\n                if np.dot(individual, W) > C:\n                    individual[idx] = 0  # Revert if it violates constraint\n        return individual\n    \n    # Main evolutionary process\n    for i in range(POP_SIZE):\n        # Choose parents with simple tournament selection\n        p1, p2 = np.random.choice(range(POP_SIZE), 2, replace=False)\n        if rankings[p1] > rankings[p2]:\n            parent1, parent2 = individuals[p1], individuals[p2]\n        else:\n            parent1, parent2 = individuals[p2], individuals[p1]\n        \n        # Generate new offspring\n        child = disrupt_crossover(parent1, parent2)\n        child = advanced_mutation(child)\n        child = enforce_constraint(child)\n        \n        # Store the newly generated offspring in the population\n        new_pops[i] = child\n    \n    return new_pops",
          "objective": 0.98586,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n\n    def calculate_fitness(individual, V):\n        return np.sum(individual[:, np.newaxis] * V, axis=0)\n    \n    def check_weight(individual, W, C):\n        return np.sum(individual * W) <= C\n    \n    def tournament_selection(pops, tournament_size=2):\n        indices = np.random.randint(0, pops['individuals'].shape[0], tournament_size)\n        subset = pops['rankings'][indices]\n        winner_idx = indices[np.argmin(subset)]\n        return pops['individuals'][winner_idx]\n\n    # Create new population array\n    new_pops = np.zeros_like(pops['individuals'])\n    \n    for i in range(POP_SIZE):\n        parent1 = tournament_selection(pops)\n        parent2 = tournament_selection(pops)\n        \n        # Crossover: one-point crossover\n        point = np.random.randint(1, N_P)\n        child = np.hstack((parent1[:point], parent2[point:]))\n        \n        # Mutation: flip one random bit\n        mutation_point = np.random.randint(N_P)\n        child[mutation_point] = 1 - child[mutation_point]\n        \n        # Repair mechanism to respect weight constraints\n        while not check_weight(child, W, C):\n            # If overweight, randomly drop an included item\n            included_items = np.where(child == 1)[0]\n            if included_items.size > 0:\n                drop_idx = np.random.choice(included_items)\n                child[drop_idx] = 0\n            else:\n                break\n        \n        new_pops[i, :] = child\n\n    return new_pops",
          "objective": 0.98571,
          "other_inf": null
     },
     {
          "algorithm": "Apply a linear combination of parents' genes weighted by their normalized rankings to create children, then apply mutation and ensure constraints via greedy repair.",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n\n    # Inputs are structured in the given format\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n\n    # Common backbone idea: Select parent based on fitness, recombine, mutate, then perform repair.\n    # New algorithm: {Apply a linear combination of parents' genes weighted by their normalized rankings to create children, then apply mutation and ensure constraints via greedy repair.}\n\n    new_pops = np.zeros_like(individuals)\n    \n    # Normalize rankings to create a weight distribution for parent selection\n    ranks_normalized = 1 / (rankings + 1)\n    selection_weights = ranks_normalized / ranks_normalized.sum()\n\n    def greedy_repair(child):\n        # Ensure the child respects the weight constraint by potentially removing items\n        while np.dot(child, W) > C:\n            items_in_knapsack = np.where(child > 0)[0]\n            if items_in_knapsack.size > 0:\n                # Preferentially remove heavier items first\n                item_to_remove = items_in_knapsack[np.argmax(W[items_in_knapsack])]\n                child[item_to_remove] = 0\n        return child\n\n    def mutate(individual, mutation_probability=0.1):\n        mutation_targets = np.random.rand(N_P) < mutation_probability\n        individual[mutation_targets] = 1 - individual[mutation_targets]\n        return individual\n\n    for i in range(POP_SIZE):\n        # Select two parents based on their ranks (weighted selection)\n        parents_indices = np.random.choice(POP_SIZE, size=2, p=selection_weights, replace=False)\n        parent1, parent2 = individuals[parents_indices[0]], individuals[parents_indices[1]]\n        rank1, rank2 = ranks_normalized[parents_indices[0]], ranks_normalized[parents_indices[1]]\n\n        # Linear combination of parents' contributions\n        alpha = rank1 / (rank1 + rank2)\n        child = np.where(np.random.rand(N_P) < alpha, parent1, parent2)\n\n        # Child mutation\n        child = mutate(child)\n\n        # Repair the child to ensure it respects the knapsack constraint\n        child = greedy_repair(child)\n\n        # Store in new population\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.98553,
          "other_inf": null
     },
     {
          "algorithm": "Create novel individuals by combining robust portfolios inherent from selected parents and carrying out a repairing process to ensure the weight constraint.",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n\n    # {Create novel individuals by combining robust portfolios inherent from selected parents and carrying out a repairing process to ensure the weight constraint.}\n    def repair_knapsack(individual):\n        while np.sum(individual * W) > C:\n            included_items = np.where(individual == 1)[0]\n            if included_items.size > 0:\n                item_to_remove = np.random.choice(included_items)\n                individual[item_to_remove] = 0\n            else:\n                break\n                \n        return individual\n    \n    def weighted_random_selection(weights):\n        cumulative_weights = np.cumsum(weights)\n        selection = np.random.rand() * cumulative_weights[-1]\n        for i, weight in enumerate(cumulative_weights):\n            if selection < weight:\n                return i\n        return len(weights) - 1\n\n    # Create new population array\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    \n    for i in range(POP_SIZE):\n        # Select parents based on their rankings (lower ranking has higher chance)\n        parent_weights = 1.0 / (1.0 + pops['rankings'])  # Lower rank has higher weight\n        parent_weights /= np.sum(parent_weights)  # Normalize to create a distribution\n        \n        parent1_idx = weighted_random_selection(parent_weights)\n        parent2_idx = weighted_random_selection(parent_weights)\n        parent1 = pops['individuals'][parent1_idx]\n        parent2 = pops['individuals'][parent2_idx]\n        \n        # Crossover: Create new individual with random genes from each parent\n        child = np.array([parent1[j] if np.random.rand() < 0.5 else parent2[j] for j in range(N_P)], dtype=np.int32)\n        \n        # Mutation: Flip a random bit\n        mutation_rate = 0.05\n        if np.random.rand() < mutation_rate:\n            mutation_point = np.random.randint(N_P)\n            child[mutation_point] = 1 - child[mutation_point]\n        \n        # Ensure the child respects the weight constraint\n        child = repair_knapsack(child)\n        \n        new_pops[i, :] = child\n\n    return new_pops",
          "objective": 0.98544,
          "other_inf": null
     }
]