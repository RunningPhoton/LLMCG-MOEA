[
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n    \n    # Initialize the new population array\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    \n    # Get individuals and their rankings from input population data\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n    \n    # Calculate multi-objective profit-weight ratio (considering all profit dimensions)\n    # Aggregate profit per item as the mean across multiple objectives\n    aggregate_profits = V.mean(axis=1)\n    profit_weight_ratio = aggregate_profits / W\n    \n    # Sort items based on profit-weight ratio in descending order\n    sorted_indices = np.argsort(-profit_weight_ratio)\n    \n    top_individuals_count = POP_SIZE // 2\n    \n    # Half of the new population comes from top individuals of the current population\n    top_individuals_sorted_by_rank = individuals[np.argsort(rankings)[:top_individuals_count]]\n    new_pops[:top_individuals_count] = top_individuals_sorted_by_rank.copy()\n    \n    # Remainder of the population is filled by a new knapsack filling strategy\n    for i in range(top_individuals_count, POP_SIZE):\n        current_weight = 0\n        knapsack = np.zeros(N_P, dtype=np.int32)\n        \n        # Attempt to fill the knapsack using sorted item indices based on profit/weight ratio\n        for idx in sorted_indices:\n            item_weight = W[idx]\n            if current_weight + item_weight <= C:\n                knapsack[idx] = 1\n                current_weight += item_weight\n            if current_weight >= C:\n                break\n        \n        # Mutation: Introduce variability by toggling random items with low probability\n        mutation_prob = 0.05  # lower probability of mutation for more stability\n        for j in range(N_P):\n            if np.random.rand() < mutation_prob:\n                proposed_change = 1 - knapsack[j]\n                potential_weight_change = W[j] if proposed_change == 1 else -W[j]\n                if current_weight + potential_weight_change <= C:\n                    knapsack[j] = proposed_change\n                    current_weight += potential_weight_change\n        \n        new_pops[i] = knapsack\n    \n    return new_pops",
          "objective": 0.98799,
          "other_inf": null
     },
     {
          "algorithm": "Utilize Fitness Proportional Selection for parents, Bitwise Crossover for child generation,\n    #  and a Greedy Knapsack Solver for weight constraint enforcement using value-weight ratio guidance.",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n    \n    # {Utilize Fitness Proportional Selection for parents, Bitwise Crossover for child generation,\n    #  and a Greedy Knapsack Solver for weight constraint enforcement using value-weight ratio guidance.}\n    \n    individuals = pops['individuals']\n    rankings = pops['rankings']\n\n    # Fitness proportional selection\n    def fitness_proportional_selection():\n        fitness_scores = 1.0 / (1.0 + rankings)\n        probabilities = fitness_scores / np.sum(fitness_scores)\n        # Select two individuals according to their fitness probabilities\n        selected_indices = np.random.choice(POP_SIZE, size=2, p=probabilities, replace=False)\n        return individuals[selected_indices[0]], individuals[selected_indices[1]]\n\n    # Bitwise crossover operation\n    def bitwise_crossover(parent1, parent2):\n        # Random crossover points\n        crossover_mask = np.random.randint(0, 2, size=N_P, dtype=bool)\n        child = np.where(crossover_mask, parent1, parent2)\n        return child\n\n    # Greedy knapsack solver based on item value-weight ratio\n    def greedy_knapsack_solver(individual):\n        value_weight_ratio = np.sum(V, axis=1) / W  # sum across all profits for simplicity\n        item_indices = np.argsort(-value_weight_ratio)  # maximize value/weight ratio, descending order\n        knapsack_weight = 0\n        solution = np.zeros(N_P, dtype=int)\n        for idx in item_indices:\n            if individual[idx] == 1 and knapsack_weight + W[idx] <= C:\n                solution[idx] = 1\n                knapsack_weight += W[idx]\n        return solution\n\n    # Mutation\n    def mutate(child):\n        mutation_rate = 0.01  # Small mutation chance\n        for i in range(N_P):\n            if np.random.rand() < mutation_rate:\n                child[i] = 1 - child[i]  # Flip bit\n        return child\n\n    new_pops = np.zeros_like(individuals)\n    \n    for i in range(POP_SIZE):\n        # Select parents\n        parent1, parent2 = fitness_proportional_selection()\n        # Generate a new child\n        child = bitwise_crossover(parent1, parent2)\n        # Possibly mutate the child\n        child = mutate(child)\n        # Repair child to fit knapsack constraints\n        child = greedy_knapsack_solver(child)\n        # Store in new population\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.98798,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n    \n    # Extract individuals and their rankings\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n    \n    # New population placeholder\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    \n    # Calculate utilities for each item based on a combined score of all profit values divided by weight\n    utilities = np.sum(V / W[:, None], axis=1)\n    \n    # Sort items by their utility in descending order for prioritized packing\n    sorted_items = np.argsort(-utilities)\n    \n    # Strategy:\n    # Use a hybrid approach of elite-preservation and utility-based item selection\n    for i in range(POP_SIZE):\n        # Elite preservation: carry over top ranked individuals directly to new population\n        if i < POP_SIZE // 2:\n            best_individuals = np.argsort(rankings)[:POP_SIZE // 2]\n            new_pops[i] = individuals[best_individuals[i % (POP_SIZE // 2)]].copy()\n        else:\n            # Utility-based item selection for remaining half of the population\n            current_weight = 0\n            new_individual = np.zeros(N_P, dtype=np.int32)\n            \n            # Try to add the highest utility items while the weight limit is not reached\n            for item in sorted_items:\n                if current_weight + W[item] <= C:\n                    new_individual[item] = 1\n                    current_weight += W[item]\n            \n            # Introduce mutation for diversity: randomly switch an item with a fixed probability\n            # This is a simple mutation without additional complexity\n            mutation_probability = 0.05\n            for j in range(N_P):\n                if np.random.rand() < mutation_probability:\n                    # Toggle item index j and check weight constraint\n                    candidate_individual = new_individual.copy()\n                    candidate_individual[j] = 1 - candidate_individual[j]\n                    if np.sum(candidate_individual * W) <= C:\n                        new_individual = candidate_individual\n            \n            new_pops[i] = new_individual\n    \n    return new_pops",
          "objective": 0.98765,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n    \n    # Initialize the new population array\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    \n    # Obtain individuals and their rankings from input population data\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n    \n    # Calculate cumulative profit per item across all objectives\n    cumulative_profits = V.sum(axis=1)\n    profit_weight_ratio = cumulative_profits / W\n    \n    # Sort items based on combined profit-weight ratio in descending order\n    sorted_indices = np.argsort(-profit_weight_ratio)\n    \n    # Top half of the new population derived from top-ranked individuals of the current population\n    elite_size = POP_SIZE // 2\n    elite_indices = np.argsort(rankings)[:elite_size]\n    new_pops[:elite_size] = individuals[elite_indices].copy()\n    \n    # Fill remaining population slots with new strategies\n    for i in range(elite_size, POP_SIZE):\n        current_weight = 0\n        new_individual = np.zeros(N_P, dtype=np.int32)\n        \n        # Fill the knapsack with high profit-weight ratio until full\n        for index in sorted_indices:\n            if current_weight + W[index] <= C:\n                new_individual[index] = 1\n                current_weight += W[index]\n        \n        # Mutation mechanism: Randomly toggle an item, given a low mutation chance\n        for mutation in range(N_P):\n            if np.random.rand() < 0.1:\n                if new_individual[mutation] == 1:\n                    if current_weight - W[mutation] >= 0:\n                        new_individual[mutation] = 0\n                        current_weight -= W[mutation]\n                else:\n                    if current_weight + W[mutation] <= C:\n                        new_individual[mutation] = 1\n                        current_weight += W[mutation]\n        \n        new_pops[i] = new_individual\n    \n    return new_pops",
          "objective": 0.98763,
          "other_inf": null
     },
     {
          "algorithm": "Utilize a tournament selection for robust parent selection, apply a uniform crossover, and enforce constraints by item value-density sorting for repair",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n    \n    # Extract the essentials from the dictionary\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n\n    # Destination array for new population\n    new_pops = np.zeros_like(individuals)\n\n    # Backbone idea: Parent selection, crossover mechanism, mutation for diversity, and a mechanism to enforce constraints.\n    # New algorithm: {Utilize a tournament selection for robust parent selection, apply a uniform crossover, and enforce constraints by item value-density sorting for repair}.\n\n    # Calculate value density (value/weight ratio) for repair purposes\n    value_density = V.sum(axis=1) / W\n    sorted_density_indices = np.argsort(-value_density)  # sort indices descending order by value density\n\n    def tournament_selection(k=3):\n        \"\"\" Select one individual using tournament selection. \"\"\"\n        selected_indices = np.random.randint(0, POP_SIZE, k)\n        best_index = selected_indices[np.argmin(rankings[selected_indices])]\n        return individuals[best_index]\n    \n    def uniform_crossover(parent1, parent2):\n        \"\"\" Perform uniform crossover between two parents. \"\"\"\n        mask = np.random.randint(0, 2, size=N_P, dtype=bool)\n        child = np.where(mask, parent1, parent2)\n        return child\n    \n    def repair(individual):\n        \"\"\" Repair individual to meet the knapsack constraint using value-density approach. \"\"\"\n        if np.dot(individual, W) > C:\n            # Begin with an empty knapsack\n            repaired = np.zeros_like(individual)\n            for idx in sorted_density_indices:\n                # Include the item if it does not exceed capacity\n                if individual[idx] == 1 and np.dot(repaired, W) + W[idx] <= C:\n                    repaired[idx] = 1\n            return repaired\n        return individual\n    \n    for i in range(POP_SIZE):\n        parent1 = tournament_selection()\n        parent2 = tournament_selection()\n        child = uniform_crossover(parent1, parent2)\n\n        # Mutation: Randomly flip a bit with a low probability\n        mutation_prob = 0.02\n        mutation_mask = np.random.rand(N_P) < mutation_prob\n        child[mutation_mask] = 1 - child[mutation_mask]\n\n        # Repair the child to ensure it adheres to the weight constraint while seeking optimality\n        child = repair(child)\n\n        # Store in new population\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.98746,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n    \n    # Create an initial structure for the new generation\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    \n    individuals = pops['individuals']\n    rankings = pops['rankings']\n\n    # Use a greedy algorithm inspired slot filling based on profit to weight ratio\n    # Calculate profit to weight ratios\n    profit_to_weight_ratios = np.array([np.sum(V[i] / W[i]) if W[i] > 0 else 0 for i in range(N_P)])\n    \n    # Sort items by descending profit to weight ratio\n    item_order = np.argsort(-profit_to_weight_ratios)\n    \n    for i in range(POP_SIZE):\n        if i < POP_SIZE // 2:\n            # Directly copy half of best individuals based on rankings\n            new_pops[i] = individuals[np.argsort(rankings)[i]].copy()\n        else:\n            # Initialize an empty knapsack\n            knapsack = np.zeros(N_P, dtype=np.int32)\n            current_weight = 0\n\n            # Try to add items in the order of their effective profit/weight ratio\n            for item in item_order:\n                if current_weight + W[item] <= C:\n                    knapsack[item] = 1\n                    current_weight += W[item]\n                \n                # Break if adding more items would exceed capacity\n                if current_weight >= C:\n                    break\n            \n            # Simple mutation: randomly toggle an item in or out with a low probability\n            mutation_rate = 0.1\n            for j in range(N_P):\n                if np.random.rand() < mutation_rate:\n                    proposed_knapsack = knapsack.copy()\n                    proposed_knapsack[j] = 1 - proposed_knapsack[j]\n                    if np.sum(proposed_knapsack * W) <= C:  # Ensure feasibility\n                        knapsack = proposed_knapsack\n\n            new_pops[i] = knapsack\n\n    return new_pops",
          "objective": 0.9872,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n\n    # Initialize the new population array\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    \n    # Get individuals and their rankings from input population data\n    individuals = pops['individuals']\n    ranks = pops['rankings']\n    num_items = W.shape[0]\n\n    # Calculate combined value-to-weight ratio using geometric mean of profit dimensions\n    combined_ratio = np.exp(np.mean(np.log(V + 1), axis=1)) / W\n    sorted_indices = np.argsort(-combined_ratio)\n\n    # Initialization for elite survival\n    elite_count = POP_SIZE // 2\n    elite_indices = np.argsort(ranks)[:elite_count]\n    new_pops[:elite_count] = individuals[elite_indices].copy()\n\n    # Breeding process starts\n    for i in range(elite_count, POP_SIZE):\n        knapsack = np.zeros(num_items, dtype=np.int32)\n        total_weight = 0\n\n        # Fill knapsack with the best items based on combined ratio, subject to capacity\n        for idx in sorted_indices:\n            if total_weight + W[idx] <= C:\n                knapsack[idx] = 1\n                total_weight += W[idx]\n            if total_weight == C:\n                break\n\n        # Crossover between chosen elite and current construction\n        if i < POP_SIZE:\n            parent = individuals[elite_indices[i % elite_count]]\n            crossover_point = np.random.randint(1, num_items - 1)\n            knapsack[:crossover_point] = parent[:crossover_point]\n\n        # Mutation with small probability to flip item inclusion\n        mutation_probability = 0.02\n        for j in range(num_items):\n            if np.random.rand() < mutation_probability:\n                if knapsack[j] == 1:\n                    if total_weight - W[j] >= 0:\n                        knapsack[j] = 0\n                        total_weight -= W[j]\n                else:\n                    if total_weight + W[j] <= C:\n                        knapsack[j] = 1\n                        total_weight += W[j]\n\n        new_pops[i] = knapsack\n\n    return new_pops",
          "objective": 0.98709,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n    new_pops = np.zeros_like(individuals)\n\n    # Strategy: Random Immigrant approach with adaptive mutation based on weighted value density and constraint repair.\n\n    # Calculate value density and sort by this metric\n    total_values = V.sum(axis=1)\n    value_density = total_values / W\n    sorted_items_by_density = np.argsort(-value_density)\n\n    def adaptive_mutation(individual, rate=0.05):\n        \"\"\" Mutate individual with a probability based on performance rank. \"\"\"\n        mutation_chance = np.random.rand(N_P)\n        higher_chance_indices = mutation_chance < rate\n        individual[higher_chance_indices] = 1 - individual[higher_chance_indices]\n        return individual\n\n    def repair(individual):\n        \"\"\" Ensure individual is within the weight constraint using the densest items. \"\"\"\n        if np.dot(individual, W) > C:\n            repaired = np.zeros_like(individual)\n            current_weight = 0\n            for idx in sorted_items_by_density:\n                if current_weight + W[idx] <= C:\n                    repaired[idx] = individual[idx]\n                    current_weight += W[idx] * individual[idx]\n                if current_weight >= C:\n                    break\n            return repaired\n        return individual\n\n    def random_immigrant(rate=0.1):\n        \"\"\" Introduce new random solutions to maintain diversity. \"\"\"\n        return np.random.randint(0, 2, size=N_P)\n\n    for i in range(POP_SIZE):\n        if np.random.rand() < 0.1:  # 10% random immigrants\n            new_individual = random_immigrant()\n        else:\n            # Select individual based on rank (prob inversely proportional to rank)\n            probabilities = 1 / (rankings + 1)\n            probabilities /= probabilities.sum()\n            index = np.random.choice(POP_SIZE, p=probabilities)\n            selected_individual = individuals[index]\n            new_individual = adaptive_mutation(selected_individual.copy(), rate=0.02 * (1 + rankings[index]))\n\n        # Repair the mutated (or randomly created) individual\n        new_individual = repair(new_individual)\n\n        new_pops[i] = new_individual\n\n    return new_pops",
          "objective": 0.98679,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n    \n    # Algorithm utilizes a combination of crossover via weighted random sampling of parents and mutation\n    # for feature toggles based on value-density sorting.\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n    \n    # Normalize rankings to create a probability distribution (inversely proportionate)\n    prob_distribution = 1.0 / (rankings + 1e-6)\n    prob_distribution /= np.sum(prob_distribution)\n    \n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    \n    # Generate new population\n    for i in range(POP_SIZE):\n        # Crossover - select two parents based on their rankings probability distribution\n        parents_indices = np.random.choice(POP_SIZE, size=2, p=prob_distribution, replace=False)\n        parent1, parent2 = individuals[parents_indices[0]], individuals[parents_indices[1]]\n        \n        # Single point crossover\n        crossover_point = np.random.randint(1, N_P)\n        child = np.hstack((parent1[:crossover_point], parent2[crossover_point:]))\n        \n        # Mutation - based on value density (value per weight unit)\n        value_density = V.sum(axis=1) / W   # Sum of values across all objectives divided by weight\n        # Normalize value_density\n        value_density /= np.max(value_density)\n        \n        # Mutate with selective probability inversely based on value density\n        mutation_chance = 0.1 * (1 - value_density)\n        mutations = np.random.rand(N_P) < mutation_chance\n        child = (child + mutations) % 2  # toggle the genes where mutation occurs\n\n        # Ensure knapsack does not exceed weight constraint\n        # Greedy repair mechanism: remove items if overweight, starting from lowest value_density\n        while np.dot(child, W) > C:\n            lowest_density_indices = np.argsort(value_density)  # indices of items sorted by lowest value_density\n            for idx in lowest_density_indices:\n                if child[idx] == 1:\n                    child[idx] = 0\n                    if np.dot(child, W) <= C:\n                        break\n        \n        new_pops[i] = child\n    \n    return new_pops",
          "objective": 0.98664,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n    \n    def calculate_fitness(individual, V):\n        \"\"\"Calculate the fitness of an individual based on the value matrix.\"\"\"\n        return np.sum(individual[:, np.newaxis] * V, axis=0)\n    \n    def check_weight(individual, W, C):\n        \"\"\"Check if the weight of an individual does not exceed the capacity.\"\"\"\n        return np.sum(individual * W) <= C\n    \n    def select_parents_by_ranking(pops):\n        \"\"\"Select parent indices based on weighted probability inversely related to ranking.\"\"\"\n        weights = 1 / (1 + pops['rankings'])\n        weights /= np.sum(weights)\n        selected_idx = np.random.choice(POP_SIZE, size=2, p=weights, replace=False)\n        return pops['individuals'][selected_idx[0]], pops['individuals'][selected_idx[1]]\n\n    # Generate new population\n    new_pops = np.zeros_like(pops['individuals'])\n    \n    for i in range(POP_SIZE):\n        parent1, parent2 = select_parents_by_ranking(pops)\n        \n        # Crossover: Uniform crossover\n        mask = np.random.randint(2, size=N_P)\n        child = np.where(mask, parent1, parent2)\n        \n        # Mutation: Flip a random bit with low probability\n        if np.random.rand() < 0.1:\n            mutation_point = np.random.randint(N_P)\n            child[mutation_point] = 1 - child[mutation_point]\n        \n        # Ensure weight constraint compliance\n        while not check_weight(child, W, C):\n            included_items = np.where(child == 1)[0]\n            if included_items.size == 0:\n                break\n            drop_idx = np.random.choice(included_items)\n            child[drop_idx] = 0\n        \n        new_pops[i, :] = child\n    \n    return new_pops",
          "objective": 0.98638,
          "other_inf": null
     }
]