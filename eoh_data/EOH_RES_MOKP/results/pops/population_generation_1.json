[
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n\n    def calculate_fitness(individual, V):\n        return np.sum(individual[:, np.newaxis] * V, axis=0)\n    \n    def check_weight(individual, W, C):\n        return np.sum(individual * W) <= C\n    \n    def tournament_selection(pops, tournament_size=2):\n        indices = np.random.randint(0, pops['individuals'].shape[0], tournament_size)\n        subset = pops['rankings'][indices]\n        winner_idx = indices[np.argmin(subset)]\n        return pops['individuals'][winner_idx]\n\n    # Create new population array\n    new_pops = np.zeros_like(pops['individuals'])\n    \n    for i in range(POP_SIZE):\n        parent1 = tournament_selection(pops)\n        parent2 = tournament_selection(pops)\n        \n        # Crossover: one-point crossover\n        point = np.random.randint(1, N_P)\n        child = np.hstack((parent1[:point], parent2[point:]))\n        \n        # Mutation: flip one random bit\n        mutation_point = np.random.randint(N_P)\n        child[mutation_point] = 1 - child[mutation_point]\n        \n        # Repair mechanism to respect weight constraints\n        while not check_weight(child, W, C):\n            # If overweight, randomly drop an included item\n            included_items = np.where(child == 1)[0]\n            if included_items.size > 0:\n                drop_idx = np.random.choice(included_items)\n                child[drop_idx] = 0\n            else:\n                break\n        \n        new_pops[i, :] = child\n\n    return new_pops",
          "objective": 0.98571,
          "other_inf": null
     },
     {
          "algorithm": "The proposed algorithm selects parents based on truncated selection, applies a uniform crossover strategy for the generation of offspring, followed by a repair mechanism to handle constraint violations, ultimately creating new diverse individuals.",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n    \n    individuals = pops['individuals']\n    rankings = pops['rankings']\n    \n    # Initialize new population\n    new_pops = np.zeros_like(individuals)\n    \n    # Select parents more likely from lower ranked (better) individuals\n    sorted_idx = np.argsort(rankings)  # Sort indices by rankings\n    elite_size = POP_SIZE // 3  # Define a proportion of population as elite\n    \n    # Mixed selection pool: top-ranked and randomly selected individuals\n    elite_individuals = sorted_idx[:elite_size]\n    random_individuals = np.random.choice(sorted_idx[elite_size:], POP_SIZE - elite_size, replace=False)\n    selection_pool = np.concatenate((elite_individuals, random_individuals))\n    \n    np.random.shuffle(selection_pool)  # Shuffle to randomize the pairing process\n    \n    # Generate new individuals using uniform crossover\n    for i in range(0, POP_SIZE, 2):\n        parent1_idx = selection_pool[i % len(selection_pool)]\n        parent2_idx = selection_pool[(i + 1) % len(selection_pool)]\n        \n        parent1, parent2 = individuals[parent1_idx], individuals[parent2_idx]\n        \n        # Uniform crossover\n        crossover_mask = np.random.rand(N_P) > 0.5\n        child1 = np.where(crossover_mask, parent1, parent2)\n        child2 = np.where(crossover_mask, parent2, parent1)\n        \n        # Repair mechanism to ensure feasibility in terms of weight\n        def repair(individual):\n            while np.dot(individual, W) > C:\n                overweight_indices = np.where(individual == 1)[0]\n                if overweight_indices.size == 0:\n                    break\n                removal_idx = np.random.choice(overweight_indices)\n                individual[removal_idx] = 0\n            return individual\n        \n        new_pops[i] = repair(child1)\n        if i + 1 < POP_SIZE:\n            new_pops[i + 1] = repair(child2)\n    \n    return new_pops",
          "objective": 0.98519,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n    \n    individuals = pops['individuals']\n    rankings = pops['rankings']\n\n    # Initialize new population\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    \n    # Calculate single-objective equivalent by averaging profits across objectives\n    average_profit = np.mean(V, axis=1)\n    single_profit_values = np.dot(individuals, average_profit)\n\n    # Sort individuals by their single-objective profit and select the top half\n    top_indices = np.argsort(-single_profit_values)[:POP_SIZE // 2]\n    new_pops[:POP_SIZE // 2] = individuals[top_indices]\n\n    # Generate new individuals for the remaining half of the population by crossover and mutation\n    for i in range(POP_SIZE // 2, POP_SIZE):\n        parent1_idx, parent2_idx = np.random.choice(top_indices, 2, replace=False)\n        crossover_point = np.random.randint(0, N_P)\n        # Perform single point crossover\n        new_individual = np.concatenate((individuals[parent1_idx, :crossover_point],\n                                         individuals[parent2_idx, crossover_point:]))\n        # Mutation: randomly flip a gene with a low probability\n        mutation_probability = 0.05\n        mutation_mask = np.random.rand(N_P) < mutation_probability\n        new_individual = (new_individual + mutation_mask) % 2\n\n        # Make sure the new individual respects the weight constraints\n        while np.dot(new_individual, W) > C:\n            overweight_indices = np.where((new_individual == 1) & (mutation_mask == 1))[0]\n            if overweight_indices.size == 0:\n                overweight_indices = np.where(new_individual == 1)[0]\n            if overweight_indices.size == 0:\n                break\n            remove_index = np.random.choice(overweight_indices)\n            new_individual[remove_index] = 0\n        new_pops[i] = new_individual\n\n    return new_pops",
          "objective": 0.97909,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n    \n    # Extract individuals and rankings\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n\n    # Initialize new population\n    new_pops = np.zeros_like(individuals)\n    \n    # Enhanced Elite And Random Sampling Crossover\n    for i in range(POP_SIZE):\n        if i < POP_SIZE // 3:  # Elite retention of top one-third\n            elite_indices = np.argsort(rankings)[:POP_SIZE // 3]\n            new_pops[i] = individuals[elite_indices[i]]\n        else:  # Crossover of randomly selected individuals for rest\n            parent1_index = np.random.randint(0, POP_SIZE)\n            parent2_index = np.random.randint(0, POP_SIZE)\n            cross_point = np.random.randint(0, N_P)\n            \n            # Creating the offspring\n            offspring = np.zeros(N_P, dtype=np.int32)\n            offspring[:cross_point] = individuals[parent1_index][:cross_point]\n            offspring[cross_point:] = individuals[parent2_index][cross_point:]\n            \n            # Mutation mechanism with a probability of 3%\n            mutation_prob = 0.03\n            for gene in range(N_P):\n                if np.random.rand() < mutation_prob:\n                    offspring[gene] = 1 - offspring[gene]\n            \n            # Weight constraint check and fix\n            while np.sum(offspring * W) > C:\n                overweight_indices = np.where(offspring == 1)[0]\n                if overweight_indices.size > 0:\n                    item_to_remove = np.random.choice(overweight_indices)\n                    offspring[item_to_remove] = 0\n            \n            # Assign the created child to the new population\n            new_pops[i] = offspring\n    \n    return new_pops",
          "objective": 0.97698,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n\n    def fitness(individual):\n        # Calculating the weighted profit which is the sum of weights for selected items\n        total_weight = np.dot(individual, W)\n        total_profit = np.dot(individual, V)\n        if total_weight <= C:\n            return sum(total_profit)  # Add multi-objective profits\n        else:\n            # This return is for invalid solutions, which would be filtered out.\n            return -1\n\n    # Get current individuals and rankings\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n\n    # Select individuals based on ranking (elitism):\n    # Keeping the best half of the population based on rankings\n    top_half = individuals[rankings.argsort()][:POP_SIZE // 2]\n\n    # Generate new population from existing top performing half:\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n\n    # Uniform crossover and mutation:\n    # Each individual in the new population is generated by randomly mixing two parents from top_half and occasionally flipping one bit to introduce randomness\n    for i in range(POP_SIZE):\n        parent1, parent2 = top_half[np.random.choice(len(top_half), 2, replace=False)]\n        crossover_point = np.random.randint(1, N_P)\n        child = np.concatenate([parent1[:crossover_point], parent2[crossover_point:]])\n\n        # Mutation with a probability of 0.05\n        if np.random.rand() < 0.05:\n            mutation_point = np.random.randint(N_P)\n            child[mutation_point] = 1 - child[mutation_point]  # Flip the bit\n\n        # Ensuring that child complies with weight constraint\n        while np.dot(child, W) > C:\n            # Randomly drop items until within weight limit\n            overweight_indices = np.where(child == 1)[0]\n            drop_index = np.random.choice(overweight_indices)\n            child[drop_index] = 0\n\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.97304,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n    \n    individuals = pops['individuals']\n    rankings = pops['rankings']\n    \n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    \n    # Select elite individuals\n    elite_count = POP_SIZE // 5  # Taking top 20% as elite\n    elite_indices = np.argsort(rankings)[:elite_count]\n    elites = individuals[elite_indices]\n    \n    # Fill part of the new population with elites\n    new_pops[:elite_count] = elites.copy()\n    \n    # Tournament selection and uniform crossover to create new individuals\n    for i in range(elite_count, POP_SIZE):\n        # Tournament selection among all individuals\n        tournament_size = 5\n        tournament_indices = np.random.choice(range(POP_SIZE), tournament_size, replace=False)\n        tournament_rankings = rankings[tournament_indices]\n        parent1_index = tournament_indices[np.argmin(tournament_rankings)]\n        parent1 = individuals[parent1_index]\n        \n        tournament_indices = np.random.choice(range(POP_SIZE), tournament_size, replace=False)\n        tournament_rankings = rankings[tournament_indices]\n        parent2_index = tournament_indices[np.argmin(tournament_rankings)]\n        parent2 = individuals[parent2_index]\n        \n        # Uniform crossover\n        mask = np.random.randint(2, size=N_P)\n        child = np.where(mask, parent1, parent2)\n        \n        # Mutation: random flip of bits with low probability\n        mutation_prob = 0.05\n        mutation_mask = np.random.random(size=N_P) < mutation_prob\n        child = np.where(mutation_mask, 1 - child, child)\n        \n        # Ensure child respects the knapsack capacity constraint\n        while np.dot(child, W) > C:\n            # Identify items to potentially remove (randomly find set bits and try turning some off)\n            nonzero_indices = np.where(child == 1)[0]\n            if len(nonzero_indices) == 0:\n                break\n            child[np.random.choice(nonzero_indices)] = 0\n        \n        new_pops[i] = child\n    \n    return new_pops",
          "objective": 0.96994,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n    \n    # Extract individuals and rankings\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n    \n    # Initialize new population\n    new_pops = np.zeros_like(individuals)\n\n    # Elite retention: Keep a fraction of the best individuals unchanged\n    elite_size = int(0.1 * POP_SIZE)\n    elite_indices = np.argsort(rankings)[:elite_size]\n    new_pops[:elite_size] = individuals[elite_indices]\n\n    # Generation of new individuals\n    for i in range(elite_size, POP_SIZE):\n        # Tournament selection: pick two sets of random individuals, choose the best from each\n        tournament_size = 5\n        indexes1 = np.random.choice(POP_SIZE, tournament_size, replace=False)\n        indexes2 = np.random.choice(POP_SIZE, tournament_size, replace=False)\n        best_index_1 = indexes1[np.argmin(rankings[indexes1])]\n        best_index_2 = indexes2[np.argmin(rankings[indexes2])]\n        \n        # Single-point crossover\n        crossover_point = np.random.randint(0, N_P)\n        child = np.concatenate((individuals[best_index_1][:crossover_point], individuals[best_index_2][crossover_point:]))\n        \n        # Mutation with probability 5%\n        mutation_prob = 0.05\n        mutation_mask = np.random.rand(N_P) < mutation_prob\n        child = np.where(mutation_mask, 1 - child, child)\n\n        # Ensure the child adheres to weight constraints\n        while np.dot(W, child) > C:\n            overweight_indices = np.where(child == 1)[0]\n            if overweight_indices.size > 0:\n                drop_item = np.random.choice(overweight_indices)\n                child[drop_item] = 0\n            else:\n                break\n\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.96785,
          "other_inf": null
     },
     {
          "algorithm": "The novel reproduction function adopts random mutation-based crossover mechanisms, producing offspring by mixing parent genes and altering them slightly while considering non-dominance and weight constraints through elitism and heuristic mutation strategies.",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n    \n    individuals = pops['individuals']\n    rankings = pops['rankings']\n    \n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    \n    # Select elite individuals\n    elite_count = POP_SIZE // 5  # Taking top 20% as elite\n    elite_indices = np.argsort(rankings)[:elite_count]\n    elites = individuals[elite_indices]\n    \n    # Fill part of the new population with elites\n    new_pops[:elite_count] = elites.copy()\n    \n    # Mutation and crossover to create new individuals\n    for i in range(elite_count, POP_SIZE):\n        # Pick two different random parents from elite set\n        parents_indices = np.random.choice(elite_indices, 2, replace=False)\n        parent1 = individuals[parents_indices[0]]\n        parent2 = individuals[parents_indices[1]]\n        \n        # Single-point crossover\n        point = np.random.randint(1, N_P)\n        child = np.hstack((parent1[:point], parent2[point:]))\n\n        # Mutation: random flip of bits with low probability\n        mutation_prob = 0.05\n        for j in range(N_P):\n            if np.random.random() < mutation_prob:\n                child[j] = 1 - child[j]\n\n        # Ensure child respects the knapsack capacity constraint\n        while np.dot(child, W) > C:\n            # Identify items to potentially remove (randomly find set bits and try turning some off)\n            nonzero_indices = np.where(child == 1)[0]\n            if len(nonzero_indices) == 0:\n                break\n            child[np.random.choice(nonzero_indices)] = 0\n        \n        new_pops[i] = child\n    \n    return new_pops",
          "objective": 0.96594,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n    \n    # Initialize new population\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    \n    # Calculate overall profitability for each individual\n    profit_values = np.dot(individuals, V)\n    total_profits = np.sum(profit_values, axis=1)\n    \n    # Rank individuals by total profit adjusted by rank to ensure diversity\n    adjusted_scores = total_profits / (1 + rankings)\n    best_individuals_indices = np.argsort(adjusted_scores)[-POP_SIZE//2:]  # take top half\n    \n    # Copy the best individuals directly to new population\n    new_pops[:POP_SIZE//2] = individuals[best_individuals_indices]\n    \n    # For the rest of the new population, use a weighted combination method\n    for i in range(POP_SIZE//2, POP_SIZE):\n        weights = total_profits / total_profits.sum()\n        chosen_index = np.random.choice(POP_SIZE, p=weights)\n        chosen_individual = individuals[chosen_index]\n        \n        # Hybridize by picking each gene based on a probability reflecting its occurrence in top individuals\n        gene_probabilities = individuals[best_individuals_indices].mean(axis=0)\n        new_individual = (np.random.random(N_P) < gene_probabilities).astype(np.int32)\n        \n        # Ensure that combined individual meets the weight constraint\n        while np.dot(new_individual, W) > C:\n            too_heavy_indices = np.where(new_individual == 1)[0]\n            if too_heavy_indices.size == 0:\n                break\n            remove_index = np.random.choice(too_heavy_indices)\n            new_individual[remove_index] = 0\n        \n        new_pops[i] = new_individual\n\n    return new_pops",
          "objective": 0.9639,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n\n    # Retrieve the individuals and their rankings from the provided population dictionary\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n    \n    # Initialize new population array\n    new_pops = np.zeros_like(individuals)\n    \n    # Utilize an environmental selection with a crossover function inspired by mating differentiation\n    for i in range(0, POP_SIZE, 2):  # Process in pairs\n        index1, index2 = np.random.choice(POP_SIZE, 2, replace=False)  # Select two different individuals\n        ind1, ind2 = individuals[index1], individuals[index2]\n        \n        # Generate two new individuals via crossover\n        cross_point = np.random.randint(1, N_P)  # Crossover point\n        child1 = np.concatenate([ind1[:cross_point], ind2[cross_point:]])\n        child2 = np.concatenate([ind2[:cross_point], ind1[cross_point:]])\n        \n        # Ensure that children meet the weight constraint\n        for child in [child1, child2]:\n            while np.dot(child, W) > C:\n                overweight_items = np.where(child * W > 0)[0]\n                if overweight_items.size > 0:\n                    item_to_remove = np.random.choice(overweight_items)\n                    child[item_to_remove] = 0\n        \n        # Place the new individuals in the population\n        new_pops[i] = child1\n        if i + 1 < POP_SIZE:\n            new_pops[i + 1] = child2\n    \n    return new_pops",
          "objective": 0.95727,
          "other_inf": null
     }
]