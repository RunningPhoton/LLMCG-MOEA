[
     {
          "algorithm": "Utilize a tournament selection for robust parent selection, apply a uniform crossover, and enforce constraints by item value-density sorting for repair",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n    \n    # Extract the essentials from the dictionary\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n\n    # Destination array for new population\n    new_pops = np.zeros_like(individuals)\n\n    # Backbone idea: Parent selection, crossover mechanism, mutation for diversity, and a mechanism to enforce constraints.\n    # New algorithm: {Utilize a tournament selection for robust parent selection, apply a uniform crossover, and enforce constraints by item value-density sorting for repair}.\n\n    # Calculate value density (value/weight ratio) for repair purposes\n    value_density = V.sum(axis=1) / W\n    sorted_density_indices = np.argsort(-value_density)  # sort indices descending order by value density\n\n    def tournament_selection(k=3):\n        \"\"\" Select one individual using tournament selection. \"\"\"\n        selected_indices = np.random.randint(0, POP_SIZE, k)\n        best_index = selected_indices[np.argmin(rankings[selected_indices])]\n        return individuals[best_index]\n    \n    def uniform_crossover(parent1, parent2):\n        \"\"\" Perform uniform crossover between two parents. \"\"\"\n        mask = np.random.randint(0, 2, size=N_P, dtype=bool)\n        child = np.where(mask, parent1, parent2)\n        return child\n    \n    def repair(individual):\n        \"\"\" Repair individual to meet the knapsack constraint using value-density approach. \"\"\"\n        if np.dot(individual, W) > C:\n            # Begin with an empty knapsack\n            repaired = np.zeros_like(individual)\n            for idx in sorted_density_indices:\n                # Include the item if it does not exceed capacity\n                if individual[idx] == 1 and np.dot(repaired, W) + W[idx] <= C:\n                    repaired[idx] = 1\n            return repaired\n        return individual\n    \n    for i in range(POP_SIZE):\n        parent1 = tournament_selection()\n        parent2 = tournament_selection()\n        child = uniform_crossover(parent1, parent2)\n\n        # Mutation: Randomly flip a bit with a low probability\n        mutation_prob = 0.02\n        mutation_mask = np.random.rand(N_P) < mutation_prob\n        child[mutation_mask] = 1 - child[mutation_mask]\n\n        # Repair the child to ensure it adheres to the weight constraint while seeking optimality\n        child = repair(child)\n\n        # Store in new population\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.98746,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n    \n    # Create an initial structure for the new generation\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    \n    individuals = pops['individuals']\n    rankings = pops['rankings']\n\n    # Use a greedy algorithm inspired slot filling based on profit to weight ratio\n    # Calculate profit to weight ratios\n    profit_to_weight_ratios = np.array([np.sum(V[i] / W[i]) if W[i] > 0 else 0 for i in range(N_P)])\n    \n    # Sort items by descending profit to weight ratio\n    item_order = np.argsort(-profit_to_weight_ratios)\n    \n    for i in range(POP_SIZE):\n        if i < POP_SIZE // 2:\n            # Directly copy half of best individuals based on rankings\n            new_pops[i] = individuals[np.argsort(rankings)[i]].copy()\n        else:\n            # Initialize an empty knapsack\n            knapsack = np.zeros(N_P, dtype=np.int32)\n            current_weight = 0\n\n            # Try to add items in the order of their effective profit/weight ratio\n            for item in item_order:\n                if current_weight + W[item] <= C:\n                    knapsack[item] = 1\n                    current_weight += W[item]\n                \n                # Break if adding more items would exceed capacity\n                if current_weight >= C:\n                    break\n            \n            # Simple mutation: randomly toggle an item in or out with a low probability\n            mutation_rate = 0.1\n            for j in range(N_P):\n                if np.random.rand() < mutation_rate:\n                    proposed_knapsack = knapsack.copy()\n                    proposed_knapsack[j] = 1 - proposed_knapsack[j]\n                    if np.sum(proposed_knapsack * W) <= C:  # Ensure feasibility\n                        knapsack = proposed_knapsack\n\n            new_pops[i] = knapsack\n\n    return new_pops",
          "objective": 0.9872,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n\n    def calculate_fitness(individual, V):\n        return np.sum(individual[:, np.newaxis] * V, axis=0)\n    \n    def check_weight(individual, W, C):\n        return np.sum(individual * W) <= C\n    \n    def tournament_selection(pops, tournament_size=2):\n        indices = np.random.randint(0, pops['individuals'].shape[0], tournament_size)\n        subset = pops['rankings'][indices]\n        winner_idx = indices[np.argmin(subset)]\n        return pops['individuals'][winner_idx]\n\n    # Create new population array\n    new_pops = np.zeros_like(pops['individuals'])\n    \n    for i in range(POP_SIZE):\n        parent1 = tournament_selection(pops)\n        parent2 = tournament_selection(pops)\n        \n        # Crossover: one-point crossover\n        point = np.random.randint(1, N_P)\n        child = np.hstack((parent1[:point], parent2[point:]))\n        \n        # Mutation: flip one random bit\n        mutation_point = np.random.randint(N_P)\n        child[mutation_point] = 1 - child[mutation_point]\n        \n        # Repair mechanism to respect weight constraints\n        while not check_weight(child, W, C):\n            # If overweight, randomly drop an included item\n            included_items = np.where(child == 1)[0]\n            if included_items.size > 0:\n                drop_idx = np.random.choice(included_items)\n                child[drop_idx] = 0\n            else:\n                break\n        \n        new_pops[i, :] = child\n\n    return new_pops",
          "objective": 0.98571,
          "other_inf": null
     },
     {
          "algorithm": "Apply a linear combination of parents' genes weighted by their normalized rankings to create children, then apply mutation and ensure constraints via greedy repair.",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n\n    # Inputs are structured in the given format\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n\n    # Common backbone idea: Select parent based on fitness, recombine, mutate, then perform repair.\n    # New algorithm: {Apply a linear combination of parents' genes weighted by their normalized rankings to create children, then apply mutation and ensure constraints via greedy repair.}\n\n    new_pops = np.zeros_like(individuals)\n    \n    # Normalize rankings to create a weight distribution for parent selection\n    ranks_normalized = 1 / (rankings + 1)\n    selection_weights = ranks_normalized / ranks_normalized.sum()\n\n    def greedy_repair(child):\n        # Ensure the child respects the weight constraint by potentially removing items\n        while np.dot(child, W) > C:\n            items_in_knapsack = np.where(child > 0)[0]\n            if items_in_knapsack.size > 0:\n                # Preferentially remove heavier items first\n                item_to_remove = items_in_knapsack[np.argmax(W[items_in_knapsack])]\n                child[item_to_remove] = 0\n        return child\n\n    def mutate(individual, mutation_probability=0.1):\n        mutation_targets = np.random.rand(N_P) < mutation_probability\n        individual[mutation_targets] = 1 - individual[mutation_targets]\n        return individual\n\n    for i in range(POP_SIZE):\n        # Select two parents based on their ranks (weighted selection)\n        parents_indices = np.random.choice(POP_SIZE, size=2, p=selection_weights, replace=False)\n        parent1, parent2 = individuals[parents_indices[0]], individuals[parents_indices[1]]\n        rank1, rank2 = ranks_normalized[parents_indices[0]], ranks_normalized[parents_indices[1]]\n\n        # Linear combination of parents' contributions\n        alpha = rank1 / (rank1 + rank2)\n        child = np.where(np.random.rand(N_P) < alpha, parent1, parent2)\n\n        # Child mutation\n        child = mutate(child)\n\n        # Repair the child to ensure it respects the knapsack constraint\n        child = greedy_repair(child)\n\n        # Store in new population\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.98553,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n\n    # (In each iteration, combine the features of top-rated individuals and introduce mutations to diversify, while prioritizing correction of invalid weights.)\n\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n\n    # Sort individuals based on rankings\n    sorted_indices = np.argsort(rankings)\n    sorted_individuals = individuals[sorted_indices]\n\n    # Prepare output population array\n    new_pops = np.zeros_like(individuals)\n\n    # Top fraction of individuals who are combined to produce the next generation\n    top_fraction = 0.2\n    num_top = int(POP_SIZE * top_fraction)\n\n    # Probability to mutate an item\n    mutation_prob = 0.05\n\n    def combine_parents(parent1, parent2):\n        # Perform uniform crossover\n        mask = np.random.randint(2, size=N_P)\n        child = (mask * parent1) + ((1 - mask) * parent2)\n        return child\n\n    def mutate(individual):\n        # Apply mutations randomly to the individual's genes\n        mutation_mask = np.random.rand(N_P) < mutation_prob\n        individual[mutation_mask] = 1 - individual[mutation_mask]\n        return individual\n\n    def validate(individual):\n        # Check if the individual's weight exceeds the capacity and fix if necessary\n        while np.dot(individual, W) > C:\n            overweight_indices = np.where((individual == 1) & (W > 0))[0]\n            if overweight_indices.size > 0:\n                individual[np.random.choice(overweight_indices)] = 0\n        return individual\n\n    # Generate new individuals\n    for i in range(POP_SIZE):\n        if np.random.rand() < 0.9:  \n            # Mainly combine top individuals\n            parents = np.random.choice(num_top, 2, replace=False)\n            child = combine_parents(sorted_individuals[parents[0]], sorted_individuals[parents[1]])\n        else:\n            # Occasionally introduce random individuals for diversity\n            child = np.random.randint(2, size=N_P)\n\n        child = mutate(child)\n        child = validate(child)\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.9792,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n    \n    def fitness(individual):\n        total_weight = np.dot(individual, W)\n        total_profit = np.dot(individual, V)\n        if total_weight <= C:\n            return np.sum(total_profit, axis=0)\n        else:\n            return np.full(total_profit.shape[1], -1)\n\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n    \n    top_third = individuals[np.argsort(rankings)][:POP_SIZE // 3]\n    \n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    \n    for i in range(POP_SIZE):\n        parent1, parent2, parent3 = top_third[np.random.choice(len(top_third), 3, replace=False)]\n        crossover1_point = np.random.randint(1, N_P)\n        crossover2_point = np.random.randint(crossover1_point, N_P)\n        child = np.concatenate([parent1[:crossover1_point], parent2[crossover1_point:crossover2_point], parent3[crossover2_point:]])\n\n        if np.random.rand() < 0.1:\n            mutation_point = np.random.randint(N_P)\n            child[mutation_point] = 1 - child[mutation_point]\n\n        while np.dot(child, W) > C:\n            overweight_indices = np.where(child == 1)[0]\n            if overweight_indices.size == 0:\n                break\n            drop_index = np.random.choice(overweight_indices)\n            child[drop_index] = 0\n            \n        new_pops[i] = child\n        \n    return new_pops",
          "objective": 0.97911,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n\n    def fitness(individual):\n        # Calculating the weighted profit which is the sum of weights for selected items\n        total_weight = np.dot(individual, W)\n        total_profit = np.dot(individual, V)\n        if total_weight <= C:\n            return sum(total_profit)  # Add multi-objective profits\n        else:\n            # This return is for invalid solutions, which would be filtered out.\n            return -1\n\n    # Get current individuals and rankings\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n\n    # Select individuals based on ranking (elitism):\n    # Keeping the best half of the population based on rankings\n    top_half = individuals[rankings.argsort()][:POP_SIZE // 2]\n\n    # Generate new population from existing top performing half:\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n\n    # Uniform crossover and mutation:\n    # Each individual in the new population is generated by randomly mixing two parents from top_half and occasionally flipping one bit to introduce randomness\n    for i in range(POP_SIZE):\n        parent1, parent2 = top_half[np.random.choice(len(top_half), 2, replace=False)]\n        crossover_point = np.random.randint(1, N_P)\n        child = np.concatenate([parent1[:crossover_point], parent2[crossover_point:]])\n\n        # Mutation with a probability of 0.05\n        if np.random.rand() < 0.05:\n            mutation_point = np.random.randint(N_P)\n            child[mutation_point] = 1 - child[mutation_point]  # Flip the bit\n\n        # Ensuring that child complies with weight constraint\n        while np.dot(child, W) > C:\n            # Randomly drop items until within weight limit\n            overweight_indices = np.where(child == 1)[0]\n            drop_index = np.random.choice(overweight_indices)\n            child[drop_index] = 0\n\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.97304,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n\n    # Extract relevant data from the population dictionary\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n    \n    # Inverse Transform Sampling based on rankings for Parent Selection\n    ranks_inverse = 1.0 / (rankings + 1)\n    selection_probabilities = ranks_inverse / ranks_inverse.sum()\n\n    # Initialize new population array\n    new_pops = np.zeros_like(individuals)\n\n    # Helper function to create new individual from two parents using random selection\n    def recombine(parent1, parent2):\n        child = np.where(np.random.rand(N_P) < 0.5, parent1, parent2)\n        return child\n\n    # Mutation with decreasing probability\n    def mutate(individual):\n        mutation_rate = 0.05  # Lower mutation rate\n        mutation_vector = np.random.rand(N_P) < mutation_rate\n        individual[mutation_vector] = 1 - individual[mutation_vector]\n        return individual\n\n    # Validation and repair function to ensure weight limits are not exceeded\n    def repair(individual):\n        while np.dot(individual, W) > C:\n            overweight_items = np.where(individual * W > 0)[0]\n            if overweight_items.size > 0:\n                individual[np.random.choice(overweight_items)] = 0\n        return individual\n\n    # Generating new population\n    for i in range(POP_SIZE):\n        # Parent selection based on ranking probabilities\n        parents_indices = np.random.choice(POP_SIZE, 2, p=selection_probabilities)\n        parent1, parent2 = individuals[parents_indices[0]], individuals[parents_indices[1]]\n\n        # Recombine and mutate operations\n        child = recombine(parent1, parent2)\n        child = mutate(child)\n\n        # Repair the child to meet problem constraints\n        child = repair(child)\n\n        # Store in new population\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.96982,
          "other_inf": null
     },
     {
          "algorithm": "The novel reproduction function adopts random mutation-based crossover mechanisms, producing offspring by mixing parent genes and altering them slightly while considering non-dominance and weight constraints through elitism and heuristic mutation strategies.",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n    \n    individuals = pops['individuals']\n    rankings = pops['rankings']\n    \n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    \n    # Select elite individuals\n    elite_count = POP_SIZE // 5  # Taking top 20% as elite\n    elite_indices = np.argsort(rankings)[:elite_count]\n    elites = individuals[elite_indices]\n    \n    # Fill part of the new population with elites\n    new_pops[:elite_count] = elites.copy()\n    \n    # Mutation and crossover to create new individuals\n    for i in range(elite_count, POP_SIZE):\n        # Pick two different random parents from elite set\n        parents_indices = np.random.choice(elite_indices, 2, replace=False)\n        parent1 = individuals[parents_indices[0]]\n        parent2 = individuals[parents_indices[1]]\n        \n        # Single-point crossover\n        point = np.random.randint(1, N_P)\n        child = np.hstack((parent1[:point], parent2[point:]))\n\n        # Mutation: random flip of bits with low probability\n        mutation_prob = 0.05\n        for j in range(N_P):\n            if np.random.random() < mutation_prob:\n                child[j] = 1 - child[j]\n\n        # Ensure child respects the knapsack capacity constraint\n        while np.dot(child, W) > C:\n            # Identify items to potentially remove (randomly find set bits and try turning some off)\n            nonzero_indices = np.where(child == 1)[0]\n            if len(nonzero_indices) == 0:\n                break\n            child[np.random.choice(nonzero_indices)] = 0\n        \n        new_pops[i] = child\n    \n    return new_pops",
          "objective": 0.96594,
          "other_inf": null
     },
     {
          "algorithm": "A novel reproduction function for a multi-objective knapsack problem using mutation-based strategy that emphasizes lightweight cross mutations and elite retention for generating the next generation with adherence to weight constraints.",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n    \n    # Extract individuals and rankings\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n    \n    # Initialize new population\n    new_pops = np.zeros_like(individuals)\n\n    # Elite selection: top 10% unchanged\n    elite_size = int(0.1 * POP_SIZE)\n    elite_indices = np.argsort(rankings)[:elite_size]\n    new_pops[:elite_size] = individuals[elite_indices]\n\n    # Generation of new individuals for non-elite 90%\n    for i in range(elite_size, POP_SIZE):\n        # Select two different parents from the top 50% based on rankings\n        potential_parents = np.argsort(rankings)[:POP_SIZE // 2]\n        parent1, parent2 = np.random.choice(potential_parents, 2, replace=False)\n\n        # Cross Mutation: mix genes of both parents, introduce random mutations\n        child = np.where(np.random.rand(N_P) < 0.5, individuals[parent1], individuals[parent2])\n        mutation_mask = np.random.rand(N_P) < 0.1  # mutation rate of 10%\n        child = np.where(mutation_mask, 1 - child, child)\n\n        # Resolve weight constraint violations\n        while np.dot(W, child) > C:\n            # Randomly drop items until within capacity\n            indices_to_drop = np.where(child == 1)[0]\n            if len(indices_to_drop) > 0:\n                dropped_index = np.random.choice(indices_to_drop)\n                child[dropped_index] = 0\n            else:\n                break\n\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.9256,
          "other_inf": null
     }
]