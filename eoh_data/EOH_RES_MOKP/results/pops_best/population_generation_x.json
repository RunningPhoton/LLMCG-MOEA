{
     "algorithm": "Algorithm uses rank-based sampling with blend crossover and proactive weight adjustment while ensuring diversity using value-biased mutation.",
     "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n    \n    individuals = pops['individuals']\n    rankings = pops['rankings']\n\n    new_pops = np.zeros_like(individuals)\n\n    # {Algorithm uses rank-based sampling with blend crossover and proactive weight adjustment while ensuring diversity using value-biased mutation.}\n    \n    # Normalize rankings to create weights inversely proportional to rank (better rank, higher chance)\n    weights = 1 / (rankings + 1)\n    weights /= np.sum(weights)\n    \n    # Blend crossover function\n    def blend_crossover(parent1, parent2, alpha=0.5):\n        return np.where(np.random.rand(N_P) < alpha, parent1, parent2)\n\n    # Mutation function increases chances of including high value density items\n    value_density = V.sum(axis=1) / W\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    \n    # Proactive weight adjustment\n    def adjust_weight(child):\n        while np.dot(child, W) > C:\n            # Prioritize removing items with low value density\n            for idx in np.argsort(value_density):\n                if child[idx] == 1:\n                    child[idx] = 0\n                    if np.dot(child, W) <= C:\n                        break\n        return child\n    \n    for i in range(POP_SIZE):\n        # Select two parents based on weighted sampling\n        parents_indices = np.random.choice(POP_SIZE, size=2, p=weights, replace=False)\n        parent1, parent2 = individuals[parents_indices[0]], individuals[parents_indices[1]]\n        \n        # Blend crossover\n        child = blend_crossover(parent1, parent2)\n\n        # Mutation biased by value density\n        higher_value_chance = value_density / np.sum(value_density)\n        mutation_mask = np.random.rand(N_P) < higher_value_chance * 0.1  # 10% mutation rate\n        child = (child + mutation_mask) % 2\n        \n        # Adjust child weight\n        child = adjust_weight(child)\n\n        new_pops[i] = child\n\n    return new_pops",
     "objective": 0.98839,
     "other_inf": null
}