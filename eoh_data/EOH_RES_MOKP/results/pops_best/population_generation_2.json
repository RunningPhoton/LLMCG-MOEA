{
     "algorithm": "```",
     "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n    \n    # Get individuals and rankings from input population\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n    \n    # Create a new empty population\n    new_pops = np.zeros_like(individuals)\n    \n    # Fitness function to score each individual based on their total profit and penalty for exceeding weight\n    def fitness(individual):\n        total_weight = np.dot(individual, W)\n        total_profits = np.dot(individual, V)\n        if total_weight > C:\n            return -1  # Heavy penalty if above capacity\n        return np.sum(total_profits)  # Sum of profits as fitness\n\n    # Roulette wheel selection based on rankings\n    def roulette_selection():\n        max_rank = np.max(rankings)\n        inverse_rankings = max_rank - rankings + 1  # Invert rankings for selection probability\n        probabilities = inverse_rankings / np.sum(inverse_rankings)\n        selected_index = np.random.choice(POP_SIZE, p=probabilities)\n        return individuals[selected_index]\n\n    # Perform crossover between two parents to generate a single child\n    def crossover(parent1, parent2):\n        cut_point = np.random.randint(0, N_P)\n        child = np.concatenate([parent1[:cut_point], parent2[cut_point:]])\n        return child\n\n    # Mutation process for generated offspring\n    def mutate(individual):\n        mutation_rate = 0.1\n        for i in range(N_P):\n            if np.random.rand() < mutation_rate:\n                individual[i] = 1 - individual[i]\n                # After mutation, check and fix if the weight exceeds capacity\n                if np.dot(individual, W) > C:\n                    individual[i] = 1 - individual[i]  # revert mutation\n        return individual\n\n    # Main loop to generate new population\n    for i in range(POP_SIZE):\n        # Selection of parents\n        parent1 = roulette_selection()\n        parent2 = roulette_selection()\n        \n        # Crossover to create a child\n        child = crossover(parent1, parent2)\n        \n        # Mutation of the child\n        child = mutate(child)\n        \n        # Fitness evaluation and potential repair\n        while np.dot(child, W) > C:\n            # Randomly set items to 0 until the total weight is under or equal the capacity\n            idxs = np.where(child == 1)[0]\n            if len(idxs) > 0:  # make sure there is something to remove\n                drop_idx = np.random.choice(idxs)\n                child[drop_idx] = 0\n        \n        # Storing the new individual in the new population\n        new_pops[i] = child\n    \n    return new_pops",
     "objective": 0.98583,
     "other_inf": null
}