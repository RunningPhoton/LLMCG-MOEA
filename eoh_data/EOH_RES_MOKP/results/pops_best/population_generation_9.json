{
     "algorithm": "```",
     "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n    \n    # Initialize the new population array\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    \n    # Get individuals and their rankings from input population data\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n    \n    # Calculate multi-objective profit-weight ratio (considering all profit dimensions)\n    # Aggregate profit per item as the mean across multiple objectives\n    aggregate_profits = V.mean(axis=1)\n    profit_weight_ratio = aggregate_profits / W\n    \n    # Sort items based on profit-weight ratio in descending order\n    sorted_indices = np.argsort(-profit_weight_ratio)\n    \n    top_individuals_count = POP_SIZE // 2\n    \n    # Half of the new population comes from top individuals of the current population\n    top_individuals_sorted_by_rank = individuals[np.argsort(rankings)[:top_individuals_count]]\n    new_pops[:top_individuals_count] = top_individuals_sorted_by_rank.copy()\n    \n    # Remainder of the population is filled by a new knapsack filling strategy\n    for i in range(top_individuals_count, POP_SIZE):\n        current_weight = 0\n        knapsack = np.zeros(N_P, dtype=np.int32)\n        \n        # Attempt to fill the knapsack using sorted item indices based on profit/weight ratio\n        for idx in sorted_indices:\n            item_weight = W[idx]\n            if current_weight + item_weight <= C:\n                knapsack[idx] = 1\n                current_weight += item_weight\n            if current_weight >= C:\n                break\n        \n        # Mutation: Introduce variability by toggling random items with low probability\n        mutation_prob = 0.05  # lower probability of mutation for more stability\n        for j in range(N_P):\n            if np.random.rand() < mutation_prob:\n                proposed_change = 1 - knapsack[j]\n                potential_weight_change = W[j] if proposed_change == 1 else -W[j]\n                if current_weight + potential_weight_change <= C:\n                    knapsack[j] = proposed_change\n                    current_weight += potential_weight_change\n        \n        new_pops[i] = knapsack\n    \n    return new_pops",
     "objective": 0.98799,
     "other_inf": null
}