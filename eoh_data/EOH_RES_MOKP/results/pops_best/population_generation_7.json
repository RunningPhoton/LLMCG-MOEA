{
     "algorithm": "Utilize Fitness Proportional Selection for parents, Bitwise Crossover for child generation,\n    #  and a Greedy Knapsack Solver for weight constraint enforcement using value-weight ratio guidance.",
     "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n    \n    # {Utilize Fitness Proportional Selection for parents, Bitwise Crossover for child generation,\n    #  and a Greedy Knapsack Solver for weight constraint enforcement using value-weight ratio guidance.}\n    \n    individuals = pops['individuals']\n    rankings = pops['rankings']\n\n    # Fitness proportional selection\n    def fitness_proportional_selection():\n        fitness_scores = 1.0 / (1.0 + rankings)\n        probabilities = fitness_scores / np.sum(fitness_scores)\n        # Select two individuals according to their fitness probabilities\n        selected_indices = np.random.choice(POP_SIZE, size=2, p=probabilities, replace=False)\n        return individuals[selected_indices[0]], individuals[selected_indices[1]]\n\n    # Bitwise crossover operation\n    def bitwise_crossover(parent1, parent2):\n        # Random crossover points\n        crossover_mask = np.random.randint(0, 2, size=N_P, dtype=bool)\n        child = np.where(crossover_mask, parent1, parent2)\n        return child\n\n    # Greedy knapsack solver based on item value-weight ratio\n    def greedy_knapsack_solver(individual):\n        value_weight_ratio = np.sum(V, axis=1) / W  # sum across all profits for simplicity\n        item_indices = np.argsort(-value_weight_ratio)  # maximize value/weight ratio, descending order\n        knapsack_weight = 0\n        solution = np.zeros(N_P, dtype=int)\n        for idx in item_indices:\n            if individual[idx] == 1 and knapsack_weight + W[idx] <= C:\n                solution[idx] = 1\n                knapsack_weight += W[idx]\n        return solution\n\n    # Mutation\n    def mutate(child):\n        mutation_rate = 0.01  # Small mutation chance\n        for i in range(N_P):\n            if np.random.rand() < mutation_rate:\n                child[i] = 1 - child[i]  # Flip bit\n        return child\n\n    new_pops = np.zeros_like(individuals)\n    \n    for i in range(POP_SIZE):\n        # Select parents\n        parent1, parent2 = fitness_proportional_selection()\n        # Generate a new child\n        child = bitwise_crossover(parent1, parent2)\n        # Possibly mutate the child\n        child = mutate(child)\n        # Repair child to fit knapsack constraints\n        child = greedy_knapsack_solver(child)\n        # Store in new population\n        new_pops[i] = child\n\n    return new_pops",
     "objective": 0.98798,
     "other_inf": null
}