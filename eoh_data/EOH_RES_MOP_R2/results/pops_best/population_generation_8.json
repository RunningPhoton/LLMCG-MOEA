{
     "algorithm": "A novel reproduction function with simulated binary crossover, adaptive mutation, and generation-wise elitism.",
     "code": "def next_generation(pops, search_trajectory, xlb, xub, POP_SIZE, N_P, current_gen, max_gen):\n    \"\"\"\n    {A novel reproduction function with simulated binary crossover, adaptive mutation, and generation-wise elitism.}\n    \"\"\"\n    import numpy as np\n    \n    # Parameters\n    eta_c = 20  # Crossover distribution index\n    eta_m = 20  # Mutation distribution index\n    mut_prob = 1.0 / N_P  # Mutation probability per gene\n    elite_factor = 0.1  # Proportion of elite individuals\n    elite_size = int(elite_factor * POP_SIZE)\n\n    # Simulated binary crossover function\n    def simulated_binary_crossover(p1, p2):\n        offspring1, offspring2 = np.copy(p1), np.copy(p2)\n        for i in range(N_P):\n            if np.random.rand() <= 0.5:\n                if abs(p1[i] - p2[i]) > 1e-14:  # Prevent division by zero\n                    y1 = min(p1[i], p2[i])\n                    y2 = max(p1[i], p2[i])\n                    rand = np.random.rand()\n                    beta = 1.0 + (2.0 * (y1 - xlb[i]) / (y2 - y1))\n                    alpha = 2.0 - beta**-(eta_c + 1)\n                    beta_q = 0\n                    if rand <= (1.0 / alpha):\n                        beta_q = (rand * alpha)**(1.0 / (eta_c + 1))\n                    else:\n                        beta_q = (1.0 / (2.0 - rand * alpha))**(1.0 / (eta_c + 1))\n                    c1 = 0.5 * ((y1 + y2) - beta_q * (y2 - y1))\n\n                    beta = 1.0 + (2.0 * (xub[i] - y2) / (y2 - y1))\n                    alpha = 2.0 - beta**-(eta_c + 1)\n                    if rand <= (1.0 / alpha):\n                        beta_q = (rand * alpha)**(1.0 / (eta_c + 1))\n                    else:\n                        beta_q = (1.0 / (2.0 - rand * alpha))**(1.0 / (eta_c + 1))\n                    c2 = 0.5 * ((y1 + y2) + beta_q * (y2 - y1))\n\n                    c1 = np.clip(c1, xlb[i], xub[i])\n                    c2 = np.clip(c2, xlb[i], xub[i])\n\n                    if np.random.rand() <= 0.5:\n                        offspring1[i] = c2\n                        offspring2[i] = c1\n                    else:\n                        offspring1[i] = c1\n                        offspring2[i] = c2\n\n        return offspring1, offspring2\n\n    # Adaptive mutation function\n    def adaptive_mutation(individual):\n        mutant = np.copy(individual)\n        for i in range(N_P):\n            if np.random.rand() < mut_prob:\n                delta = 0\n                rand = np.random.rand()\n                if rand < 0.5:\n                    delta = (2.0 * rand)**(1.0 / (1.0 + eta_m)) - 1.0\n                else:\n                    delta = 1.0 - (2.0 * (1.0 - rand))**(1.0 / (1.0 + eta_m))\n                mutant[i] += delta * (xub[i] - xlb[i])\n                mutant[i] = np.clip(mutant[i], xlb[i], xub[i])\n        return mutant\n\n    # Generation-wise elitism function\n    def elitism(individuals, rankings, elite_size):\n        elite_indices = np.argpartition(rankings, elite_size)[:elite_size]\n        return individuals[elite_indices]\n\n    # Main reproduction function\n    def next_population(pops):\n        individuals = pops['individuals']\n        rankings = pops['rankings']\n        new_individuals = []\n        elite_individuals = elitism(individuals, rankings, elite_size)\n        while len(new_individuals) < POP_SIZE - elite_size:\n            parents_indices = np.random.choice(POP_SIZE, 2, replace=False)\n            p1, p2 = individuals[parents_indices[0]], individuals[parents_indices[1]]\n            offspring1, offspring2 = simulated_binary_crossover(p1, p2)\n            offspring1 = adaptive_mutation(offspring1)\n            offspring2 = adaptive_mutation(offspring2)\n            new_individuals.append(offspring1)\n            if len(new_individuals) < POP_SIZE - elite_size:\n                new_individuals.append(offspring2)\n        new_individuals.extend(elite_individuals)\n        return np.array(new_individuals)\n\n    # Generate the next population\n    new_pops = next_population(pops)\n\n    return new_pops",
     "objective": 0.66578,
     "other_inf": null
}