{
     "algorithm": "This novel algorithm uses a simulated annealing inspired selection mechanism with polynomial mutation \n    and single-point crossover to balance exploration and exploitation in generating the next population.",
     "code": "def next_generation(pops, search_trajectory, xlb, xub, POP_SIZE, N_P, current_gen, max_gen):\n    \"\"\"\n    {This novel algorithm uses a simulated annealing inspired selection mechanism with polynomial mutation \n    and single-point crossover to balance exploration and exploitation in generating the next population.}\n    \"\"\"\n    import numpy as np\n    \n    def polynomial_mutation(individual, eta=20):\n        # Polynomial mutation\n        for i in range(N_P):\n            if np.random.rand() < 1.0 / N_P:\n                delta = np.random.rand()\n                if delta < 0.5:\n                    delta_q = (2.0 * delta)**(1.0 / (eta + 1)) - 1.0\n                else:\n                    delta_q = 1.0 - (2.0 * (1.0 - delta))**(1.0 / (eta + 1))\n                individual[i] += delta_q * (xub[i] - xlb[i])\n                individual[i] = np.clip(individual[i], xlb[i], xub[i])\n        return individual\n    \n    def single_point_crossover(parent1, parent2):\n        # Single-point crossover\n        if np.random.rand() < 0.9:  # Crossover probability\n            point = np.random.randint(1, N_P)\n            return np.concatenate((parent1[:point], parent2[point:]))\n        else:\n            return parent1\n    \n    def simulated_annealing_selection(individual, best_individual, temperature):\n        # Simulated annealing inspired selection\n        cost_diff = np.linalg.norm(individual - best_individual)\n        if cost_diff < 0 or np.random.rand() < np.exp(-cost_diff / temperature):\n            return individual\n        else:\n            return best_individual\n    \n    def generate_new_population(pops):\n        new_pops = []\n        best_individual = pops['individuals'][0]  # Assuming the first individual is the best\n        temperature = max_gen / (current_gen + 1)  # Decreasing temperature\n        \n        for _ in range(POP_SIZE):\n            parent1_idx, parent2_idx = np.random.choice(POP_SIZE, 2, replace=False)\n            parent1 = pops['individuals'][parent1_idx]\n            parent2 = pops['individuals'][parent2_idx]\n            \n            child = single_point_crossover(parent1, parent2)\n            child = polynomial_mutation(child)\n            child = simulated_annealing_selection(child, best_individual, temperature)\n            \n            new_pops.append(child)\n        \n        return np.array(new_pops)\n    \n    new_pops = generate_new_population(pops)\n    return new_pops",
     "objective": 0.33992,
     "other_inf": null
}