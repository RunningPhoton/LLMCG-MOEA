{
     "algorithm": "\nThe new algorithm performs tournament selection, uniform crossover, bit-flip mutation, and a first-fit repair strategy to ensure weight constraints are met.\n",
     "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n    \n    # Tournament selection\n    def tournament_selection(pops):\n        tournament_size = 3\n        indices = np.random.choice(POP_SIZE, tournament_size, replace=False)\n        tournament = pops['individuals'][indices]\n        tournament_ranks = pops['rankings'][indices]\n        winner_index = indices[np.argmin(tournament_ranks)]\n        return pops['individuals'][winner_index]\n\n    # Uniform crossover\n    def uniform_crossover(parent1, parent2):\n        crossover_mask = np.random.rand(N_P) < 0.5\n        child = np.where(crossover_mask, parent1, parent2)\n        return child\n\n    # Bit-flip mutation\n    def bit_flip_mutation(individual):\n        mutation_rate = 0.05\n        mutation_mask = np.random.rand(N_P) < mutation_rate\n        individual[mutation_mask] = 1 - individual[mutation_mask]\n        return individual\n\n    # First-fit repair strategy\n    def first_fit_repair(individual):\n        if np.dot(individual, W) > C:\n            sorted_indices = np.argsort(-V.sum(axis=1) / W)  # Sort by descending efficiency\n            individual[:] = 0  # Reset individual\n            current_weight = 0\n            for index in sorted_indices:\n                if current_weight + W[index] <= C:\n                    individual[index] = 1\n                    current_weight += W[index]\n        return individual\n\n    # Generate new individual\n    def generate_new_individual():\n        parent1 = tournament_selection(pops)\n        parent2 = tournament_selection(pops)\n        child = uniform_crossover(parent1, parent2)\n        child = bit_flip_mutation(child)\n        child = first_fit_repair(child)\n        return child\n\n    # Generate new population\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        new_pops[i] = generate_new_individual()\n\n    return new_pops",
     "objective": 0.98834,
     "other_inf": null
}