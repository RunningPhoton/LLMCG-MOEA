{
     "algorithm": "```",
     "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n    \n    # Sub-function for rank-based selection\n    def rank_based_selection(ranked_pop):\n        # Calculate selection probabilities inversely proportional to rankings\n        selection_probs = 1 / (1 + ranked_pop['rankings'])\n        selection_probs /= selection_probs.sum()\n        selected_index = np.random.choice(POP_SIZE, p=selection_probs)\n        return ranked_pop['individuals'][selected_index]\n\n    # Sub-function for single point crossover\n    def single_point_crossover(parent1, parent2):\n        crossover_point = np.random.randint(1, N_P)\n        child = np.concatenate([parent1[:crossover_point], parent2[crossover_point:]])\n        return child\n\n    # Sub-function for mutation with a decreasing mutation rate\n    def decreasing_mutation(individual, generation, max_generations=100):\n        mutation_rate = 0.1 * (1 - generation / max_generations)\n        mutation_mask = np.random.rand(N_P) < mutation_rate\n        individual[mutation_mask] = 1 - individual[mutation_mask]\n        return individual\n\n    # Sub-function for greedy repair to fix weight constraint violations\n    def greedy_repair(individual):\n        while np.dot(individual, W) > C:\n            nonzero_indices = np.where(individual == 1)[0]\n            if nonzero_indices.size == 0:\n                break\n            efficiencies = np.sum(V[nonzero_indices], axis=1) / W[nonzero_indices]\n            least_efficient_item = nonzero_indices[np.argmin(efficiencies)]\n            individual[least_efficient_item] = 0\n        return individual\n\n    # Sub-function to generate a new individual\n    def generate_new_individual(generation):\n        parent1 = rank_based_selection(pops)\n        parent2 = rank_based_selection(pops)\n        child = single_point_crossover(parent1, parent2)\n        child = decreasing_mutation(child, generation)\n        child = greedy_repair(child)\n        return child\n\n    # Main loop to generate new population\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        new_pops[i] = generate_new_individual(i)  # Pass current generation index as parameter\n\n    return new_pops",
     "objective": 0.98705,
     "other_inf": null
}