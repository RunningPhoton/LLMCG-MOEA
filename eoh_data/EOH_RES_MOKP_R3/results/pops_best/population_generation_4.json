{
     "algorithm": "Generate new population by elitism, bitwise crossover, random mutation, and a proportional repair based on item value/weight ratio.",
     "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    # {Generate new population by elitism, bitwise crossover, random mutation, and a proportional repair based on item value/weight ratio.}\n\n    # Elitism: directly copy a fraction of the best individuals to the new population\n    def elitism(individuals, rankings, fraction=0.1):\n        num_elites = int(POP_SIZE * fraction)\n        elite_indices = np.argsort(rankings)[:num_elites]\n        return individuals[elite_indices]\n\n    # Bitwise crossover: cross over individual bits with a fixed probability\n    def bitwise_crossover(parent1, parent2, crossover_rate=0.5):\n        mask = np.random.rand(N_P) < crossover_rate\n        child = np.where(mask, parent1, parent2)\n        return child\n\n    # Random mutation: flip individual bits with a fixed probability\n    def random_mutation(individual, mutation_rate=0.05):\n        for i in range(N_P):\n            if np.random.rand() < mutation_rate:\n                individual[i] = 1 - individual[i]\n        return individual\n\n    # Proportional repair: remove items based on the lowest value/weight ratio until the weight constraint is met\n    def proportional_repair(individual, W, C, V):\n        weight = np.dot(individual, W)\n        value_weight_ratio = np.sum(V, axis=1) / W  # Sum of values divided by weight\n        while weight > C:\n            # Find items to consider for removal based on the individual and their value/weight ratio\n            items_to_consider = np.where(individual == 1)[0]\n            # Sort items by their value/weight ratio in ascending order\n            items_sorted_by_ratio = items_to_consider[np.argsort(value_weight_ratio[items_to_consider])]\n            # Remove the item with the lowest ratio\n            item_to_remove = items_sorted_by_ratio[0]\n            individual[item_to_remove] = 0\n            weight -= W[item_to_remove]\n        return individual\n\n    # Initialize the new population\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    \n    # Apply elitism to copy the best individuals to the new population\n    elites = elitism(pops['individuals'], pops['rankings'])\n    new_pops[:len(elites)] = elites\n\n    # Generate the rest of the new population\n    for i in range(len(elites), POP_SIZE):\n        # Randomly select two parents from the current population\n        parent_indices = np.random.choice(POP_SIZE, 2, replace=False)\n        parent1, parent2 = pops['individuals'][parent_indices]\n        \n        # Perform bitwise crossover and random mutation\n        child = bitwise_crossover(parent1, parent2)\n        child = random_mutation(child)\n        \n        # Repair the child to ensure it meets the weight constraint\n        child = proportional_repair(child, W, C, V)\n        \n        # Add the child to the new population\n        new_pops[i] = child\n\n    return new_pops",
     "objective": 0.98687,
     "other_inf": null
}