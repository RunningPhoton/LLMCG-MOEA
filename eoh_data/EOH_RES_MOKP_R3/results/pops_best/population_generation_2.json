{
     "algorithm": "```",
     "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    # Tournament-based selection with a tournament size of 2\n    def tournament_selection(rankings, tournament_size=2):\n        selected_indices = []\n        for _ in range(tournament_size):\n            selected_indices.append(np.random.randint(len(rankings)))\n        selected_rankings = rankings[selected_indices]\n        return selected_indices[np.argmin(selected_rankings)]\n\n    # Single-point crossover\n    def single_point_crossover(parent1, parent2):\n        crossover_point = np.random.randint(1, len(parent1))\n        child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        return child\n\n    # Mutation with a dynamic mutation rate based on the individual's rank\n    def dynamic_mutation(individual, rankings, rank):\n        mutation_rate = 0.1 / (1 + np.log(rankings[rank] + 1))\n        mutation_mask = np.random.rand(N_P) < mutation_rate\n        individual ^= mutation_mask.astype(np.int32)\n        return individual\n\n    # Proportional value-to-weight repair mechanism\n    def proportional_repair(individual, W, C, V):\n        weight = np.dot(individual, W)\n        while weight > C:\n            items = np.where(individual == 1)[0]\n            item_weights = W[items]\n            item_values = V[items].sum(axis=1)\n            # Remove the item with the highest weight-to-value ratio\n            ratios = item_weights / item_values\n            remove_idx = items[np.argmax(ratios)]\n            individual[remove_idx] = 0\n            weight -= W[remove_idx]\n        return individual\n\n    # Create offspring using tournament selection, single-point crossover, dynamic mutation, and proportional repair\n    def create_offspring(pops, rankings, W, C, V):\n        parent1_index = tournament_selection(rankings)\n        parent2_index = tournament_selection(rankings)\n        parent1, parent2 = pops['individuals'][parent1_index], pops['individuals'][parent2_index]\n        child = single_point_crossover(parent1, parent2)\n        child = dynamic_mutation(child, rankings, parent1_index)\n        child = proportional_repair(child, W, C, V)\n        return child\n\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        new_pops[i] = create_offspring(pops, pops['rankings'], W, C, V)\n\n    return new_pops",
     "objective": 0.98682,
     "other_inf": null
}