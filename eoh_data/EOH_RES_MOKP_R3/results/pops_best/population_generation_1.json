{
     "algorithm": "```",
     "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n\n    def rank_based_selection(rankings):\n        probabilities = 1 / (rankings + 1)\n        probabilities /= probabilities.sum()\n        return np.random.choice(len(rankings), p=probabilities)\n\n    def uniform_crossover(parent1, parent2):\n        mask = np.random.randint(2, size=len(parent1))\n        child = np.where(mask, parent1, parent2)\n        return child\n\n    def bit_flip_mutation(individual, mutation_rate=0.1):\n        mutation_mask = np.random.rand(N_P) < mutation_rate\n        individual ^= mutation_mask.astype(np.int32)\n        return individual\n\n    def greedy_repair(individual, W, C):\n        weight = np.dot(individual, W)\n        while weight > C:\n            items = np.where(individual == 1)[0]\n            item_weights = W[items]\n            item_values = V[items].sum(axis=1)\n            # Remove the item with the lowest value-to-weight ratio\n            ratios = item_values / item_weights\n            remove_idx = items[np.argmin(ratios)]\n            individual[remove_idx] = 0\n            weight -= W[remove_idx]\n        return individual\n\n    def create_offspring(pops, rankings, W, C):\n        parent1_index = rank_based_selection(rankings)\n        parent2_index = rank_based_selection(rankings)\n        parent1, parent2 = pops['individuals'][parent1_index], pops['individuals'][parent2_index]\n        child = uniform_crossover(parent1, parent2)\n        child = bit_flip_mutation(child)\n        child = greedy_repair(child, W, C)\n        return child\n\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        new_pops[i] = create_offspring(pops, pops['rankings'], W, C)\n    \n    return new_pops",
     "objective": 0.98662,
     "other_inf": null
}