{
     "algorithm": "Create a new population using rank-based selection, two-point crossover, and a greedy mutation that selectively adds items based on a sorted value-to-weight ratio, followed by a trimming process to remove items if the weight constraint is exceeded.",
     "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n    \n    # Common backbone idea: Selection, Crossover, Mutation, and Repair to generate a new population.\n    \n    # {Create a new population using rank-based selection, two-point crossover, and a greedy mutation that selectively adds items based on a sorted value-to-weight ratio, followed by a trimming process to remove items if the weight constraint is exceeded.}\n    \n    # Rank-based selection\n    def rank_based_selection():\n        probabilities = 1 / (np.arange(1, POP_SIZE + 1))  # Inverse rank probabilities\n        probabilities /= probabilities.sum()  # Normalize to get a probability distribution\n        selected_index = np.random.choice(POP_SIZE, p=probabilities)\n        return pops['individuals'][selected_index]\n    \n    # Two-point crossover\n    def two_point_crossover(parent1, parent2):\n        points = np.sort(np.random.choice(N_P, 2, replace=False))\n        child = np.concatenate((parent1[:points[0]], parent2[points[0]:points[1]], parent1[points[1]:]))\n        return child\n    \n    # Greedy mutation\n    def greedy_mutation(individual):\n        value_weight_ratio = V.sum(axis=1) / W\n        sorted_indices = np.argsort(-value_weight_ratio)\n        for index in sorted_indices:\n            if individual[index] == 0 and np.dot(individual, W) + W[index] <= C:\n                individual[index] = 1\n        return individual\n    \n    # Trimming process\n    def trim_to_fit(individual):\n        while np.dot(individual, W) > C:\n            included_items = np.where(individual == 1)[0]\n            value_weight_ratio = V[included_items].sum(axis=1) / W[included_items]\n            least_efficient_item = included_items[np.argmin(value_weight_ratio)]\n            individual[least_efficient_item] = 0\n        return individual\n    \n    # Generate new population\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        parent1 = rank_based_selection()\n        parent2 = rank_based_selection()\n        child = two_point_crossover(parent1, parent2)\n        child = greedy_mutation(child)\n        child = trim_to_fit(child)\n        new_pops[i] = child\n    \n    return new_pops",
     "objective": 0.98888,
     "other_inf": null
}