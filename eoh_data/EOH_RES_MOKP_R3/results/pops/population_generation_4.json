[
     {
          "algorithm": "Generate new population by elitism, bitwise crossover, random mutation, and a proportional repair based on item value/weight ratio.",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    # {Generate new population by elitism, bitwise crossover, random mutation, and a proportional repair based on item value/weight ratio.}\n\n    # Elitism: directly copy a fraction of the best individuals to the new population\n    def elitism(individuals, rankings, fraction=0.1):\n        num_elites = int(POP_SIZE * fraction)\n        elite_indices = np.argsort(rankings)[:num_elites]\n        return individuals[elite_indices]\n\n    # Bitwise crossover: cross over individual bits with a fixed probability\n    def bitwise_crossover(parent1, parent2, crossover_rate=0.5):\n        mask = np.random.rand(N_P) < crossover_rate\n        child = np.where(mask, parent1, parent2)\n        return child\n\n    # Random mutation: flip individual bits with a fixed probability\n    def random_mutation(individual, mutation_rate=0.05):\n        for i in range(N_P):\n            if np.random.rand() < mutation_rate:\n                individual[i] = 1 - individual[i]\n        return individual\n\n    # Proportional repair: remove items based on the lowest value/weight ratio until the weight constraint is met\n    def proportional_repair(individual, W, C, V):\n        weight = np.dot(individual, W)\n        value_weight_ratio = np.sum(V, axis=1) / W  # Sum of values divided by weight\n        while weight > C:\n            # Find items to consider for removal based on the individual and their value/weight ratio\n            items_to_consider = np.where(individual == 1)[0]\n            # Sort items by their value/weight ratio in ascending order\n            items_sorted_by_ratio = items_to_consider[np.argsort(value_weight_ratio[items_to_consider])]\n            # Remove the item with the lowest ratio\n            item_to_remove = items_sorted_by_ratio[0]\n            individual[item_to_remove] = 0\n            weight -= W[item_to_remove]\n        return individual\n\n    # Initialize the new population\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    \n    # Apply elitism to copy the best individuals to the new population\n    elites = elitism(pops['individuals'], pops['rankings'])\n    new_pops[:len(elites)] = elites\n\n    # Generate the rest of the new population\n    for i in range(len(elites), POP_SIZE):\n        # Randomly select two parents from the current population\n        parent_indices = np.random.choice(POP_SIZE, 2, replace=False)\n        parent1, parent2 = pops['individuals'][parent_indices]\n        \n        # Perform bitwise crossover and random mutation\n        child = bitwise_crossover(parent1, parent2)\n        child = random_mutation(child)\n        \n        # Repair the child to ensure it meets the weight constraint\n        child = proportional_repair(child, W, C, V)\n        \n        # Add the child to the new population\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.98687,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    # Tournament-based selection with a tournament size of 2\n    def tournament_selection(rankings, tournament_size=2):\n        selected_indices = []\n        for _ in range(tournament_size):\n            selected_indices.append(np.random.randint(len(rankings)))\n        selected_rankings = rankings[selected_indices]\n        return selected_indices[np.argmin(selected_rankings)]\n\n    # Single-point crossover\n    def single_point_crossover(parent1, parent2):\n        crossover_point = np.random.randint(1, len(parent1))\n        child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        return child\n\n    # Mutation with a dynamic mutation rate based on the individual's rank\n    def dynamic_mutation(individual, rankings, rank):\n        mutation_rate = 0.1 / (1 + np.log(rankings[rank] + 1))\n        mutation_mask = np.random.rand(N_P) < mutation_rate\n        individual ^= mutation_mask.astype(np.int32)\n        return individual\n\n    # Proportional value-to-weight repair mechanism\n    def proportional_repair(individual, W, C, V):\n        weight = np.dot(individual, W)\n        while weight > C:\n            items = np.where(individual == 1)[0]\n            item_weights = W[items]\n            item_values = V[items].sum(axis=1)\n            # Remove the item with the highest weight-to-value ratio\n            ratios = item_weights / item_values\n            remove_idx = items[np.argmax(ratios)]\n            individual[remove_idx] = 0\n            weight -= W[remove_idx]\n        return individual\n\n    # Create offspring using tournament selection, single-point crossover, dynamic mutation, and proportional repair\n    def create_offspring(pops, rankings, W, C, V):\n        parent1_index = tournament_selection(rankings)\n        parent2_index = tournament_selection(rankings)\n        parent1, parent2 = pops['individuals'][parent1_index], pops['individuals'][parent2_index]\n        child = single_point_crossover(parent1, parent2)\n        child = dynamic_mutation(child, rankings, parent1_index)\n        child = proportional_repair(child, W, C, V)\n        return child\n\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        new_pops[i] = create_offspring(pops, pops['rankings'], W, C, V)\n\n    return new_pops",
          "objective": 0.98682,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n\n    def tournament_selection(ranked_pop, tournament_size=3):\n        # Select individuals for the tournament\n        selected_indices = np.random.choice(POP_SIZE, tournament_size, replace=False)\n        # Find the best individual among the selected\n        best_index = selected_indices[np.argmin(ranked_pop['rankings'][selected_indices])]\n        return ranked_pop['individuals'][best_index]\n\n    def uniform_crossover(parent1, parent2):\n        child = np.where(np.random.rand(N_P) < 0.5, parent1, parent2)\n        return child\n\n    def bit_flip_mutation(individual, mutation_rate=0.1):\n        mutation_mask = np.random.rand(N_P) < mutation_rate\n        individual[mutation_mask] = 1 - individual[mutation_mask]\n        return individual\n\n    def greedy_repair(individual):\n        while np.dot(individual, W) > C:\n            # Select items that can be removed (non-zero in individual)\n            # and sort them by their efficiency (value/weight ratio)\n            nonzero_indices = np.where(individual == 1)[0]\n            if nonzero_indices.size == 0:\n                break\n            efficiencies = np.sum(V[nonzero_indices], axis=1) / W[nonzero_indices]\n            # Find the least efficient item and remove it\n            least_efficient_item = nonzero_indices[np.argmin(efficiencies)]\n            individual[least_efficient_item] = 0\n        return individual\n\n    def generate_new_individual():\n        parent1 = tournament_selection(pops)\n        parent2 = tournament_selection(pops)\n        child = uniform_crossover(parent1, parent2)\n        child = bit_flip_mutation(child)\n        child = greedy_repair(child)\n        return child\n\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        new_pops[i] = generate_new_individual()\n\n    return new_pops",
          "objective": 0.98678,
          "other_inf": null
     },
     {
          "algorithm": "Enhance the population by tournament selection, single-point crossover, bit-flip mutation with adaptive rate, and a greedy repair mechanism that considers profit-to-weight ratio.",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n    \n    # New algorithm in one sentence: {Enhance the population by tournament selection, single-point crossover, bit-flip mutation with adaptive rate, and a greedy repair mechanism that considers profit-to-weight ratio.}\n\n    # Tournament selection\n    def tournament_selection(population, rankings, tournament_size=2):\n        selected = []\n        for _ in range(tournament_size):\n            participants = np.random.choice(len(population), tournament_size, replace=False)\n            winner_idx = participants[np.argmin(rankings[participants])]\n            selected.append(population[winner_idx])\n        return np.array(selected)\n    \n    # Single-point crossover\n    def single_point_crossover(parent1, parent2):\n        crossover_point = np.random.randint(0, N_P)\n        child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        return child\n\n    # Bit-flip mutation with adaptive rate\n    def adaptive_mutation(individual, generation):\n        mutation_rate = 0.1 * (1 - generation / 1000)  # Example of an adaptive rate\n        mutation_mask = np.random.rand(N_P) < mutation_rate\n        individual[mutation_mask] = 1 - individual[mutation_mask]\n        return individual\n\n    # Greedy repair mechanism considering profit-to-weight ratio\n    def greedy_repair(individual, W, C, V):\n        weight = np.dot(individual, W)\n        value_per_weight = np.sum(V, axis=1) / W  # Calculate profit-to-weight ratio\n        while weight > C:\n            items_to_remove = np.where(individual == 1)[0]\n            # Sort items by profit-to-weight ratio to remove less efficient ones first\n            items_sorted_by_ratio = items_to_remove[np.argsort(value_per_weight[items_to_remove])]\n            for item in items_sorted_by_ratio:\n                individual[item] = 0\n                weight -= W[item]\n                if weight <= C:\n                    break\n        return individual\n    \n    individuals = pops['individuals']\n    rankings = pops['rankings']\n    generation = 0  # Initialize generation counter\n\n    new_population = []\n    while len(new_population) < POP_SIZE:\n        # Select two parents using tournament selection\n        parent1, parent2 = tournament_selection(individuals, rankings)\n        child = single_point_crossover(parent1, parent2)\n        child = adaptive_mutation(child, generation)\n        child = greedy_repair(child, W, C, V)\n        new_population.append(child)\n        generation += 1\n\n    new_pops = np.array(new_population, dtype=np.int32)\n    return new_pops",
          "objective": 0.98667,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n\n    def rank_based_selection(rankings):\n        probabilities = 1 / (rankings + 1)\n        probabilities /= probabilities.sum()\n        return np.random.choice(len(rankings), p=probabilities)\n\n    def uniform_crossover(parent1, parent2):\n        mask = np.random.randint(2, size=len(parent1))\n        child = np.where(mask, parent1, parent2)\n        return child\n\n    def bit_flip_mutation(individual, mutation_rate=0.1):\n        mutation_mask = np.random.rand(N_P) < mutation_rate\n        individual ^= mutation_mask.astype(np.int32)\n        return individual\n\n    def greedy_repair(individual, W, C):\n        weight = np.dot(individual, W)\n        while weight > C:\n            items = np.where(individual == 1)[0]\n            item_weights = W[items]\n            item_values = V[items].sum(axis=1)\n            # Remove the item with the lowest value-to-weight ratio\n            ratios = item_values / item_weights\n            remove_idx = items[np.argmin(ratios)]\n            individual[remove_idx] = 0\n            weight -= W[remove_idx]\n        return individual\n\n    def create_offspring(pops, rankings, W, C):\n        parent1_index = rank_based_selection(rankings)\n        parent2_index = rank_based_selection(rankings)\n        parent1, parent2 = pops['individuals'][parent1_index], pops['individuals'][parent2_index]\n        child = uniform_crossover(parent1, parent2)\n        child = bit_flip_mutation(child)\n        child = greedy_repair(child, W, C)\n        return child\n\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        new_pops[i] = create_offspring(pops, pops['rankings'], W, C)\n    \n    return new_pops",
          "objective": 0.98662,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    # (My novel algorithm uses tournament selection, two-point crossover, and uniform mutation with a fixed mutation rate, followed by a greedy repair function to ensure weight constraint compliance.)\n\n    # Tournament selection\n    def tournament_selection(rankings, tournament_size=3):\n        selected_indices = np.random.choice(len(rankings), tournament_size, replace=False)\n        best_index = selected_indices[np.argmin(rankings[selected_indices])]\n        return best_index\n\n    # Two-point crossover\n    def two_point_crossover(parent1, parent2):\n        point1, point2 = np.sort(np.random.choice(range(1, N_P), 2, replace=False))\n        child = np.zeros(N_P, dtype=np.int32)\n        child[:point1] = parent1[:point1]\n        child[point1:point2] = parent2[point1:point2]\n        child[point2:] = parent1[point2:]\n        return child\n\n    # Uniform mutation\n    def uniform_mutation(individual, mutation_rate=0.05):\n        mutation_mask = np.random.rand(N_P) < mutation_rate\n        individual[mutation_mask] = 1 - individual[mutation_mask]\n        return individual\n\n    # Greedy repair function\n    def greedy_repair(individual):\n        weight = np.dot(individual, W)\n        while weight > C:\n            item_weights = individual * W\n            max_weight_index = np.argmax(item_weights)\n            individual[max_weight_index] = 0\n            weight = np.dot(individual, W)\n        return individual\n\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n\n    for i in range(POP_SIZE):\n        parent1_idx = tournament_selection(pops['rankings'])\n        parent2_idx = tournament_selection(pops['rankings'])\n        parent1 = pops['individuals'][parent1_idx]\n        parent2 = pops['individuals'][parent2_idx]\n\n        child = two_point_crossover(parent1, parent2)\n        child = uniform_mutation(child)\n        child = greedy_repair(child)\n\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.98638,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n\n    # Novel algorithm: Tournament selection, uniform crossover, and inversion mutation, followed by a greedy repair function.\n\n    # Tournament selection\n    def tournament_selection(rankings, tournament_size=3):\n        selected_indices = np.random.choice(len(rankings), tournament_size, replace=False)\n        best_index = selected_indices[np.argmin(rankings[selected_indices])]\n        return best_index\n\n    # Uniform crossover\n    def uniform_crossover(parent1, parent2):\n        mask = np.random.randint(0, 2, size=N_P)\n        child = np.where(mask, parent1, parent2)\n        return child\n\n    # Inversion mutation\n    def inversion_mutation(individual):\n        if np.random.rand() < 0.1:  # Mutation probability\n            start, end = np.sort(np.random.choice(N_P, 2, replace=False))\n            individual[start:end] = individual[start:end][::-1]\n        return individual\n\n    # Greedy repair function\n    def greedy_repair(individual):\n        weight = np.dot(individual, W)\n        while weight > C:\n            item_weights = individual * W\n            max_weight_index = np.argmax(item_weights)\n            individual[max_weight_index] = 0\n            weight = np.dot(individual, W)\n        return individual\n\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n\n    for i in range(POP_SIZE):\n        parent1_idx = tournament_selection(pops['rankings'])\n        parent2_idx = tournament_selection(pops['rankings'])\n        parent1 = pops['individuals'][parent1_idx]\n        parent2 = pops['individuals'][parent2_idx]\n\n        child = uniform_crossover(parent1, parent2)\n        child = inversion_mutation(child)\n        child = greedy_repair(child)\n\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.98601,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n\n    def crossover(parent1, parent2):\n        \"\"\"Perform crossover between two parents to produce an offspring.\"\"\"\n        crossover_point = np.random.randint(1, N_P)\n        offspring = np.hstack((parent1[:crossover_point], parent2[crossover_point:]))\n        return offspring\n\n    def mutate(individual):\n        \"\"\"Perform mutation on an individual.\"\"\"\n        mutation_point = np.random.randint(N_P)\n        individual[mutation_point] = 1 - individual[mutation_point]\n        return individual\n\n    def repair(individual):\n        \"\"\"Repair an individual if it violates the weight constraint.\"\"\"\n        while np.dot(individual, W) > C:\n            overweight_items = np.where((individual == 1) & (W > 0))[0]\n            if overweight_items.size == 0:\n                break\n            item_to_remove = np.random.choice(overweight_items)\n            individual[item_to_remove] = 0\n        return individual\n\n    def select_parents(rankings):\n        \"\"\"Select parents based on their rankings using a tournament selection.\"\"\"\n        tournament_size = 2\n        selected_indices = np.random.choice(POP_SIZE, tournament_size, replace=False)\n        selected_rankings = rankings[selected_indices]\n        winner_index = selected_indices[np.argmin(selected_rankings)]\n        return pops['individuals'][winner_index]\n\n    # Main steps of the reproduction function\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        parent1 = select_parents(pops['rankings'])\n        parent2 = select_parents(pops['rankings'])\n        offspring = crossover(parent1, parent2)\n        offspring = mutate(offspring)\n        offspring = repair(offspring)\n        new_pops[i] = offspring\n\n    return new_pops",
          "objective": 0.98573,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n\n    def crossover(parent1, parent2):\n        \"\"\"Perform uniform crossover between two parents to produce an offspring.\"\"\"\n        mask = np.random.randint(0, 2, size=N_P)\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(individual):\n        \"\"\"Perform mutation on an individual with a lower probability.\"\"\"\n        for i in range(N_P):\n            if np.random.rand() < 0.1:  # Lower mutation rate\n                individual[i] = 1 - individual[i]\n        return individual\n\n    def repair(individual):\n        \"\"\"Repair an individual if it violates the weight constraint by removing items based on the least profit-to-weight ratio.\"\"\"\n        while np.dot(individual, W) > C:\n            item_efficiency = V[:, 0] / W  # Use only the first profit value for simplicity\n            inefficient_items = np.where((individual == 1) & (W > 0))[0]\n            if inefficient_items.size == 0:\n                break\n            item_to_remove = inefficient_items[np.argmin(item_efficiency[inefficient_items])]\n            individual[item_to_remove] = 0\n        return individual\n\n    def rank_based_selection(rankings):\n        \"\"\"Select parents based on their rankings using rank-based selection.\"\"\"\n        probabilities = 1 / (rankings + 1)  # Higher probability for lower ranks\n        probabilities /= probabilities.sum()  # Normalize to create a probability distribution\n        selected_index = np.random.choice(POP_SIZE, p=probabilities)\n        return pops['individuals'][selected_index]\n\n    # Main steps of the reproduction function\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        parent1 = rank_based_selection(pops['rankings'])\n        parent2 = rank_based_selection(pops['rankings'])\n        offspring = crossover(parent1, parent2)\n        offspring = mutate(offspring)\n        offspring = repair(offspring)\n        new_pops[i] = offspring\n\n    return new_pops",
          "objective": 0.98561,
          "other_inf": null
     },
     {
          "algorithm": "Generate a new population by performing rank-based roulette wheel selection, single-point crossover, bit-flip mutation with adaptive rate, and a random item removal repair strategy.",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n\n    # Backbone idea: Use selection, crossover, mutation, and repair to create a new generation.\n    # New algorithm in one sentence: {Generate a new population by performing rank-based roulette wheel selection, single-point crossover, bit-flip mutation with adaptive rate, and a random item removal repair strategy.}\n    \n    def roulette_wheel_selection(rankings):\n        \"\"\"Select an individual using roulette wheel selection based on rankings.\"\"\"\n        max_rank = np.max(rankings)\n        adjusted_fitness = max_rank - rankings + 1\n        probabilities = adjusted_fitness / np.sum(adjusted_fitness)\n        selected_index = np.random.choice(np.arange(POP_SIZE), p=probabilities)\n        return pops['individuals'][selected_index]\n\n    def single_point_crossover(parent1, parent2):\n        \"\"\"Perform single-point crossover between two parents.\"\"\"\n        point = np.random.randint(1, N_P)\n        return np.concatenate([parent1[:point], parent2[point:]])\n\n    def adaptive_mutation(individual, lower_rate=0.01, upper_rate=0.1):\n        \"\"\"Perform bit-flip mutation with an adaptive mutation rate.\"\"\"\n        rate = lower_rate + (upper_rate - lower_rate) * (1 - np.mean(pops['rankings']))\n        for i in range(N_P):\n            if np.random.rand() < rate:\n                individual[i] = 1 - individual[i]\n        return individual\n\n    def random_repair(individual):\n        \"\"\"Randomly remove items until the weight constraint is satisfied.\"\"\"\n        while np.dot(individual, W) > C:\n            possible_to_remove = np.where(individual == 1)[0]\n            if possible_to_remove.size == 0:\n                break\n            remove_idx = np.random.choice(possible_to_remove)\n            individual[remove_idx] = 0\n        return individual\n\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        parent1 = roulette_wheel_selection(pops['rankings'])\n        parent2 = roulette_wheel_selection(pops['rankings'])\n        offspring = single_point_crossover(parent1, parent2)\n        offspring = adaptive_mutation(offspring)\n        offspring = random_repair(offspring)\n        new_pops[i] = offspring\n\n    return new_pops",
          "objective": 0.98542,
          "other_inf": null
     }
]