[
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n\n    def rank_based_selection(rankings):\n        probabilities = 1 / (rankings + 1)\n        probabilities /= probabilities.sum()\n        return np.random.choice(len(rankings), p=probabilities)\n\n    def uniform_crossover(parent1, parent2):\n        mask = np.random.randint(2, size=len(parent1))\n        child = np.where(mask, parent1, parent2)\n        return child\n\n    def bit_flip_mutation(individual, mutation_rate=0.1):\n        mutation_mask = np.random.rand(N_P) < mutation_rate\n        individual ^= mutation_mask.astype(np.int32)\n        return individual\n\n    def greedy_repair(individual, W, C):\n        weight = np.dot(individual, W)\n        while weight > C:\n            items = np.where(individual == 1)[0]\n            item_weights = W[items]\n            item_values = V[items].sum(axis=1)\n            # Remove the item with the lowest value-to-weight ratio\n            ratios = item_values / item_weights\n            remove_idx = items[np.argmin(ratios)]\n            individual[remove_idx] = 0\n            weight -= W[remove_idx]\n        return individual\n\n    def create_offspring(pops, rankings, W, C):\n        parent1_index = rank_based_selection(rankings)\n        parent2_index = rank_based_selection(rankings)\n        parent1, parent2 = pops['individuals'][parent1_index], pops['individuals'][parent2_index]\n        child = uniform_crossover(parent1, parent2)\n        child = bit_flip_mutation(child)\n        child = greedy_repair(child, W, C)\n        return child\n\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        new_pops[i] = create_offspring(pops, pops['rankings'], W, C)\n    \n    return new_pops",
          "objective": 0.98662,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n\n    def crossover(parent1, parent2):\n        \"\"\"Perform crossover between two parents to produce an offspring.\"\"\"\n        crossover_point = np.random.randint(1, N_P)\n        offspring = np.hstack((parent1[:crossover_point], parent2[crossover_point:]))\n        return offspring\n\n    def mutate(individual):\n        \"\"\"Perform mutation on an individual.\"\"\"\n        mutation_point = np.random.randint(N_P)\n        individual[mutation_point] = 1 - individual[mutation_point]\n        return individual\n\n    def repair(individual):\n        \"\"\"Repair an individual if it violates the weight constraint.\"\"\"\n        while np.dot(individual, W) > C:\n            overweight_items = np.where((individual == 1) & (W > 0))[0]\n            if overweight_items.size == 0:\n                break\n            item_to_remove = np.random.choice(overweight_items)\n            individual[item_to_remove] = 0\n        return individual\n\n    def select_parents(rankings):\n        \"\"\"Select parents based on their rankings using a tournament selection.\"\"\"\n        tournament_size = 2\n        selected_indices = np.random.choice(POP_SIZE, tournament_size, replace=False)\n        selected_rankings = rankings[selected_indices]\n        winner_index = selected_indices[np.argmin(selected_rankings)]\n        return pops['individuals'][winner_index]\n\n    # Main steps of the reproduction function\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        parent1 = select_parents(pops['rankings'])\n        parent2 = select_parents(pops['rankings'])\n        offspring = crossover(parent1, parent2)\n        offspring = mutate(offspring)\n        offspring = repair(offspring)\n        new_pops[i] = offspring\n\n    return new_pops",
          "objective": 0.98573,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n\n    def crossover(parent1, parent2):\n        \"\"\"Perform uniform crossover between two parents to produce an offspring.\"\"\"\n        mask = np.random.randint(0, 2, size=N_P)\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def mutate(individual):\n        \"\"\"Perform mutation on an individual with a lower probability.\"\"\"\n        for i in range(N_P):\n            if np.random.rand() < 0.1:  # Lower mutation rate\n                individual[i] = 1 - individual[i]\n        return individual\n\n    def repair(individual):\n        \"\"\"Repair an individual if it violates the weight constraint by removing items based on the least profit-to-weight ratio.\"\"\"\n        while np.dot(individual, W) > C:\n            item_efficiency = V[:, 0] / W  # Use only the first profit value for simplicity\n            inefficient_items = np.where((individual == 1) & (W > 0))[0]\n            if inefficient_items.size == 0:\n                break\n            item_to_remove = inefficient_items[np.argmin(item_efficiency[inefficient_items])]\n            individual[item_to_remove] = 0\n        return individual\n\n    def rank_based_selection(rankings):\n        \"\"\"Select parents based on their rankings using rank-based selection.\"\"\"\n        probabilities = 1 / (rankings + 1)  # Higher probability for lower ranks\n        probabilities /= probabilities.sum()  # Normalize to create a probability distribution\n        selected_index = np.random.choice(POP_SIZE, p=probabilities)\n        return pops['individuals'][selected_index]\n\n    # Main steps of the reproduction function\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        parent1 = rank_based_selection(pops['rankings'])\n        parent2 = rank_based_selection(pops['rankings'])\n        offspring = crossover(parent1, parent2)\n        offspring = mutate(offspring)\n        offspring = repair(offspring)\n        new_pops[i] = offspring\n\n    return new_pops",
          "objective": 0.98561,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n    \n    def crossover(parent1, parent2):\n        child = np.zeros(N_P, dtype=np.int32)\n        crossover_point = np.random.randint(0, N_P)\n        child[:crossover_point] = parent1[:crossover_point]\n        child[crossover_point:] = parent2[crossover_point:]\n        return child\n\n    def mutate(individual):\n        mutation_index = np.random.randint(0, N_P)\n        individual[mutation_index] = 1 - individual[mutation_index]\n        return individual\n\n    def repair(individual):\n        while np.dot(individual, W) > C:\n            idxs = np.where(individual == 1)[0]\n            if idxs.size == 0:\n                break\n            individual[np.random.choice(idxs)] = 0\n        return individual\n\n    def select_parents(ranked_pop):\n        probabilities = 1 / (1 + np.arange(POP_SIZE))\n        probabilities /= probabilities.sum()\n        parents_idx = np.random.choice(np.arange(POP_SIZE), size=2, p=probabilities, replace=False)\n        return ranked_pop[parents_idx[0]], ranked_pop[parents_idx[1]]\n\n    def generate_new_individual():\n        parent1, parent2 = select_parents(pops['individuals'])\n        child = crossover(parent1, parent2)\n        child = mutate(child)\n        child = repair(child)\n        return child\n\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        new_pops[i] = generate_new_individual()\n    \n    return new_pops",
          "objective": 0.98507,
          "other_inf": null
     },
     {
          "algorithm": "Create a new population by selecting the best individuals, performing uniform crossover, applying a flip-bit mutation, and ensuring feasibility through a greedy repair mechanism.",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n\n    # Backbone idea: Use a combination of selection, crossover, mutation, and repair to generate a new population.\n    # New algorithm in one sentence: {Create a new population by selecting the best individuals, performing uniform crossover, applying a flip-bit mutation, and ensuring feasibility through a greedy repair mechanism.}\n\n    # Select the top individuals based on rankings\n    def select_top_individuals(population, rankings, num_to_select):\n        sorted_indices = np.argsort(rankings)\n        return population[sorted_indices][:num_to_select]\n\n    # Uniform crossover\n    def uniform_crossover(parent1, parent2):\n        mask = np.random.randint(0, 2, size=N_P)\n        child = np.where(mask, parent1, parent2)\n        return child\n\n    # Flip-bit mutation\n    def flip_bit_mutation(individual, mutation_rate=0.1):\n        mutation_mask = np.random.rand(N_P) < mutation_rate\n        individual[mutation_mask] = 1 - individual[mutation_mask]\n        return individual\n\n    # Greedy repair mechanism\n    def greedy_repair(individual, W, C):\n        weight = np.dot(individual, W)\n        while weight > C:\n            # Find the items that can be removed\n            items_to_remove = np.where(individual == 1)[0]\n            # Sort items by weight to remove heavier ones first\n            items_sorted_by_weight = items_to_remove[np.argsort(W[items_to_remove])[::-1]]\n            for item in items_sorted_by_weight:\n                individual[item] = 0\n                weight -= W[item]\n                if weight <= C:\n                    break\n        return individual\n\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n\n    # Select the top 50% of the individuals to ensure quality\n    selected_individuals = select_top_individuals(individuals, rankings, POP_SIZE // 2)\n\n    new_population = []\n    while len(new_population) < POP_SIZE:\n        # Randomly choose two parents from the selected top individuals\n        parent_indices = np.random.choice(len(selected_individuals), 2, replace=False)\n        parent1, parent2 = selected_individuals[parent_indices]\n        child = uniform_crossover(parent1, parent2)\n        child = flip_bit_mutation(child)\n        child = greedy_repair(child, W, C)\n        new_population.append(child)\n\n    new_pops = np.array(new_population, dtype=np.int32)\n    return new_pops",
          "objective": 0.98504,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n\n    def rank_based_selection(rankings):\n        # Selects individuals based on rank, with better ranks having higher probability\n        probabilities = 1 / (rankings + 1)  # Add 1 to avoid division by zero\n        probabilities /= probabilities.sum()  # Normalize to create a probability distribution\n        selected_index = np.random.choice(range(len(rankings)), p=probabilities)\n        return selected_index\n\n    def uniform_crossover(parent1, parent2):\n        # Uniform crossover where each gene is chosen randomly from one of the parents\n        mask = np.random.rand(N_P) < 0.5\n        child = np.where(mask, parent1, parent2)\n        return child\n\n    def mutate(individual, mutation_rate=0.1):\n        # Mutation with a given mutation rate\n        mutation_mask = np.random.rand(N_P) < mutation_rate\n        individual[mutation_mask] = 1 - individual[mutation_mask]\n        return individual\n\n    def greedy_repair(individual):\n        # Repairs the individual by removing items based on lowest value-to-weight ratio until within weight limit\n        while np.dot(individual, W) > C:\n            value_to_weight = np.where(individual == 1, V[:, 0] / W, np.inf)  # Use the first profit as example\n            to_remove = np.argmin(value_to_weight)  # Find the item with the lowest value-to-weight ratio\n            individual[to_remove] = 0\n        return individual\n\n    def create_new_individual():\n        # Creates a new individual using rank-based selection, uniform crossover, and mutation\n        parent1_index = rank_based_selection(pops['rankings'])\n        parent2_index = rank_based_selection(pops['rankings'])\n        parent1 = pops['individuals'][parent1_index]\n        parent2 = pops['individuals'][parent2_index]\n        child = uniform_crossover(parent1, parent2)\n        child = mutate(child)\n        child = greedy_repair(child)\n        return child\n\n    # Main reproduction loop\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        new_pops[i] = create_new_individual()\n\n    return new_pops",
          "objective": 0.98468,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n\n    def crossover(parent1, parent2):\n        crossover_point = np.random.randint(1, N_P)\n        child = np.hstack((parent1[:crossover_point], parent2[crossover_point:]))\n        return child\n\n    def mutate(individual):\n        mutation_point = np.random.randint(N_P)\n        individual[mutation_point] = 1 - individual[mutation_point]\n        return individual\n\n    def repair(individual):\n        while np.dot(individual, W) > C:\n            nonzero_indices = np.nonzero(individual)[0]\n            if nonzero_indices.size == 0:\n                break\n            individual[np.random.choice(nonzero_indices)] = 0\n        return individual\n\n    def select_parents(ranked_individuals):\n        total = len(ranked_individuals)\n        probs = np.log(total + 1) - np.log(np.arange(1, total + 1))\n        probs /= probs.sum()\n        selected_indices = np.random.choice(total, size=2, replace=False, p=probs)\n        return ranked_individuals[selected_indices[0]], ranked_individuals[selected_indices[1]]\n\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    sorted_individuals = pops['individuals'][np.argsort(pops['rankings'])]\n\n    for i in range(POP_SIZE):\n        parent1, parent2 = select_parents(sorted_individuals)\n        child = crossover(parent1, parent2)\n        if np.random.rand() < 0.1:  # Assuming a mutation probability of 10%\n            child = mutate(child)\n        child = repair(child)\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.98216,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n\n    def score_function(individual):\n        # Calculate the score based on the sum of values of the items included in the knapsack\n        return np.sum(V[individual == 1], axis=0)\n\n    def tournament_selection(rankings, tournament_size=3):\n        # Selects individuals for crossover using tournament selection with a larger pool\n        selected_indices = np.random.choice(range(len(rankings)), size=tournament_size, replace=False)\n        selected_rankings = rankings[selected_indices]\n        winner_index = selected_indices[np.argmin(selected_rankings)]\n        return winner_index\n\n    def uniform_crossover(parent1, parent2):\n        # Uniform crossover to mix genes from both parents\n        mask = np.random.randint(2, size=N_P)\n        child = (mask * parent1) + ((1 - mask) * parent2)\n        return child\n\n    def mutate(individual, mutation_rate=0.05):\n        # Mutation with a reduced mutation rate\n        for i in range(N_P):\n            if np.random.rand() < mutation_rate:\n                individual[i] = 1 - individual[i]\n        return individual\n\n    def repair(individual):\n        # Repairs the individual if the weight constraint is violated\n        while np.dot(individual, W) > C:\n            overweight_indices = np.where((individual == 1) & (W > 0))[0]\n            if len(overweight_indices) == 0:\n                break\n            individual[np.random.choice(overweight_indices)] = 0\n        return individual\n\n    def create_new_individual():\n        # Creates a new individual using tournament selection, uniform crossover, mutation, and repair\n        parent1_index = tournament_selection(pops['rankings'])\n        parent2_index = tournament_selection(pops['rankings'])\n        parent1 = pops['individuals'][parent1_index]\n        parent2 = pops['individuals'][parent2_index]\n        child = uniform_crossover(parent1, parent2)\n        child = mutate(child)\n        child = repair(child)\n        return child\n\n    # Main reproduction loop\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        new_pops[i] = create_new_individual()\n\n    return new_pops",
          "objective": 0.97669,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n\n    # (My novel algorithm uses rank-based selection, single-point ordered crossover, and bit-flip mutation with adaptive mutation rate, followed by a greedy repair function to ensure weight constraint compliance.)\n\n    # Adaptive mutation rate based on generation number\n    def adaptive_mutation_rate(generation, max_generation=1000):\n        return 0.1 * (1 - generation / max_generation)\n\n    # Rank-based selection\n    def rank_based_selection(rankings):\n        probabilities = 1 / (rankings + 1)\n        probabilities /= probabilities.sum()\n        selected_index = np.random.choice(len(rankings), p=probabilities)\n        return selected_index\n\n    # Single-point ordered crossover\n    def single_point_ordered_crossover(parent1, parent2):\n        point = np.random.randint(1, N_P)\n        child = np.zeros(N_P, dtype=np.int32)\n        child[:point] = parent1[:point]\n        for gene in parent2[point:]:\n            if gene not in child[:point]:\n                child[child == 0] = gene\n        return child\n\n    # Bit-flip mutation\n    def bit_flip_mutation(individual, mutation_rate):\n        for i in range(N_P):\n            if np.random.rand() < mutation_rate:\n                individual[i] = 1 - individual[i]\n        return individual\n\n    # Greedy repair function\n    def greedy_repair(individual):\n        weight = np.dot(individual, W)\n        while weight > C:\n            item_weights = individual * W\n            max_weight_index = np.argmax(item_weights)\n            individual[max_weight_index] = 0\n            weight = np.dot(individual, W)\n        return individual\n\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    current_generation = 0\n    mutation_rate = adaptive_mutation_rate(current_generation)\n\n    for i in range(POP_SIZE):\n        parent1_idx = rank_based_selection(pops['rankings'])\n        parent2_idx = rank_based_selection(pops['rankings'])\n        parent1 = pops['individuals'][parent1_idx]\n        parent2 = pops['individuals'][parent2_idx]\n\n        child = single_point_ordered_crossover(parent1, parent2)\n        child = bit_flip_mutation(child, mutation_rate)\n        child = greedy_repair(child)\n\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.97193,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n\n    def tournament_selection(rankings, tournament_size):\n        \"\"\"Selects an individual based on tournament selection.\"\"\"\n        selected_indices = np.random.choice(range(len(rankings)), tournament_size, replace=False)\n        selected_rankings = rankings[selected_indices]\n        winner_index = selected_indices[np.argmin(selected_rankings)]\n        return winner_index\n\n    def crossover(parent1, parent2):\n        \"\"\"Performs uniform crossover to generate an offspring.\"\"\"\n        crossover_mask = np.random.randint(0, 2, size=N_P)\n        offspring = np.where(crossover_mask == 1, parent1, parent2)\n        return offspring\n\n    def mutation(individual, mutation_rate):\n        \"\"\"Performs mutation on an individual.\"\"\"\n        mutation_mask = np.random.rand(N_P) < mutation_rate\n        individual[mutation_mask] = 1 - individual[mutation_mask]\n        return individual\n\n    def repair(individual, W, C):\n        \"\"\"Repairs an individual to satisfy the weight constraint.\"\"\"\n        while np.dot(individual, W) > C:\n            non_zero_indices = np.nonzero(individual)[0]\n            drop_index = np.random.choice(non_zero_indices)\n            individual[drop_index] = 0\n        return individual\n\n    def create_offspring(pops, W, C, mutation_rate=0.1, tournament_size=2):\n        \"\"\"Creates offspring using tournament selection, crossover, and mutation.\"\"\"\n        parent1_index = tournament_selection(pops['rankings'], tournament_size)\n        parent2_index = tournament_selection(pops['rankings'], tournament_size)\n        parent1 = pops['individuals'][parent1_index]\n        parent2 = pops['individuals'][parent2_index]\n        offspring = crossover(parent1, parent2)\n        offspring = mutation(offspring, mutation_rate)\n        offspring = repair(offspring, W, C)\n        return offspring\n    \n    # Main algorithm to generate the next population\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        new_pops[i] = create_offspring(pops, W, C)\n    \n    return new_pops",
          "objective": 0.90989,
          "other_inf": null
     }
]