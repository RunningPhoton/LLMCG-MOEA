[
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n\n    def crossover(parent1, parent2):\n        \"\"\"Perform crossover between two parents to produce an offspring.\"\"\"\n        crossover_point = np.random.randint(1, N_P)\n        offspring = np.hstack((parent1[:crossover_point], parent2[crossover_point:]))\n        return offspring\n\n    def mutate(individual):\n        \"\"\"Perform mutation on an individual.\"\"\"\n        mutation_point = np.random.randint(N_P)\n        individual[mutation_point] = 1 - individual[mutation_point]\n        return individual\n\n    def repair(individual):\n        \"\"\"Repair an individual if it violates the weight constraint.\"\"\"\n        while np.dot(individual, W) > C:\n            overweight_items = np.where((individual == 1) & (W > 0))[0]\n            if overweight_items.size == 0:\n                break\n            item_to_remove = np.random.choice(overweight_items)\n            individual[item_to_remove] = 0\n        return individual\n\n    def select_parents(rankings):\n        \"\"\"Select parents based on their rankings using a tournament selection.\"\"\"\n        tournament_size = 2\n        selected_indices = np.random.choice(POP_SIZE, tournament_size, replace=False)\n        selected_rankings = rankings[selected_indices]\n        winner_index = selected_indices[np.argmin(selected_rankings)]\n        return pops['individuals'][winner_index]\n\n    # Main steps of the reproduction function\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        parent1 = select_parents(pops['rankings'])\n        parent2 = select_parents(pops['rankings'])\n        offspring = crossover(parent1, parent2)\n        offspring = mutate(offspring)\n        offspring = repair(offspring)\n        new_pops[i] = offspring\n\n    return new_pops",
          "objective": 0.98573,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n    \n    def crossover(parent1, parent2):\n        child = np.zeros(N_P, dtype=np.int32)\n        crossover_point = np.random.randint(0, N_P)\n        child[:crossover_point] = parent1[:crossover_point]\n        child[crossover_point:] = parent2[crossover_point:]\n        return child\n\n    def mutate(individual):\n        mutation_index = np.random.randint(0, N_P)\n        individual[mutation_index] = 1 - individual[mutation_index]\n        return individual\n\n    def repair(individual):\n        while np.dot(individual, W) > C:\n            idxs = np.where(individual == 1)[0]\n            if idxs.size == 0:\n                break\n            individual[np.random.choice(idxs)] = 0\n        return individual\n\n    def select_parents(ranked_pop):\n        probabilities = 1 / (1 + np.arange(POP_SIZE))\n        probabilities /= probabilities.sum()\n        parents_idx = np.random.choice(np.arange(POP_SIZE), size=2, p=probabilities, replace=False)\n        return ranked_pop[parents_idx[0]], ranked_pop[parents_idx[1]]\n\n    def generate_new_individual():\n        parent1, parent2 = select_parents(pops['individuals'])\n        child = crossover(parent1, parent2)\n        child = mutate(child)\n        child = repair(child)\n        return child\n\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        new_pops[i] = generate_new_individual()\n    \n    return new_pops",
          "objective": 0.98507,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n\n    def crossover(parent1, parent2):\n        crossover_point = np.random.randint(1, N_P)\n        child = np.hstack((parent1[:crossover_point], parent2[crossover_point:]))\n        return child\n\n    def mutate(individual):\n        mutation_point = np.random.randint(N_P)\n        individual[mutation_point] = 1 - individual[mutation_point]\n        return individual\n\n    def repair(individual):\n        while np.dot(individual, W) > C:\n            nonzero_indices = np.nonzero(individual)[0]\n            if nonzero_indices.size == 0:\n                break\n            individual[np.random.choice(nonzero_indices)] = 0\n        return individual\n\n    def select_parents(ranked_individuals):\n        total = len(ranked_individuals)\n        probs = np.log(total + 1) - np.log(np.arange(1, total + 1))\n        probs /= probs.sum()\n        selected_indices = np.random.choice(total, size=2, replace=False, p=probs)\n        return ranked_individuals[selected_indices[0]], ranked_individuals[selected_indices[1]]\n\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    sorted_individuals = pops['individuals'][np.argsort(pops['rankings'])]\n\n    for i in range(POP_SIZE):\n        parent1, parent2 = select_parents(sorted_individuals)\n        child = crossover(parent1, parent2)\n        if np.random.rand() < 0.1:  # Assuming a mutation probability of 10%\n            child = mutate(child)\n        child = repair(child)\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.98216,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n\n    def tournament_selection(rankings, tournament_size):\n        \"\"\"Selects an individual based on tournament selection.\"\"\"\n        selected_indices = np.random.choice(range(len(rankings)), tournament_size, replace=False)\n        selected_rankings = rankings[selected_indices]\n        winner_index = selected_indices[np.argmin(selected_rankings)]\n        return winner_index\n\n    def crossover(parent1, parent2):\n        \"\"\"Performs uniform crossover to generate an offspring.\"\"\"\n        crossover_mask = np.random.randint(0, 2, size=N_P)\n        offspring = np.where(crossover_mask == 1, parent1, parent2)\n        return offspring\n\n    def mutation(individual, mutation_rate):\n        \"\"\"Performs mutation on an individual.\"\"\"\n        mutation_mask = np.random.rand(N_P) < mutation_rate\n        individual[mutation_mask] = 1 - individual[mutation_mask]\n        return individual\n\n    def repair(individual, W, C):\n        \"\"\"Repairs an individual to satisfy the weight constraint.\"\"\"\n        while np.dot(individual, W) > C:\n            non_zero_indices = np.nonzero(individual)[0]\n            drop_index = np.random.choice(non_zero_indices)\n            individual[drop_index] = 0\n        return individual\n\n    def create_offspring(pops, W, C, mutation_rate=0.1, tournament_size=2):\n        \"\"\"Creates offspring using tournament selection, crossover, and mutation.\"\"\"\n        parent1_index = tournament_selection(pops['rankings'], tournament_size)\n        parent2_index = tournament_selection(pops['rankings'], tournament_size)\n        parent1 = pops['individuals'][parent1_index]\n        parent2 = pops['individuals'][parent2_index]\n        offspring = crossover(parent1, parent2)\n        offspring = mutation(offspring, mutation_rate)\n        offspring = repair(offspring, W, C)\n        return offspring\n    \n    # Main algorithm to generate the next population\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        new_pops[i] = create_offspring(pops, W, C)\n    \n    return new_pops",
          "objective": 0.90989,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n\n    def tournament_selection(rankings, tournament_size=2):\n        \"\"\"Selects parents using tournament selection.\"\"\"\n        selected_indices = np.random.choice(range(len(rankings)), tournament_size, replace=False)\n        selected_rankings = rankings[selected_indices]\n        return selected_indices[np.argmin(selected_rankings)]\n\n    def crossover(parent1, parent2):\n        \"\"\"Performs uniform crossover on two parents.\"\"\"\n        child = np.where(np.random.rand(N_P) < 0.5, parent1, parent2)\n        return child\n\n    def mutation(individual, mutation_rate=0.1):\n        \"\"\"Mutates an individual by flipping bits with a given mutation rate.\"\"\"\n        mutation_indices = np.random.rand(N_P) < mutation_rate\n        individual[mutation_indices] = 1 - individual[mutation_indices]\n        return individual\n\n    def repair(individual):\n        \"\"\"Repairs an individual to satisfy the weight constraint.\"\"\"\n        while np.dot(individual, W) > C:\n            # Randomly remove items until the weight constraint is met\n            overweight_indices = np.where(individual == 1)[0]\n            individual[np.random.choice(overweight_indices)] = 0\n        return individual\n\n    # Main reproduction function\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        # Selection\n        parent1_idx = tournament_selection(pops['rankings'])\n        parent2_idx = tournament_selection(pops['rankings'])\n        parent1 = pops['individuals'][parent1_idx]\n        parent2 = pops['individuals'][parent2_idx]\n\n        # Crossover\n        child = crossover(parent1, parent2)\n\n        # Mutation\n        child = mutation(child)\n\n        # Repair\n        child = repair(child)\n\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.90822,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n    \n    def tournament_selection(rankings, tournament_size=2):\n        selected_indices = np.random.choice(range(len(rankings)), tournament_size, replace=False)\n        selected_rankings = rankings[selected_indices]\n        winner_index = selected_indices[np.argmin(selected_rankings)]\n        return winner_index\n    \n    def crossover(parent1, parent2):\n        crossover_point = np.random.randint(1, N_P)\n        child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        return child\n    \n    def mutation(individual, mutation_rate=0.1):\n        for i in range(len(individual)):\n            if np.random.rand() < mutation_rate:\n                individual[i] = 1 - individual[i]\n        return individual\n    \n    def repair(individual, W, C):\n        while np.dot(individual, W) > C:\n            overweight_items = np.where((individual == 1) & (W > 0))[0]\n            if overweight_items.size == 0:\n                break\n            item_to_remove = np.random.choice(overweight_items)\n            individual[item_to_remove] = 0\n        return individual\n    \n    def create_new_individual(parents, W, C):\n        parent1, parent2 = parents[np.random.choice(range(len(parents)), 2, replace=False)]\n        child = crossover(parent1, parent2)\n        child = mutation(child)\n        child = repair(child, W, C)\n        return child\n    \n    individuals = pops['individuals']\n    rankings = pops['rankings']\n    \n    new_population = []\n    while len(new_population) < POP_SIZE:\n        parent_indices = [tournament_selection(rankings) for _ in range(2)]\n        parents = individuals[parent_indices]\n        new_individual = create_new_individual(parents, W, C)\n        new_population.append(new_individual)\n    \n    new_pops = np.array(new_population, dtype=np.int32)\n    return new_pops",
          "objective": 0.90054,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n\n    def tournament_selection(rankings, tournament_size=2):\n        # Selects individuals for crossover using tournament selection\n        selected_indices = np.random.choice(range(len(rankings)), size=tournament_size, replace=False)\n        selected_rankings = rankings[selected_indices]\n        winner_index = selected_indices[np.argmin(selected_rankings)]\n        return winner_index\n\n    def crossover(parent1, parent2):\n        # Single-point crossover\n        point = np.random.randint(1, N_P)\n        child = np.concatenate((parent1[:point], parent2[point:]))\n        return child\n\n    def mutate(individual, mutation_rate=0.1):\n        # Mutation with a given mutation rate\n        for i in range(N_P):\n            if np.random.rand() < mutation_rate:\n                individual[i] = 1 - individual[i]\n        return individual\n\n    def repair(individual):\n        # Repairs the individual if the weight constraint is violated\n        while np.dot(individual, W) > C:\n            nonzero_indices = np.nonzero(individual)[0]\n            if len(nonzero_indices) == 0:  # If no items can be removed, break\n                break\n            individual[np.random.choice(nonzero_indices)] = 0\n        return individual\n\n    def create_new_individual():\n        # Creates a new individual using tournament selection, crossover, and mutation\n        parent1_index = tournament_selection(pops['rankings'])\n        parent2_index = tournament_selection(pops['rankings'])\n        parent1 = pops['individuals'][parent1_index]\n        parent2 = pops['individuals'][parent2_index]\n        child = crossover(parent1, parent2)\n        child = mutate(child)\n        child = repair(child)\n        return child\n\n    # Main reproduction loop\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        new_pops[i] = create_new_individual()\n\n    return new_pops",
          "objective": 0.90029,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n\n    def tournament_selection(population, rankings, tournament_size=2):\n        selected_indices = np.random.choice(np.arange(len(population)), size=tournament_size, replace=False)\n        selected_individuals = rankings[selected_indices]\n        winner_index = selected_indices[np.argmin(selected_individuals)]\n        return population[winner_index]\n\n    def crossover(parent1, parent2):\n        crossover_point = np.random.randint(1, N_P)\n        child = np.concatenate([parent1[:crossover_point], parent2[crossover_point:]])\n        return child\n\n    def mutation(individual, mutation_rate=0.1):\n        for i in range(N_P):\n            if np.random.rand() < mutation_rate:\n                individual[i] = 1 - individual[i]\n        return individual\n\n    def repair(individual):\n        while np.dot(individual, W) > C:\n            nonzero_indices = np.nonzero(individual)[0]\n            if nonzero_indices.size == 0:\n                break\n            individual[np.random.choice(nonzero_indices)] = 0\n        return individual\n\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n    new_population = []\n\n    while len(new_population) < POP_SIZE:\n        parent1 = tournament_selection(individuals, rankings)\n        parent2 = tournament_selection(individuals, rankings)\n        child = crossover(parent1, parent2)\n        child = mutation(child)\n        child = repair(child)\n        new_population.append(child)\n\n    new_pops = np.array(new_population, dtype=np.int32)\n    return new_pops",
          "objective": 0.899,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n    \n    def crossover(parent1, parent2):\n        # Single point crossover\n        point = np.random.randint(1, N_P)\n        child = np.concatenate((parent1[:point], parent2[point:]))\n        return child\n    \n    def mutate(individual):\n        # Randomly flip a bit with a low probability\n        for i in range(N_P):\n            if np.random.rand() < 0.1:\n                individual[i] = 1 - individual[i]\n        return individual\n    \n    def repair(individual):\n        # Repair the individual if the weight exceeds the capacity\n        while np.dot(individual, W) > C:\n            # Randomly remove items until the weight is under capacity\n            overweight_items = np.where((individual == 1) & (W > 0))[0]\n            if overweight_items.size > 0:\n                individual[np.random.choice(overweight_items)] = 0\n            else:\n                break\n        return individual\n    \n    def select_parents(rankings):\n        # Tournament selection based on rankings\n        tournament_size = 2\n        selected_indices = np.random.choice(POP_SIZE, tournament_size, replace=False)\n        best_index = selected_indices[np.argmin(rankings[selected_indices])]\n        return pops['individuals'][best_index]\n    \n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    \n    for i in range(POP_SIZE):\n        # Select parents based on rankings\n        parent1 = select_parents(pops['rankings'])\n        parent2 = select_parents(pops['rankings'])\n        \n        # Generate a new individual through crossover and mutation\n        child = crossover(parent1, parent2)\n        child = mutate(child)\n        \n        # Repair the individual if it violates the weight constraint\n        child = repair(child)\n        \n        # Add the new individual to the new population\n        new_pops[i, :] = child\n    \n    return new_pops",
          "objective": 0.89546,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n    \n    def tournament_selection(rankings, tournament_size=2):\n        selected_indices = np.random.choice(range(len(rankings)), size=tournament_size, replace=False)\n        selected_rankings = rankings[selected_indices]\n        winner_index = selected_indices[np.argmin(selected_rankings)]\n        return winner_index\n\n    def crossover(parent1, parent2):\n        crossover_point = np.random.randint(1, N_P)\n        child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        return child\n\n    def mutation(individual, mutation_rate=0.1):\n        for i in range(N_P):\n            if np.random.rand() < mutation_rate:\n                individual[i] = 1 - individual[i]\n        return individual\n\n    def repair(individual, W, C):\n        while np.dot(individual, W) > C:\n            nonzero_indices = np.nonzero(individual)[0]\n            if len(nonzero_indices) == 0: break\n            individual[np.random.choice(nonzero_indices)] = 0\n        return individual\n\n    def create_new_individual(parents_pool, rankings, W, C):\n        parent1_index = tournament_selection(rankings)\n        parent2_index = tournament_selection(rankings)\n        child = crossover(parents_pool[parent1_index], parents_pool[parent2_index])\n        child = mutation(child)\n        child = repair(child, W, C)\n        return child\n\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        new_pops[i] = create_new_individual(pops['individuals'], pops['rankings'], W, C)\n    \n    return new_pops",
          "objective": 0.89461,
          "other_inf": null
     }
]