[
     {
          "algorithm": "Create a new population using deterministic tournament selection, single-point crossover, and a heuristic-based mutation that favors items with higher value-to-weight ratios.",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    # {Create a new population using deterministic tournament selection, single-point crossover, and a heuristic-based mutation that favors items with higher value-to-weight ratios.}\n\n    # Initialize the new population\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    \n    for i in range(POP_SIZE):\n        # Deterministic tournament selection\n        competitors = np.random.choice(POP_SIZE, 2, replace=False)\n        if pops['rankings'][competitors[0]] < pops['rankings'][competitors[1]]:\n            winner = pops['individuals'][competitors[0]]\n        else:\n            winner = pops['individuals'][competitors[1]]\n\n        # Single-point crossover\n        point = np.random.randint(1, N_P)\n        if i > 0:  # Ensure we have at least one parent from the previous generation\n            parent = new_pops[np.random.randint(i)]\n            child = np.concatenate((winner[:point], parent[point:]))\n        else:\n            child = winner.copy()  # The first individual is a copy of the winner\n\n        # Heuristic-based mutation\n        value_weight_ratio = V.sum(axis=1) / W\n        sorted_indices = np.argsort(value_weight_ratio)[::-1]\n        for j in sorted_indices:\n            if child[j] == 0 and np.dot(child, W) + W[j] <= C:\n                child[j] = 1  # Add item if it improves the value without exceeding weight\n            elif child[j] == 1 and np.random.rand() < 0.05:\n                child[j] = 0  # Randomly remove item with a small probability\n\n        # Ensure the child meets the weight constraint\n        while np.dot(child, W) > C:\n            overweight_indices = np.where(child == 1)[0]\n            child[np.random.choice(overweight_indices)] = 0\n\n        # Add the child to the new population\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.98732,
          "other_inf": null
     },
     {
          "algorithm": "Implement tournament selection, uniform crossover, and greedy mutation based on a sorted value-weight ratio, followed by a repair strategy that drops items based on the reverse value-weight ratio until the weight constraint is met.",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n\n    # New algorithm in one sentence: {Implement tournament selection, uniform crossover, and greedy mutation based on a sorted value-weight ratio, followed by a repair strategy that drops items based on the reverse value-weight ratio until the weight constraint is met.}\n    \n    def tournament_selection(fitness_scores, tournament_size=3):\n        # Select random individuals for the tournament\n        competitors_idx = np.random.choice(len(fitness_scores), tournament_size, replace=False)\n        competitors_fitness = fitness_scores[competitors_idx]\n        # Choose the best individual from the tournament\n        winner_idx = competitors_idx[np.argmax(competitors_fitness)]\n        return winner_idx\n\n    def uniform_crossover(parent1, parent2):\n        # Create a mask for crossover\n        mask = np.random.randint(0, 2, size=N_P)\n        # Generate offspring\n        offspring = np.where(mask == 1, parent1, parent2)\n        return offspring\n\n    def greedy_mutation(individual, mutation_rate=0.1):\n        # Sort items by value-weight ratio\n        value_weight_ratios = V.sum(axis=1) / W\n        sorted_indices = np.argsort(value_weight_ratios)[::-1]\n        # Apply mutation based on mutation rate\n        for idx in sorted_indices:\n            if np.random.rand() < mutation_rate:\n                individual[idx] = 1 - individual[idx]\n                # If the knapsack becomes too heavy, revert the mutation\n                if np.dot(individual, W) > C:\n                    individual[idx] = 1 - individual[idx]\n                    break\n        return individual\n\n    def repair(individual):\n        # Sort items by reverse value-weight ratio\n        value_weight_ratios = V.sum(axis=1) / W\n        sorted_indices = np.argsort(value_weight_ratios)\n        # Remove items until the weight constraint is met\n        for idx in sorted_indices:\n            if np.dot(individual, W) > C:\n                individual[idx] = 0\n            else:\n                break\n        return individual\n\n    # Calculate fitness scores as inverse of rankings for selection\n    fitness_scores = 1 / (pops['rankings'] + 1)\n    \n    # Initialize new population\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    \n    # Generate new population\n    for i in range(POP_SIZE):\n        # Select parents using tournament selection\n        parent1_index = tournament_selection(fitness_scores)\n        parent2_index = tournament_selection(fitness_scores)\n        parent1 = pops['individuals'][parent1_index]\n        parent2 = pops['individuals'][parent2_index]\n        \n        # Create offspring using uniform crossover\n        offspring = uniform_crossover(parent1, parent2)\n        \n        # Mutate offspring using greedy mutation\n        offspring = greedy_mutation(offspring)\n        \n        # Repair offspring if necessary\n        offspring = repair(offspring)\n        \n        # Add offspring to new population\n        new_pops[i] = offspring\n    \n    return new_pops",
          "objective": 0.98728,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n\n    # Rank-based selection with probability inversely proportional to ranking\n    def rank_based_selection(rankings):\n        selection_probs = 1 / (rankings + 1)\n        selection_probs /= selection_probs.sum()\n        return np.random.choice(len(rankings), p=selection_probs)\n\n    # Uniform crossover that randomly takes genes from both parents\n    def uniform_crossover(parent1, parent2):\n        mask = np.random.rand(N_P) < 0.5\n        child = np.where(mask, parent1, parent2)\n        return child\n\n    # Mutation with a fixed mutation rate that flips bits in the individual\n    def fixed_mutation(individual, mutation_rate=0.05):\n        mutation_mask = np.random.rand(N_P) < mutation_rate\n        individual ^= mutation_mask.astype(np.int32)\n        return individual\n\n    # Greedy repair mechanism that removes the least efficient items until the weight constraint is met\n    def greedy_repair(individual, W, C, V):\n        weight = np.dot(individual, W)\n        while weight > C:\n            efficiency = V.sum(axis=1) / W\n            items = np.where(individual == 1)[0]\n            efficiency_of_items = efficiency[items]\n            remove_idx = items[np.argmin(efficiency_of_items)]\n            individual[remove_idx] = 0\n            weight -= W[remove_idx]\n        return individual\n\n    # Create offspring using rank-based selection, uniform crossover, fixed mutation, and greedy repair\n    def create_offspring(pops, rankings, W, C, V):\n        parent1_index = rank_based_selection(rankings)\n        parent2_index = rank_based_selection(rankings)\n        parent1, parent2 = pops['individuals'][parent1_index], pops['individuals'][parent2_index]\n        child = uniform_crossover(parent1, parent2)\n        child = fixed_mutation(child)\n        child = greedy_repair(child, W, C, V)\n        return child\n\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        new_pops[i] = create_offspring(pops, pops['rankings'], W, C, V)\n\n    return new_pops",
          "objective": 0.9871,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n    \n    # Sub-function for rank-based selection\n    def rank_based_selection(ranked_pop):\n        # Calculate selection probabilities inversely proportional to rankings\n        selection_probs = 1 / (1 + ranked_pop['rankings'])\n        selection_probs /= selection_probs.sum()\n        selected_index = np.random.choice(POP_SIZE, p=selection_probs)\n        return ranked_pop['individuals'][selected_index]\n\n    # Sub-function for single point crossover\n    def single_point_crossover(parent1, parent2):\n        crossover_point = np.random.randint(1, N_P)\n        child = np.concatenate([parent1[:crossover_point], parent2[crossover_point:]])\n        return child\n\n    # Sub-function for mutation with a decreasing mutation rate\n    def decreasing_mutation(individual, generation, max_generations=100):\n        mutation_rate = 0.1 * (1 - generation / max_generations)\n        mutation_mask = np.random.rand(N_P) < mutation_rate\n        individual[mutation_mask] = 1 - individual[mutation_mask]\n        return individual\n\n    # Sub-function for greedy repair to fix weight constraint violations\n    def greedy_repair(individual):\n        while np.dot(individual, W) > C:\n            nonzero_indices = np.where(individual == 1)[0]\n            if nonzero_indices.size == 0:\n                break\n            efficiencies = np.sum(V[nonzero_indices], axis=1) / W[nonzero_indices]\n            least_efficient_item = nonzero_indices[np.argmin(efficiencies)]\n            individual[least_efficient_item] = 0\n        return individual\n\n    # Sub-function to generate a new individual\n    def generate_new_individual(generation):\n        parent1 = rank_based_selection(pops)\n        parent2 = rank_based_selection(pops)\n        child = single_point_crossover(parent1, parent2)\n        child = decreasing_mutation(child, generation)\n        child = greedy_repair(child)\n        return child\n\n    # Main loop to generate new population\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        new_pops[i] = generate_new_individual(i)  # Pass current generation index as parameter\n\n    return new_pops",
          "objective": 0.98705,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n    \n    def tournament_selection(population, rankings, tournament_size=3):\n        \"\"\"Select one parent using tournament selection.\"\"\"\n        selected_indices = np.random.choice(POP_SIZE, tournament_size, replace=False)\n        selected_rankings = rankings[selected_indices]\n        winner_index = selected_indices[np.argmin(selected_rankings)]\n        return population[winner_index]\n\n    def two_point_crossover(parent1, parent2):\n        \"\"\"Perform two-point crossover between two parents.\"\"\"\n        crossover_points = np.sort(np.random.choice(range(1, N_P), 2, replace=False))\n        offspring = np.concatenate([parent1[:crossover_points[0]],\n                                    parent2[crossover_points[0]:crossover_points[1]],\n                                    parent1[crossover_points[1]:]])\n        return offspring\n\n    def bit_flip_mutation(individual, mutation_rate=0.05):\n        \"\"\"Perform bit flip mutation on an individual.\"\"\"\n        mutation_mask = np.random.rand(N_P) < mutation_rate\n        individual[mutation_mask] = 1 - individual[mutation_mask]\n        return individual\n\n    def greedy_repair(individual):\n        \"\"\"Repair an individual using a greedy algorithm based on profit-to-weight ratio.\"\"\"\n        while np.dot(individual, W) > C:\n            ratios = V / W.reshape(-1, 1)\n            total_ratios = np.sum(ratios, axis=1)\n            item_indices = np.where(individual == 1)[0]\n            if item_indices.size == 0:\n                break\n            least_efficient_item = item_indices[np.argmin(total_ratios[item_indices])]\n            individual[least_efficient_item] = 0\n        return individual\n\n    # Main steps of the reproduction function\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        parent1 = tournament_selection(pops['individuals'], pops['rankings'])\n        parent2 = tournament_selection(pops['individuals'], pops['rankings'])\n        offspring = two_point_crossover(parent1, parent2)\n        offspring = bit_flip_mutation(offspring)\n        offspring = greedy_repair(offspring)\n        new_pops[i] = offspring\n\n    return new_pops",
          "objective": 0.98702,
          "other_inf": null
     },
     {
          "algorithm": "Use roulette wheel selection, two-point crossover, and a value-weight ratio-based mutation and repair strategy.",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n\n    # The common backbone idea: Genetic operators (selection, crossover, mutation, repair) to create new population\n    # New algorithm in one sentence: {Use roulette wheel selection, two-point crossover, and a value-weight ratio-based mutation and repair strategy.}\n\n    def roulette_wheel_selection(fitness_scores):\n        # Normalize fitness scores to probabilities\n        probabilities = fitness_scores / fitness_scores.sum()\n        # Roulette wheel selection\n        selected_index = np.random.choice(len(fitness_scores), p=probabilities)\n        return selected_index\n\n    def two_point_crossover(parent1, parent2):\n        # Randomly select two points for crossover\n        points = np.sort(np.random.choice(range(1, N_P), 2, replace=False))\n        # Create offspring\n        offspring = np.concatenate([parent1[:points[0]], parent2[points[0]:points[1]], parent1[points[1]:]])\n        return offspring\n\n    def value_weight_ratio_mutation(individual):\n        # Calculate value-weight ratio for each item\n        value_weight_ratios = V.sum(axis=1) / W\n        # Flip the bit with the highest value-weight ratio\n        if np.max(value_weight_ratios) > 0:\n            max_ratio_index = np.argmax(value_weight_ratios)\n            individual[max_ratio_index] = 1 - individual[max_ratio_index]\n        return individual\n\n    def value_weight_ratio_repair(individual):\n        # Repair the individual if it violates the weight constraint\n        while np.dot(individual, W) > C:\n            value_weight_ratios = individual * V.sum(axis=1) / W\n            # Select the item with the lowest value-weight ratio to remove\n            min_ratio_index = np.argmin(value_weight_ratios + np.max(value_weight_ratios) * (1 - individual))\n            individual[min_ratio_index] = 0\n        return individual\n\n    # Calculate fitness scores as inverse of rankings for selection\n    fitness_scores = 1 / (pops['rankings'] + 1)\n    \n    # Initialize new population\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    \n    # Generate new population\n    for i in range(POP_SIZE):\n        # Select parents using roulette wheel selection\n        parent1_index = roulette_wheel_selection(fitness_scores)\n        parent2_index = roulette_wheel_selection(fitness_scores)\n        parent1 = pops['individuals'][parent1_index]\n        parent2 = pops['individuals'][parent2_index]\n        \n        # Create offspring using two-point crossover\n        offspring = two_point_crossover(parent1, parent2)\n        \n        # Mutate offspring using value-weight ratio mutation\n        offspring = value_weight_ratio_mutation(offspring)\n        \n        # Repair offspring if necessary\n        offspring = value_weight_ratio_repair(offspring)\n        \n        # Add offspring to new population\n        new_pops[i] = offspring\n    \n    return new_pops",
          "objective": 0.98695,
          "other_inf": null
     },
     {
          "algorithm": "Blending-based selection, multipoint crossover, uniform mutation, and value-density based repair.",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    # {Blending-based selection, multipoint crossover, uniform mutation, and value-density based repair.}\n    \n    # Blending-based selection\n    def blending_selection(rankings):\n        weights = 1 / (rankings + 1)\n        chosen_index = np.random.choice(np.arange(len(rankings)), p=weights/weights.sum())\n        return chosen_index\n    \n    # Multipoint crossover\n    def multipoint_crossover(parent1, parent2, num_points=3):\n        crossover_points = np.sort(np.random.choice(np.arange(1, N_P), num_points-1, replace=False))\n        child = np.zeros_like(parent1)\n        prev_point = 0\n        for i, point in enumerate(crossover_points):\n            if i % 2 == 0:\n                child[prev_point:point] = parent1[prev_point:point]\n            else:\n                child[prev_point:point] = parent2[prev_point:point]\n            prev_point = point\n        child[prev_point:] = parent1[prev_point:] if len(crossover_points) % 2 == 0 else parent2[prev_point:]\n        return child\n    \n    # Uniform mutation\n    def uniform_mutation(individual, mutation_rate=0.05):\n        for i in range(len(individual)):\n            if np.random.rand() < mutation_rate:\n                individual[i] = 1 - individual[i]\n        return individual\n    \n    # Value-density based repair\n    def value_density_repair(individual, W, C, V):\n        weight = np.dot(individual, W)\n        value_density = V.sum(axis=1) / W\n        while weight > C:\n            items = np.where(individual == 1)[0]\n            densities = value_density[items]\n            remove_idx = items[np.argmin(densities)]\n            individual[remove_idx] = 0\n            weight -= W[remove_idx]\n        return individual\n    \n    # Create offspring\n    def create_offspring(pops, rankings, W, C, V):\n        parent1_index = blending_selection(rankings)\n        parent2_index = blending_selection(rankings)\n        parent1, parent2 = pops['individuals'][parent1_index], pops['individuals'][parent2_index]\n        child = multipoint_crossover(parent1, parent2)\n        child = uniform_mutation(child)\n        child = value_density_repair(child, W, C, V)\n        return child\n    \n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        new_pops[i] = create_offspring(pops, pops['rankings'], W, C, V)\n    \n    return new_pops",
          "objective": 0.98692,
          "other_inf": null
     },
     {
          "algorithm": "Generate new population by elitism, bitwise crossover, random mutation, and a proportional repair based on item value/weight ratio.",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    # {Generate new population by elitism, bitwise crossover, random mutation, and a proportional repair based on item value/weight ratio.}\n\n    # Elitism: directly copy a fraction of the best individuals to the new population\n    def elitism(individuals, rankings, fraction=0.1):\n        num_elites = int(POP_SIZE * fraction)\n        elite_indices = np.argsort(rankings)[:num_elites]\n        return individuals[elite_indices]\n\n    # Bitwise crossover: cross over individual bits with a fixed probability\n    def bitwise_crossover(parent1, parent2, crossover_rate=0.5):\n        mask = np.random.rand(N_P) < crossover_rate\n        child = np.where(mask, parent1, parent2)\n        return child\n\n    # Random mutation: flip individual bits with a fixed probability\n    def random_mutation(individual, mutation_rate=0.05):\n        for i in range(N_P):\n            if np.random.rand() < mutation_rate:\n                individual[i] = 1 - individual[i]\n        return individual\n\n    # Proportional repair: remove items based on the lowest value/weight ratio until the weight constraint is met\n    def proportional_repair(individual, W, C, V):\n        weight = np.dot(individual, W)\n        value_weight_ratio = np.sum(V, axis=1) / W  # Sum of values divided by weight\n        while weight > C:\n            # Find items to consider for removal based on the individual and their value/weight ratio\n            items_to_consider = np.where(individual == 1)[0]\n            # Sort items by their value/weight ratio in ascending order\n            items_sorted_by_ratio = items_to_consider[np.argsort(value_weight_ratio[items_to_consider])]\n            # Remove the item with the lowest ratio\n            item_to_remove = items_sorted_by_ratio[0]\n            individual[item_to_remove] = 0\n            weight -= W[item_to_remove]\n        return individual\n\n    # Initialize the new population\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    \n    # Apply elitism to copy the best individuals to the new population\n    elites = elitism(pops['individuals'], pops['rankings'])\n    new_pops[:len(elites)] = elites\n\n    # Generate the rest of the new population\n    for i in range(len(elites), POP_SIZE):\n        # Randomly select two parents from the current population\n        parent_indices = np.random.choice(POP_SIZE, 2, replace=False)\n        parent1, parent2 = pops['individuals'][parent_indices]\n        \n        # Perform bitwise crossover and random mutation\n        child = bitwise_crossover(parent1, parent2)\n        child = random_mutation(child)\n        \n        # Repair the child to ensure it meets the weight constraint\n        child = proportional_repair(child, W, C, V)\n        \n        # Add the child to the new population\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.98687,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    # Tournament-based selection with a tournament size of 2\n    def tournament_selection(rankings, tournament_size=2):\n        selected_indices = []\n        for _ in range(tournament_size):\n            selected_indices.append(np.random.randint(len(rankings)))\n        selected_rankings = rankings[selected_indices]\n        return selected_indices[np.argmin(selected_rankings)]\n\n    # Single-point crossover\n    def single_point_crossover(parent1, parent2):\n        crossover_point = np.random.randint(1, len(parent1))\n        child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        return child\n\n    # Mutation with a dynamic mutation rate based on the individual's rank\n    def dynamic_mutation(individual, rankings, rank):\n        mutation_rate = 0.1 / (1 + np.log(rankings[rank] + 1))\n        mutation_mask = np.random.rand(N_P) < mutation_rate\n        individual ^= mutation_mask.astype(np.int32)\n        return individual\n\n    # Proportional value-to-weight repair mechanism\n    def proportional_repair(individual, W, C, V):\n        weight = np.dot(individual, W)\n        while weight > C:\n            items = np.where(individual == 1)[0]\n            item_weights = W[items]\n            item_values = V[items].sum(axis=1)\n            # Remove the item with the highest weight-to-value ratio\n            ratios = item_weights / item_values\n            remove_idx = items[np.argmax(ratios)]\n            individual[remove_idx] = 0\n            weight -= W[remove_idx]\n        return individual\n\n    # Create offspring using tournament selection, single-point crossover, dynamic mutation, and proportional repair\n    def create_offspring(pops, rankings, W, C, V):\n        parent1_index = tournament_selection(rankings)\n        parent2_index = tournament_selection(rankings)\n        parent1, parent2 = pops['individuals'][parent1_index], pops['individuals'][parent2_index]\n        child = single_point_crossover(parent1, parent2)\n        child = dynamic_mutation(child, rankings, parent1_index)\n        child = proportional_repair(child, W, C, V)\n        return child\n\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        new_pops[i] = create_offspring(pops, pops['rankings'], W, C, V)\n\n    return new_pops",
          "objective": 0.98682,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n\n    def tournament_selection(ranked_pop, tournament_size=3):\n        # Select individuals for the tournament\n        selected_indices = np.random.choice(POP_SIZE, tournament_size, replace=False)\n        # Find the best individual among the selected\n        best_index = selected_indices[np.argmin(ranked_pop['rankings'][selected_indices])]\n        return ranked_pop['individuals'][best_index]\n\n    def uniform_crossover(parent1, parent2):\n        child = np.where(np.random.rand(N_P) < 0.5, parent1, parent2)\n        return child\n\n    def bit_flip_mutation(individual, mutation_rate=0.1):\n        mutation_mask = np.random.rand(N_P) < mutation_rate\n        individual[mutation_mask] = 1 - individual[mutation_mask]\n        return individual\n\n    def greedy_repair(individual):\n        while np.dot(individual, W) > C:\n            # Select items that can be removed (non-zero in individual)\n            # and sort them by their efficiency (value/weight ratio)\n            nonzero_indices = np.where(individual == 1)[0]\n            if nonzero_indices.size == 0:\n                break\n            efficiencies = np.sum(V[nonzero_indices], axis=1) / W[nonzero_indices]\n            # Find the least efficient item and remove it\n            least_efficient_item = nonzero_indices[np.argmin(efficiencies)]\n            individual[least_efficient_item] = 0\n        return individual\n\n    def generate_new_individual():\n        parent1 = tournament_selection(pops)\n        parent2 = tournament_selection(pops)\n        child = uniform_crossover(parent1, parent2)\n        child = bit_flip_mutation(child)\n        child = greedy_repair(child)\n        return child\n\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        new_pops[i] = generate_new_individual()\n\n    return new_pops",
          "objective": 0.98678,
          "other_inf": null
     }
]