[
     {
          "algorithm": "Create a new population using rank-based selection, two-point crossover, and a greedy mutation that selectively adds items based on a sorted value-to-weight ratio, followed by a trimming process to remove items if the weight constraint is exceeded.",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n    \n    # Common backbone idea: Selection, Crossover, Mutation, and Repair to generate a new population.\n    \n    # {Create a new population using rank-based selection, two-point crossover, and a greedy mutation that selectively adds items based on a sorted value-to-weight ratio, followed by a trimming process to remove items if the weight constraint is exceeded.}\n    \n    # Rank-based selection\n    def rank_based_selection():\n        probabilities = 1 / (np.arange(1, POP_SIZE + 1))  # Inverse rank probabilities\n        probabilities /= probabilities.sum()  # Normalize to get a probability distribution\n        selected_index = np.random.choice(POP_SIZE, p=probabilities)\n        return pops['individuals'][selected_index]\n    \n    # Two-point crossover\n    def two_point_crossover(parent1, parent2):\n        points = np.sort(np.random.choice(N_P, 2, replace=False))\n        child = np.concatenate((parent1[:points[0]], parent2[points[0]:points[1]], parent1[points[1]:]))\n        return child\n    \n    # Greedy mutation\n    def greedy_mutation(individual):\n        value_weight_ratio = V.sum(axis=1) / W\n        sorted_indices = np.argsort(-value_weight_ratio)\n        for index in sorted_indices:\n            if individual[index] == 0 and np.dot(individual, W) + W[index] <= C:\n                individual[index] = 1\n        return individual\n    \n    # Trimming process\n    def trim_to_fit(individual):\n        while np.dot(individual, W) > C:\n            included_items = np.where(individual == 1)[0]\n            value_weight_ratio = V[included_items].sum(axis=1) / W[included_items]\n            least_efficient_item = included_items[np.argmin(value_weight_ratio)]\n            individual[least_efficient_item] = 0\n        return individual\n    \n    # Generate new population\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        parent1 = rank_based_selection()\n        parent2 = rank_based_selection()\n        child = two_point_crossover(parent1, parent2)\n        child = greedy_mutation(child)\n        child = trim_to_fit(child)\n        new_pops[i] = child\n    \n    return new_pops",
          "objective": 0.98888,
          "other_inf": null
     },
     {
          "algorithm": "\nThe new algorithm performs tournament selection, uniform crossover, bit-flip mutation, and a first-fit repair strategy to ensure weight constraints are met.\n",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n    \n    # Tournament selection\n    def tournament_selection(pops):\n        tournament_size = 3\n        indices = np.random.choice(POP_SIZE, tournament_size, replace=False)\n        tournament = pops['individuals'][indices]\n        tournament_ranks = pops['rankings'][indices]\n        winner_index = indices[np.argmin(tournament_ranks)]\n        return pops['individuals'][winner_index]\n\n    # Uniform crossover\n    def uniform_crossover(parent1, parent2):\n        crossover_mask = np.random.rand(N_P) < 0.5\n        child = np.where(crossover_mask, parent1, parent2)\n        return child\n\n    # Bit-flip mutation\n    def bit_flip_mutation(individual):\n        mutation_rate = 0.05\n        mutation_mask = np.random.rand(N_P) < mutation_rate\n        individual[mutation_mask] = 1 - individual[mutation_mask]\n        return individual\n\n    # First-fit repair strategy\n    def first_fit_repair(individual):\n        if np.dot(individual, W) > C:\n            sorted_indices = np.argsort(-V.sum(axis=1) / W)  # Sort by descending efficiency\n            individual[:] = 0  # Reset individual\n            current_weight = 0\n            for index in sorted_indices:\n                if current_weight + W[index] <= C:\n                    individual[index] = 1\n                    current_weight += W[index]\n        return individual\n\n    # Generate new individual\n    def generate_new_individual():\n        parent1 = tournament_selection(pops)\n        parent2 = tournament_selection(pops)\n        child = uniform_crossover(parent1, parent2)\n        child = bit_flip_mutation(child)\n        child = first_fit_repair(child)\n        return child\n\n    # Generate new population\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        new_pops[i] = generate_new_individual()\n\n    return new_pops",
          "objective": 0.98834,
          "other_inf": null
     },
     {
          "algorithm": "A novel algorithm using roulette wheel selection, two-point crossover, uniform mutation, and a sort-based repair mechanism.",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    \"\"\"\n    {A novel algorithm using roulette wheel selection, two-point crossover, uniform mutation, and a sort-based repair mechanism.}\n    \"\"\"\n    import numpy as np\n\n    # Roulette wheel selection\n    def roulette_wheel_selection(rankings):\n        max_rank = np.max(rankings)\n        adjusted_fitness = max_rank - rankings + 1\n        total_fitness = np.sum(adjusted_fitness)\n        selection_probs = adjusted_fitness / total_fitness\n        selected_index = np.random.choice(POP_SIZE, p=selection_probs)\n        return selected_index\n\n    # Two-point crossover\n    def two_point_crossover(parent1, parent2):\n        crossover_point1 = np.random.randint(1, N_P - 1)\n        crossover_point2 = np.random.randint(crossover_point1 + 1, N_P)\n        child = np.concatenate((parent1[:crossover_point1], parent2[crossover_point1:crossover_point2], parent1[crossover_point2:]))\n        return child\n\n    # Uniform mutation\n    def uniform_mutation(individual, mutation_rate=0.01):\n        for i in range(N_P):\n            if np.random.rand() < mutation_rate:\n                individual[i] = 1 - individual[i]\n        return individual\n\n    # Sort-based repair mechanism\n    def sort_based_repair(individual, W, C, V):\n        weight = np.dot(individual, W)\n        profit_weight_ratio = V.sum(axis=1) / W\n        items_sorted_by_ratio = np.argsort(-profit_weight_ratio)\n        for i in items_sorted_by_ratio:\n            if weight <= C:\n                break\n            if individual[i] == 1:\n                individual[i] = 0\n                weight -= W[i]\n        # If the knapsack is not full, try to add items\n        for i in items_sorted_by_ratio:\n            if weight + W[i] <= C and individual[i] == 0:\n                individual[i] = 1\n                weight += W[i]\n        return individual\n\n    # Generate new population\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        parent1_index = roulette_wheel_selection(pops['rankings'])\n        parent2_index = roulette_wheel_selection(pops['rankings'])\n        parent1, parent2 = pops['individuals'][parent1_index], pops['individuals'][parent2_index]\n        child = two_point_crossover(parent1, parent2)\n        child = uniform_mutation(child)\n        child = sort_based_repair(child, W, C, V)\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.98805,
          "other_inf": null
     },
     {
          "algorithm": "Create a new algorithm that uses random sampling to initialize a diverse population, followed by a single-point crossover and a heuristic mutation that favors items with higher profit-to-weight ratios, ensuring all offspring comply with the weight constraint.",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    # {Create a new algorithm that uses random sampling to initialize a diverse population, followed by a single-point crossover and a heuristic mutation that favors items with higher profit-to-weight ratios, ensuring all offspring comply with the weight constraint.}\n\n    import numpy as np\n    \n    def initialize_population(POP_SIZE, N_P):\n        return np.random.randint(2, size=(POP_SIZE, N_P))\n    \n    def single_point_crossover(parent1, parent2):\n        crossover_point = np.random.randint(1, N_P)\n        offspring = np.hstack((parent1[:crossover_point], parent2[crossover_point:]))\n        return offspring\n    \n    def heuristic_mutation(individual, W, C, V):\n        profit_weight_ratio = V.sum(axis=1) / W\n        while np.dot(individual, W) > C:\n            # Find items to consider for removal based on the individual and their profit/weight ratio\n            items_to_consider = np.where(individual == 1)[0]\n            # Sort items by their profit/weight ratio in descending order\n            items_sorted_by_ratio = items_to_consider[np.argsort(-profit_weight_ratio[items_to_consider])]\n            # Remove the item with the lowest ratio\n            item_to_remove = items_sorted_by_ratio[-1]\n            individual[item_to_remove] = 0\n        \n        # Mutation: flip a bit with a probability proportional to its profit/weight ratio\n        for i in range(N_P):\n            if np.random.rand() < (profit_weight_ratio[i] / profit_weight_ratio.sum()):\n                individual[i] = 1 - individual[i]\n                if np.dot(individual, W) > C:\n                    individual[i] = 1 - individual[i]  # revert if overweight\n        return individual\n    \n    # Initialize new population\n    new_pops = initialize_population(POP_SIZE, N_P)\n    \n    # Parent selection and crossover\n    for i in range(0, POP_SIZE, 2):\n        parent1, parent2 = pops['individuals'][np.random.choice(POP_SIZE, 2, replace=False)]\n        offspring1 = single_point_crossover(parent1, parent2)\n        offspring2 = single_point_crossover(parent2, parent1)\n        \n        # Mutation and repair\n        offspring1 = heuristic_mutation(offspring1, W, C, V)\n        offspring2 = heuristic_mutation(offspring2, W, C, V)\n        \n        # Add offspring to new population\n        new_pops[i] = offspring1\n        if i+1 < POP_SIZE:\n            new_pops[i+1] = offspring2\n    \n    return new_pops",
          "objective": 0.98802,
          "other_inf": null
     },
     {
          "algorithm": "A modified algorithm with rank-based selection, uniform crossover, mutation with a dynamic rate, and a greedy repair based on a combined score of profit/weight and rank.",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    \"\"\"\n    {A modified algorithm with rank-based selection, uniform crossover, mutation with a dynamic rate, and a greedy repair based on a combined score of profit/weight and rank.}\n    \"\"\"\n    import numpy as np\n    \n    # Rank-based selection\n    def rank_based_selection(rankings):\n        probabilities = (1 / (rankings + 1)) / sum(1 / (rankings + 1))\n        selected_index = np.random.choice(np.arange(len(rankings)), p=probabilities)\n        return selected_index\n    \n    # Uniform crossover\n    def uniform_crossover(parent1, parent2):\n        mask = np.random.rand(N_P) < 0.5\n        child = np.where(mask, parent1, parent2)\n        return child\n    \n    # Mutation with a dynamic rate\n    def dynamic_mutation(individual, gen_count):\n        mutation_rate = 0.05 / (1 + 0.05 * gen_count)\n        mutation_mask = np.random.rand(len(individual)) < mutation_rate\n        individual[mutation_mask] = 1 - individual[mutation_mask]\n        return individual\n    \n    # Greedy repair based on combined score of profit/weight and rank\n    def greedy_repair(individual, W, C, V, rankings, parent_index):\n        weight = np.dot(individual, W)\n        combined_score = (V.sum(axis=1) / W) * (1 / (rankings[parent_index] + 1))\n        while weight > C:\n            items_included = np.where(individual == 1)[0]\n            least_beneficial_item = items_included[np.argmin(combined_score[items_included])]\n            individual[least_beneficial_item] = 0\n            weight -= W[least_beneficial_item]\n        return individual\n    \n    # Generate new population\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    gen_count = 0\n    while gen_count < POP_SIZE:\n        parent1_index = rank_based_selection(pops['rankings'])\n        parent2_index = rank_based_selection(pops['rankings'])\n        parent1, parent2 = pops['individuals'][parent1_index], pops['individuals'][parent2_index]\n        child = uniform_crossover(parent1, parent2)\n        child = dynamic_mutation(child, gen_count)\n        child = greedy_repair(child, W, C, V, pops['rankings'], parent1_index)\n        new_pops[gen_count] = child\n        gen_count += 1\n    \n    return new_pops",
          "objective": 0.9877,
          "other_inf": null
     },
     {
          "algorithm": "A novel algorithm with tournament-based selection, single-point crossover, bit-flip mutation, and greedy repair based on profit/weight ratio.",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    \"\"\"\n    {A novel algorithm with tournament-based selection, single-point crossover, bit-flip mutation, and greedy repair based on profit/weight ratio.}\n    \"\"\"\n    import numpy as np\n    \n    # Tournament-based selection\n    def tournament_selection(rankings, tournament_size=3):\n        competitors = np.random.choice(np.arange(len(rankings)), tournament_size, replace=False)\n        best_index = competitors[np.argmin(rankings[competitors])]\n        return best_index\n    \n    # Single-point crossover\n    def single_point_crossover(parent1, parent2):\n        crossover_point = np.random.randint(1, N_P)\n        child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        return child\n    \n    # Bit-flip mutation\n    def bit_flip_mutation(individual, mutation_rate=0.01):\n        mutation_mask = np.random.rand(len(individual)) < mutation_rate\n        individual[mutation_mask] = 1 - individual[mutation_mask]\n        return individual\n    \n    # Greedy repair based on profit/weight ratio\n    def greedy_repair(individual, W, C, V):\n        weight = np.dot(individual, W)\n        profit_weight_ratio = V.sum(axis=1) / W\n        while weight > C:\n            items_included = np.where(individual == 1)[0]\n            least_efficient_item = items_included[np.argmin(profit_weight_ratio[items_included])]\n            individual[least_efficient_item] = 0\n            weight -= W[least_efficient_item]\n        return individual\n    \n    # Create offspring\n    def create_offspring(pops, rankings, W, C, V):\n        parent1_index = tournament_selection(rankings)\n        parent2_index = tournament_selection(rankings)\n        parent1, parent2 = pops['individuals'][parent1_index], pops['individuals'][parent2_index]\n        child = single_point_crossover(parent1, parent2)\n        child = bit_flip_mutation(child)\n        child = greedy_repair(child, W, C, V)\n        return child\n    \n    # Generate new population\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        new_pops[i] = create_offspring(pops, pops['rankings'], W, C, V)\n    \n    return new_pops",
          "objective": 0.98742,
          "other_inf": null
     },
     {
          "algorithm": "Create a new population using deterministic tournament selection, single-point crossover, and a heuristic-based mutation that favors items with higher value-to-weight ratios.",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    # {Create a new population using deterministic tournament selection, single-point crossover, and a heuristic-based mutation that favors items with higher value-to-weight ratios.}\n\n    # Initialize the new population\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    \n    for i in range(POP_SIZE):\n        # Deterministic tournament selection\n        competitors = np.random.choice(POP_SIZE, 2, replace=False)\n        if pops['rankings'][competitors[0]] < pops['rankings'][competitors[1]]:\n            winner = pops['individuals'][competitors[0]]\n        else:\n            winner = pops['individuals'][competitors[1]]\n\n        # Single-point crossover\n        point = np.random.randint(1, N_P)\n        if i > 0:  # Ensure we have at least one parent from the previous generation\n            parent = new_pops[np.random.randint(i)]\n            child = np.concatenate((winner[:point], parent[point:]))\n        else:\n            child = winner.copy()  # The first individual is a copy of the winner\n\n        # Heuristic-based mutation\n        value_weight_ratio = V.sum(axis=1) / W\n        sorted_indices = np.argsort(value_weight_ratio)[::-1]\n        for j in sorted_indices:\n            if child[j] == 0 and np.dot(child, W) + W[j] <= C:\n                child[j] = 1  # Add item if it improves the value without exceeding weight\n            elif child[j] == 1 and np.random.rand() < 0.05:\n                child[j] = 0  # Randomly remove item with a small probability\n\n        # Ensure the child meets the weight constraint\n        while np.dot(child, W) > C:\n            overweight_indices = np.where(child == 1)[0]\n            child[np.random.choice(overweight_indices)] = 0\n\n        # Add the child to the new population\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.98732,
          "other_inf": null
     },
     {
          "algorithm": "Implement tournament selection, uniform crossover, and greedy mutation based on a sorted value-weight ratio, followed by a repair strategy that drops items based on the reverse value-weight ratio until the weight constraint is met.",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n\n    # New algorithm in one sentence: {Implement tournament selection, uniform crossover, and greedy mutation based on a sorted value-weight ratio, followed by a repair strategy that drops items based on the reverse value-weight ratio until the weight constraint is met.}\n    \n    def tournament_selection(fitness_scores, tournament_size=3):\n        # Select random individuals for the tournament\n        competitors_idx = np.random.choice(len(fitness_scores), tournament_size, replace=False)\n        competitors_fitness = fitness_scores[competitors_idx]\n        # Choose the best individual from the tournament\n        winner_idx = competitors_idx[np.argmax(competitors_fitness)]\n        return winner_idx\n\n    def uniform_crossover(parent1, parent2):\n        # Create a mask for crossover\n        mask = np.random.randint(0, 2, size=N_P)\n        # Generate offspring\n        offspring = np.where(mask == 1, parent1, parent2)\n        return offspring\n\n    def greedy_mutation(individual, mutation_rate=0.1):\n        # Sort items by value-weight ratio\n        value_weight_ratios = V.sum(axis=1) / W\n        sorted_indices = np.argsort(value_weight_ratios)[::-1]\n        # Apply mutation based on mutation rate\n        for idx in sorted_indices:\n            if np.random.rand() < mutation_rate:\n                individual[idx] = 1 - individual[idx]\n                # If the knapsack becomes too heavy, revert the mutation\n                if np.dot(individual, W) > C:\n                    individual[idx] = 1 - individual[idx]\n                    break\n        return individual\n\n    def repair(individual):\n        # Sort items by reverse value-weight ratio\n        value_weight_ratios = V.sum(axis=1) / W\n        sorted_indices = np.argsort(value_weight_ratios)\n        # Remove items until the weight constraint is met\n        for idx in sorted_indices:\n            if np.dot(individual, W) > C:\n                individual[idx] = 0\n            else:\n                break\n        return individual\n\n    # Calculate fitness scores as inverse of rankings for selection\n    fitness_scores = 1 / (pops['rankings'] + 1)\n    \n    # Initialize new population\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    \n    # Generate new population\n    for i in range(POP_SIZE):\n        # Select parents using tournament selection\n        parent1_index = tournament_selection(fitness_scores)\n        parent2_index = tournament_selection(fitness_scores)\n        parent1 = pops['individuals'][parent1_index]\n        parent2 = pops['individuals'][parent2_index]\n        \n        # Create offspring using uniform crossover\n        offspring = uniform_crossover(parent1, parent2)\n        \n        # Mutate offspring using greedy mutation\n        offspring = greedy_mutation(offspring)\n        \n        # Repair offspring if necessary\n        offspring = repair(offspring)\n        \n        # Add offspring to new population\n        new_pops[i] = offspring\n    \n    return new_pops",
          "objective": 0.98728,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    import numpy as np\n\n    # Rank-based selection using exponential ranking\n    def exponential_rank_selection(ranked_pop):\n        ranks = ranked_pop['rankings']\n        max_rank = np.max(ranks)\n        # Exponential rank-based probabilities\n        selection_probs = np.exp(-ranks / max_rank)\n        selection_probs /= selection_probs.sum()\n        selected_index = np.random.choice(POP_SIZE, p=selection_probs)\n        return ranked_pop['individuals'][selected_index]\n\n    # Uniform crossover for creating new offspring\n    def uniform_crossover(parent1, parent2):\n        mask = np.random.rand(N_P) < 0.5\n        child = np.where(mask, parent1, parent2)\n        return child\n\n    # Mutation with fixed mutation rate\n    def fixed_mutation(individual):\n        mutation_rate = 0.05  # Fixed mutation rate\n        mutation_mask = np.random.rand(N_P) < mutation_rate\n        individual[mutation_mask] = 1 - individual[mutation_mask]\n        return individual\n\n    # Greedy repair modified to prioritize profit/weight ratio\n    def modified_greedy_repair(individual):\n        while np.dot(individual, W) > C:\n            nonzero_indices = np.where(individual == 1)[0]\n            if nonzero_indices.size == 0:\n                break\n            # Calculate profit/weight ratio for each item\n            profit_per_weight = np.sum(V[nonzero_indices], axis=1) / W[nonzero_indices]\n            # Find the item with the lowest profit/weight ratio\n            least_profitable_item = nonzero_indices[np.argmin(profit_per_weight)]\n            individual[least_profitable_item] = 0\n        return individual\n\n    # Generate a new individual using the defined sub-functions\n    def generate_new_individual():\n        parent1 = exponential_rank_selection(pops)\n        parent2 = exponential_rank_selection(pops)\n        child = uniform_crossover(parent1, parent2)\n        child = fixed_mutation(child)\n        child = modified_greedy_repair(child)\n        return child\n\n    # Main loop to generate new population\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        new_pops[i] = generate_new_individual()\n\n    return new_pops",
          "objective": 0.98726,
          "other_inf": null
     },
     {
          "algorithm": "Create a new algorithm that uses tournament selection for parent choice, uniform crossover, and a greedy mutation that adds items with the highest profit-to-weight ratio until the knapsack is full.",
          "code": "def next_generation(pops, W, C, V, POP_SIZE, N_P):\n    # {Create a new algorithm that uses tournament selection for parent choice, uniform crossover, and a greedy mutation that adds items with the highest profit-to-weight ratio until the knapsack is full.}\n\n    import numpy as np\n    \n    def tournament_selection(pop, rankings, k=3):\n        selected_indices = np.random.choice(len(rankings), k, replace=False)\n        selected_rankings = rankings[selected_indices]\n        winner_index = selected_indices[selected_rankings.argmin()]\n        return pop[winner_index]\n\n    def uniform_crossover(parent1, parent2):\n        mask = np.random.randint(2, size=N_P)\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n    \n    def greedy_mutation(individual, W, C, V):\n        profit_weight_ratio = V.sum(axis=1) / W\n        items_not_included = np.where(individual == 0)[0]\n        items_sorted_by_ratio = items_not_included[np.argsort(-profit_weight_ratio[items_not_included])]\n        \n        for item in items_sorted_by_ratio:\n            if np.dot(individual, W) + W[item] <= C:\n                individual[item] = 1\n        return individual\n    \n    def repair(individual, W, C):\n        while np.dot(individual, W) > C:\n            included_items = np.where(individual == 1)[0]\n            item_to_remove = np.random.choice(included_items)\n            individual[item_to_remove] = 0\n        return individual\n\n    # Initialize new population\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    \n    # Generate new population\n    for i in range(POP_SIZE):\n        # Tournament selection\n        parent1 = tournament_selection(pops['individuals'], pops['rankings'])\n        parent2 = tournament_selection(pops['individuals'], pops['rankings'])\n        \n        # Uniform crossover\n        offspring = uniform_crossover(parent1, parent2)\n        \n        # Greedy mutation\n        offspring = greedy_mutation(offspring, W, C, V)\n        \n        # Repair if necessary\n        offspring = repair(offspring, W, C)\n        \n        # Add offspring to new population\n        new_pops[i] = offspring\n    \n    return new_pops",
          "objective": 0.98717,
          "other_inf": null
     }
]