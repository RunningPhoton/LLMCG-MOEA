[
     {
          "algorithm": "```",
          "code": "def next_generation(pops, search_trajectory, xlb, xub, POP_SIZE, N_P, current_gen, max_gen):\n    import numpy as np\n\n    def crossover(parent1, parent2):\n        child = np.empty(N_P)\n        for i in range(N_P):\n            if np.random.rand() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutate(individual):\n        mutation_rate = 0.1 + (0.5 - 0.1) * current_gen / max_gen\n        for i in range(N_P):\n            if np.random.rand() < mutation_rate:\n                individual[i] += np.random.uniform(-1, 1) * (xub[i] - xlb[i]) * 0.1\n                individual[i] = np.clip(individual[i], xlb[i], xub[i])\n        return individual\n\n    def select_parents(ranked_individuals):\n        index1 = np.random.randint(POP_SIZE)\n        index2 = (index1 + np.random.randint(1, POP_SIZE)) % POP_SIZE\n        return ranked_individuals[index1], ranked_individuals[index2]\n\n    def create_new_population():\n        new_population = np.empty((POP_SIZE, N_P))\n        for i in range(POP_SIZE):\n            parent1, parent2 = select_parents(pops['individuals'])\n            child = crossover(parent1, parent2)\n            child = mutate(child)\n            new_population[i] = child\n        return new_population\n\n    new_pops = create_new_population()\n    return new_pops",
          "objective": -0.95647,
          "other_inf": null
     },
     {
          "algorithm": "A reproduction function that integrates tournament selection, simulated binary crossover (SBX), \n    Gaussian mutation, and search trajectory exploitation to generate the next population for \n    multi-objective optimization problems.",
          "code": "def next_generation(pops, search_trajectory, xlb, xub, POP_SIZE, N_P, current_gen, max_gen):\n    \"\"\"\n    {A reproduction function that integrates tournament selection, simulated binary crossover (SBX), \n    Gaussian mutation, and search trajectory exploitation to generate the next population for \n    multi-objective optimization problems.}\n    \"\"\"\n    import numpy as np\n\n    def tournament_selection(k=2):\n        best = None\n        for _ in range(k):\n            ind = np.random.randint(0, POP_SIZE)\n            if best is None or pops['rankings'][ind] < pops['rankings'][best]:\n                best = ind\n        return pops['individuals'][best]\n\n    def sbx_crossover(parent1, parent2, eta=2.0):\n        child1, child2 = np.copy(parent1), np.copy(parent2)\n        for i in range(N_P):\n            if np.random.rand() <= 0.5:\n                if abs(parent1[i] - parent2[i]) > 1e-14:\n                    x1 = min(parent1[i], parent2[i])\n                    x2 = max(parent1[i], parent2[i])\n                    beta = 1.0 + (2.0 * (x1 - xlb[i]) / (x2 - x1))\n                    alpha = 2.0 - beta**-(eta + 1)\n                    rand = np.random.rand()\n                    if rand <= 1.0 / alpha:\n                        beta_q = (rand * alpha)**(1.0 / (eta + 1))\n                    else:\n                        beta_q = (1.0 / (2.0 - rand * alpha))**(1.0 / (eta + 1))\n                    c1 = 0.5 * ((x1 + x2) - beta_q * (x2 - x1))\n                    \n                    beta = 1.0 + (2.0 * (xub[i] - x2) / (x2 - x1))\n                    alpha = 2.0 - beta**-(eta + 1)\n                    if rand <= 1.0 / alpha:\n                        beta_q = (rand * alpha)**(1.0 / (eta + 1))\n                    else:\n                        beta_q = (1.0 / (2.0 - rand * alpha))**(1.0 / (eta + 1))\n                    c2 = 0.5 * ((x1 + x2) + beta_q * (x2 - x1))\n                    \n                    c1 = np.clip(c1, xlb[i], xub[i])\n                    c2 = np.clip(c2, xlb[i], xub[i])\n                    \n                    if np.random.rand() <= 0.5:\n                        child1[i] = c2\n                        child2[i] = c1\n                    else:\n                        child1[i] = c1\n                        child2[i] = c2\n        return child1 if np.random.rand() <= 0.5 else child2\n\n    def gaussian_mutation(individual, mutation_prob=0.1):\n        for i in range(N_P):\n            if np.random.rand() < mutation_prob:\n                sigma = (xub[i] - xlb[i]) / 20.0\n                individual[i] += np.random.normal(0, sigma)\n                individual[i] = np.clip(individual[i], xlb[i], xub[i])\n        return individual\n\n    def exploit_search_trajectory():\n        if search_trajectory['individuals'] is not None and search_trajectory['rankings'] is not None:\n            best_idx = np.argmin(search_trajectory['rankings'])\n            return search_trajectory['individuals'][best_idx]\n        else:\n            return None\n\n    new_pops = np.zeros((POP_SIZE, N_P))\n    for i in range(POP_SIZE):\n        parent1 = tournament_selection()\n        if np.random.rand() < 0.9:  # High probability for crossover\n            parent2 = tournament_selection()\n            child = sbx_crossover(parent1, parent2)\n        else:\n            traj_ind = exploit_search_trajectory()\n            child = traj_ind if traj_ind is not None else parent1\n        child = gaussian_mutation(child)\n        new_pops[i, :] = child\n\n    return new_pops",
          "objective": -3.66608,
          "other_inf": null
     },
     {
          "algorithm": "A novel algorithm that integrates simulated annealing into the mutation process to adaptively control exploration and exploitation based on the current generation, alongside a crossover strategy that favors elite individuals.",
          "code": "def next_generation(pops, search_trajectory, xlb, xub, POP_SIZE, N_P, current_gen, max_gen):\n    \"\"\"\n    {A novel algorithm that integrates simulated annealing into the mutation process to adaptively control exploration and exploitation based on the current generation, alongside a crossover strategy that favors elite individuals.}\n    \"\"\"\n    import numpy as np\n\n    def simulated_annealing_mutation(individuals, current_gen, max_gen):\n        T_initial = 1.0\n        T_final = 0.01\n        T = T_initial * ((T_final / T_initial) ** (current_gen / max_gen))\n        new_individuals = np.empty_like(individuals)\n        for i in range(len(individuals)):\n            idxs = [idx for idx in range(len(individuals)) if idx != i]\n            a, b, c = individuals[np.random.choice(idxs, 3, replace=False)]\n            mutant = a + (b - c) * (T * np.random.randn(N_P))\n            mutant = np.clip(mutant, xlb, xub)\n            new_individuals[i] = mutant\n        return new_individuals\n\n    def elite_crossover(individuals, rankings):\n        CR = 0.7  # Crossover probability\n        elite = individuals[rankings.argmin()]\n        new_individuals = np.empty_like(individuals)\n        for i in range(len(individuals)):\n            cross_points = np.random.rand(N_P) < CR\n            trial = np.where(cross_points, individuals[i], elite)\n            new_individuals[i] = trial\n        return new_individuals\n\n    def create_new_population(individuals, rankings):\n        individuals = simulated_annealing_mutation(individuals, current_gen, max_gen)\n        individuals = elite_crossover(individuals, rankings)\n        return individuals\n\n    new_pops = create_new_population(pops['individuals'], pops['rankings'])\n    return new_pops",
          "objective": -4.12943,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, search_trajectory, xlb, xub, POP_SIZE, N_P, current_gen, max_gen):\n    \"\"\"\n    This algorithm introduces a blending crossover along with adaptive mutation based on historical search trajectory and a cooling schedule for mutation intensity.\n    \"\"\"\n    import numpy as np\n    \n    def blending_crossover(parents):\n        alpha = 0.5  # blending ratio\n        new_individuals = np.empty_like(parents)\n        for i in range(len(parents)):\n            p1, p2 = np.random.choice(len(parents), 2, replace=False)\n            new_individuals[i] = alpha * parents[p1] + (1 - alpha) * parents[p2]\n        return new_individuals\n    \n    def adaptive_mutation(individuals, trajectory, current_gen, max_gen):\n        sigma_base = (xub - xlb) * 0.1\n        cooling_factor = (1 - (current_gen / max_gen))**2\n        sigma = sigma_base * cooling_factor\n        for i in range(len(individuals)):\n            if trajectory['individuals'] is not None and len(trajectory['individuals']) > 0:\n                historical_individual = trajectory['individuals'][np.random.randint(0, len(trajectory['individuals']))]\n                individuals[i] += np.random.normal(0, sigma) * (historical_individual - individuals[i])\n            individuals[i] = np.clip(individuals[i], xlb, xub)\n        return individuals\n    \n    def create_new_population(individuals):\n        quarter_pop_size = POP_SIZE // 4\n        crossover_individuals = blending_crossover(individuals[:quarter_pop_size])\n        mutated_individuals = adaptive_mutation(individuals[quarter_pop_size:], search_trajectory, current_gen, max_gen)\n        return np.vstack((crossover_individuals, mutated_individuals, individuals[quarter_pop_size:]))\n    \n    def validate_population(individuals):\n        return np.clip(individuals, xlb, xub)\n    \n    individuals = pops['individuals']\n    new_individuals = create_new_population(individuals)\n    new_pops = validate_population(new_individuals)\n    \n    return new_pops",
          "objective": -7.58174,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, search_trajectory, xlb, xub, POP_SIZE, N_P, current_gen, max_gen):\n    import numpy as np\n\n    def mutate(individual, mutation_rate, xlb, xub):\n        if np.random.rand() < mutation_rate:\n            mutation_vector = np.random.uniform(-1, 1, individual.shape) * (xub - xlb)\n            new_individual = individual + mutation_vector\n            new_individual = np.clip(new_individual, xlb, xub)\n        else:\n            new_individual = individual\n        return new_individual\n\n    def crossover(parent1, parent2, crossover_rate):\n        if np.random.rand() < crossover_rate:\n            crossover_point = np.random.randint(0, N_P)\n            child1 = np.concatenate([parent1[:crossover_point], parent2[crossover_point:]])\n            child2 = np.concatenate([parent2[:crossover_point], parent1[crossover_point:]])\n            return child1, child2\n        else:\n            return parent1, parent2\n\n    def select_parents(population, rankings):\n        prob = 1 / (1 + rankings)\n        prob /= prob.sum()\n        idx = np.random.choice(np.arange(POP_SIZE), size=2, replace=False, p=prob)\n        return population[idx[0]], population[idx[1]]\n\n    def create_new_population(pops, POP_SIZE, N_P, xlb, xub, current_gen, max_gen):\n        new_population = np.empty((POP_SIZE, N_P))\n        mutation_rate = max(0.1, 1 - current_gen / max_gen)\n        crossover_rate = max(0.5, 1 - current_gen / max_gen)\n        \n        for i in range(0, POP_SIZE, 2):\n            parent1, parent2 = select_parents(pops['individuals'], pops['rankings'])\n            child1, child2 = crossover(parent1, parent2, crossover_rate)\n            child1 = mutate(child1, mutation_rate, xlb, xub)\n            child2 = mutate(child2, mutation_rate, xlb, xub)\n            new_population[i] = child1\n            if i + 1 < POP_SIZE:\n                new_population[i + 1] = child2\n\n        return new_population\n\n    new_pops = create_new_population(pops, POP_SIZE, N_P, xlb, xub, current_gen, max_gen)\n    return new_pops",
          "objective": -19.35809,
          "other_inf": null
     },
     {
          "algorithm": "A novel algorithm that combines tournament selection with simulated binary crossover (SBX) and polynomial mutation, focusing on diversity preservation and exploration.",
          "code": "def next_generation(pops, search_trajectory, xlb, xub, POP_SIZE, N_P, current_gen, max_gen):\n    \"\"\"\n    {A novel algorithm that combines tournament selection with simulated binary crossover (SBX) and polynomial mutation, focusing on diversity preservation and exploration.}\n    \"\"\"\n    import numpy as np\n    \n    def tournament_selection(population, rankings, tournament_size=2):\n        selected = []\n        for _ in range(tournament_size):\n            participants = np.random.choice(len(population), tournament_size, replace=False)\n            winner = participants[np.argmin(rankings[participants])]\n            selected.append(winner)\n        return population[selected]\n\n    def sbx_crossover(parent1, parent2, eta=2.0):\n        child1, child2 = np.copy(parent1), np.copy(parent2)\n        for i in range(N_P):\n            if np.random.rand() <= 0.9:\n                if abs(parent1[i] - parent2[i]) > 1e-14:\n                    x1 = min(parent1[i], parent2[i])\n                    x2 = max(parent1[i], parent2[i])\n                    xl = xlb[i]\n                    xu = xub[i]\n                    rand = np.random.rand()\n                    beta = 1.0 + (2.0 * (x1 - xl) / (x2 - x1))\n                    alpha = 2.0 - beta**-(eta + 1)\n                    if rand <= 1.0 / alpha:\n                        beta_q = (rand * alpha)**(1.0 / (eta + 1))\n                    else:\n                        beta_q = (1.0 / (2.0 - rand * alpha))**(1.0 / (eta + 1))\n                    c1 = 0.5 * ((x1 + x2) - beta_q * (x2 - x1))\n                    beta = 1.0 + (2.0 * (xu - x2) / (x2 - x1))\n                    alpha = 2.0 - beta**-(eta + 1)\n                    if rand <= 1.0 / alpha:\n                        beta_q = (rand * alpha)**(1.0 / (eta + 1))\n                    else:\n                        beta_q = (1.0 / (2.0 - rand * alpha))**(1.0 / (eta + 1))\n                    c2 = 0.5 * ((x1 + x2) + beta_q * (x2 - x1))\n                    c1 = np.clip(c1, xl, xu)\n                    c2 = np.clip(c2, xl, xu)\n                    if np.random.rand() <= 0.5:\n                        child1[i] = c2\n                        child2[i] = c1\n                    else:\n                        child1[i] = c1\n                        child2[i] = c2\n        return child1, child2\n\n    def polynomial_mutation(individual, eta_m=20):\n        mutant = np.copy(individual)\n        for i in range(N_P):\n            if np.random.rand() < 1.0 / N_P:\n                xl = xlb[i]\n                xu = xub[i]\n                delta1 = (mutant[i] - xl) / (xu - xl)\n                delta2 = (xu - mutant[i]) / (xu - xl)\n                rand = np.random.rand()\n                mut_pow = 1.0 / (eta_m + 1.0)\n                if rand < 0.5:\n                    xy = 1.0 - delta1\n                    val = 2.0 * rand + (1.0 - 2.0 * rand) * (xy**(eta_m + 1))\n                    delta_q = val**mut_pow - 1.0\n                else:\n                    xy = 1.0 - delta2\n                    val = 2.0 * (1.0 - rand) + 2.0 * (rand - 0.5) * (xy**(eta_m + 1))\n                    delta_q = 1.0 - val**mut_pow\n                mutant[i] = mutant[i] + delta_q * (xu - xl)\n                mutant[i] = np.clip(mutant[i], xl, xu)\n        return mutant\n\n    def create_new_population(population, rankings):\n        new_population = np.empty_like(population)\n        for i in range(0, POP_SIZE, 2):\n            parent1, parent2 = tournament_selection(population, rankings)\n            child1, child2 = sbx_crossover(parent1, parent2)\n            child1 = polynomial_mutation(child1)\n            child2 = polynomial_mutation(child2)\n            new_population[i] = child1\n            if i + 1 < POP_SIZE:\n                new_population[i + 1] = child2\n        return new_population\n\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n    new_pops = create_new_population(individuals, rankings)\n\n    return new_pops",
          "objective": -21.11261,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, search_trajectory, xlb, xub, POP_SIZE, N_P, current_gen, max_gen):\n    \"\"\"\n    The algorithm iteratively generates a new population by selecting parents, \n    applying crossover and mutation, and then selecting the best individuals based on rankings.\n    \"\"\"\n    import numpy as np\n\n    def crossover(parent1, parent2):\n        \"\"\"Perform crossover between two parents to produce an offspring.\"\"\"\n        alpha = np.random.rand(N_P)\n        return alpha * parent1 + (1 - alpha) * parent2\n\n    def mutate(individual):\n        \"\"\"Mutate an individual by randomly changing its genes within bounds.\"\"\"\n        mutation_strength = (xub - xlb) * (1 - current_gen / max_gen) * 0.1\n        mutation = np.random.randn(N_P) * mutation_strength\n        return np.clip(individual + mutation, xlb, xub)\n\n    def tournament_selection(population, k=2):\n        \"\"\"Select one individual from the population using k-tournament selection.\"\"\"\n        selected_indices = np.random.choice(len(population), k, replace=False)\n        selected_individuals = population[selected_indices]\n        selected_rankings = pops['rankings'][selected_indices]\n        winner_index = selected_indices[np.argmin(selected_rankings)]\n        return population[winner_index]\n\n    def create_new_population():\n        \"\"\"Create a new population using crossover, mutation, and selection.\"\"\"\n        new_population = []\n        while len(new_population) < POP_SIZE:\n            # Select parents\n            parent1 = tournament_selection(pops['individuals'])\n            parent2 = tournament_selection(pops['individuals'])\n            # Crossover\n            offspring = crossover(parent1, parent2)\n            # Mutation\n            offspring = mutate(offspring)\n            new_population.append(offspring)\n        return np.array(new_population)\n\n    # Generate the new population\n    new_pops = create_new_population()\n    \n    return new_pops",
          "objective": -27.17128,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, search_trajectory, xlb, xub, POP_SIZE, N_P, current_gen, max_gen):\n    import numpy as np\n\n    def crossover(parent1, parent2):\n        alpha = np.random.uniform(0, 1, size=N_P)\n        child = alpha * parent1 + (1 - alpha) * parent2\n        return child\n\n    def mutate(individual):\n        mutation_rate = 0.1 + (0.9 - 0.1) * current_gen / max_gen\n        for i in range(N_P):\n            if np.random.rand() < mutation_rate:\n                individual[i] += np.random.normal(0, (xub[i] - xlb[i]) / 10)\n                individual[i] = np.clip(individual[i], xlb[i], xub[i])\n        return individual\n\n    def select_parents(population, rankings):\n        prob = 1 / (rankings + 1)\n        prob /= prob.sum()\n        parents_indices = np.random.choice(len(population), size=2, p=prob, replace=False)\n        return population[parents_indices[0]], population[parents_indices[1]]\n\n    def create_new_individual(current_population, rankings):\n        parent1, parent2 = select_parents(current_population, rankings)\n        child = crossover(parent1, parent2)\n        child = mutate(child)\n        return child\n\n    new_pops = np.empty((POP_SIZE, N_P))\n    for i in range(POP_SIZE):\n        new_pops[i] = create_new_individual(pops['individuals'], pops['rankings'])\n\n    return new_pops",
          "objective": -29.97957,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, search_trajectory, xlb, xub, POP_SIZE, N_P, current_gen, max_gen):\n    \"\"\"\n    A novel reproduction function that employs a hybrid of differential evolution and trajectory-based mutation to generate the next population.\n    \"\"\"\n\n    import numpy as np\n\n    def differential_evolution(individuals):\n        CR = 0.9  # Crossover probability\n        F = 0.8  # Differential weight\n        new_individuals = np.empty_like(individuals)\n        for i in range(len(individuals)):\n            idxs = [idx for idx in range(len(individuals)) if idx != i]\n            a, b, c = individuals[np.random.choice(idxs, 3, replace=False)]\n            mutant = np.clip(a + F * (b - c), xlb, xub)\n            cross_points = np.random.rand(N_P) < CR\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, N_P)] = True\n            trial = np.where(cross_points, mutant, individuals[i])\n            new_individuals[i] = trial\n        return new_individuals\n\n    def trajectory_mutation(individuals, trajectory):\n        sigma = (xub - xlb) * (1 - (current_gen / max_gen))**2\n        for i in range(len(individuals)):\n            if trajectory['individuals'] is not None and len(trajectory['individuals']) > 0:\n                historical_individual = trajectory['individuals'][np.random.randint(0, len(trajectory['individuals']))]\n                individuals[i] += np.random.normal(0, sigma) * (historical_individual - individuals[i])\n            individuals[i] = np.clip(individuals[i], xlb, xub)\n        return individuals\n\n    def create_new_population(individuals):\n        half_pop_size = POP_SIZE // 2\n        new_individuals = differential_evolution(individuals[:half_pop_size])\n        mutated_individuals = trajectory_mutation(individuals[half_pop_size:], search_trajectory)\n        return np.vstack((new_individuals, mutated_individuals))\n\n    def validate_population(individuals):\n        return np.clip(individuals, xlb, xub)\n\n    individuals = pops['individuals']\n    new_individuals = create_new_population(individuals)\n    new_pops = validate_population(new_individuals)\n\n    return new_pops",
          "objective": -32.12739,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, search_trajectory, xlb, xub, POP_SIZE, N_P, current_gen, max_gen):\n    \"\"\"\n    The algorithm combines differential evolution with a local search heuristic that uses historical search information to guide mutation and crossover, aiming to converge towards the Pareto front.\n    \"\"\"\n    import numpy as np\n\n    def differential_evolution(individuals):\n        CR = 0.9  # Crossover probability\n        F = 0.8   # Differential weight\n        new_individuals = np.empty_like(individuals)\n        for i in range(len(individuals)):\n            idxs = [idx for idx in range(len(individuals)) if idx != i]\n            a, b, c = individuals[np.random.choice(idxs, 3, replace=False)]\n            mutant = np.clip(a + F * (b - c), xlb, xub)\n            cross_points = np.random.rand(N_P) < CR\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, N_P)] = True\n            trial = np.where(cross_points, mutant, individuals[i])\n            new_individuals[i] = trial\n        return new_individuals\n\n    def local_search(individuals):\n        LS_FACTOR = 0.1  # Local search factor\n        for i in range(len(individuals)):\n            if np.random.rand() < LS_FACTOR:\n                local_search_vector = np.random.randn(N_P) * (xub - xlb) * 0.1\n                individuals[i] = np.clip(individuals[i] + local_search_vector, xlb, xub)\n        return individuals\n\n    def historical_guided_mutation(individuals):\n        if search_trajectory['individuals'] is not None and len(search_trajectory['individuals']) > 0:\n            historical_individuals = search_trajectory['individuals']\n            for i in range(len(individuals)):\n                if np.random.rand() < 0.2:\n                    historical_idx = np.random.randint(len(historical_individuals))\n                    historical_individual = historical_individuals[historical_idx]\n                    mutation_vector = (historical_individual - individuals[i]) * np.random.rand(N_P)\n                    individuals[i] = np.clip(individuals[i] + mutation_vector, xlb, xub)\n        return individuals\n\n    def create_new_population(individuals):\n        individuals = differential_evolution(individuals)\n        individuals = local_search(individuals)\n        individuals = historical_guided_mutation(individuals)\n        return individuals\n\n    new_pops = create_new_population(pops['individuals'])\n    return new_pops",
          "objective": -35.09861,
          "other_inf": null
     }
]