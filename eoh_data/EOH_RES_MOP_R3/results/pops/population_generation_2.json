[
     {
          "algorithm": "A novel reproduction function that combines simulated binary crossover and polynomial mutation to generate the next population.",
          "code": "def next_generation(pops, search_trajectory, xlb, xub, POP_SIZE, N_P, current_gen, max_gen):\n    \"\"\"\n    {A novel reproduction function that combines simulated binary crossover and polynomial mutation to generate the next population.}\n    \"\"\"\n    import numpy as np\n\n    def sbx_crossover(parent1, parent2, eta=30):\n        child1, child2 = np.copy(parent1), np.copy(parent2)\n        for i in range(N_P):\n            if np.random.rand() <= 0.5:\n                if abs(parent1[i] - parent2[i]) > 1e-14:\n                    x1 = min(parent1[i], parent2[i])\n                    x2 = max(parent1[i], parent2[i])\n                    xl = xlb[i]\n                    xu = xub[i]\n                    rand = np.random.rand()\n\n                    beta = 1.0 + (2.0 * (x1 - xl) / (x2 - x1))\n                    alpha = 2.0 - beta**-(eta + 1)\n                    if rand <= 1.0 / alpha:\n                        beta_q = (rand * alpha)**(1.0 / (eta + 1))\n                    else:\n                        beta_q = (1.0 / (2.0 - rand * alpha))**(1.0 / (eta + 1))\n\n                    c1 = 0.5 * ((x1 + x2) - beta_q * (x2 - x1))\n\n                    beta = 1.0 + (2.0 * (xu - x2) / (x2 - x1))\n                    alpha = 2.0 - beta**-(eta + 1)\n                    if rand <= 1.0 / alpha:\n                        beta_q = (rand * alpha)**(1.0 / (eta + 1))\n                    else:\n                        beta_q = (1.0 / (2.0 - rand * alpha))**(1.0 / (eta + 1))\n                    c2 = 0.5 * ((x1 + x2) + beta_q * (x2 - x1))\n\n                    c1 = np.clip(c1, xl, xu)\n                    c2 = np.clip(c2, xl, xu)\n\n                    if np.random.rand() <= 0.5:\n                        child1[i] = c2\n                        child2[i] = c1\n                    else:\n                        child1[i] = c1\n                        child2[i] = c2\n        return child1, child2\n\n    def polynomial_mutation(individual, eta_m=20):\n        mutant = np.copy(individual)\n        for i in range(N_P):\n            if np.random.rand() <= 1.0 / N_P:\n                xl = xlb[i]\n                xu = xub[i]\n                delta1 = (individual[i] - xl) / (xu - xl)\n                delta2 = (xu - individual[i]) / (xu - xl)\n                rand = np.random.rand()\n                mut_pow = 1.0 / (eta_m + 1.0)\n                if rand <= 0.5:\n                    delta_q = (2.0 * rand + (1.0 - 2.0 * rand) * (1.0 - delta1)**(eta_m + 1.0))**(mut_pow) - 1.0\n                else:\n                    delta_q = 1.0 - (2.0 * (1.0 - rand) + 2.0 * (rand - 0.5) * (1.0 - delta2)**(eta_m + 1.0))**(mut_pow)\n                mutant[i] = np.clip(individual[i] + delta_q * (xu - xl), xl, xu)\n        return mutant\n\n    def create_new_population(individuals):\n        new_population = []\n        for i in range(0, POP_SIZE, 2):\n            parent1 = individuals[np.random.randint(0, POP_SIZE)]\n            parent2 = individuals[np.random.randint(0, POP_SIZE)]\n            child1, child2 = sbx_crossover(parent1, parent2)\n            new_population.append(child1)\n            if len(new_population) < POP_SIZE:\n                new_population.append(child2)\n        return np.array(new_population)\n\n    def mutate_population(individuals):\n        mutated_population = []\n        for i in range(POP_SIZE):\n            mutated_individual = polynomial_mutation(individuals[i])\n            mutated_population.append(mutated_individual)\n        return np.array(mutated_population)\n\n    individuals = pops['individuals']\n    crossover_population = create_new_population(individuals)\n    mutated_population = mutate_population(crossover_population)\n    new_pops = np.clip(mutated_population, xlb, xub)\n\n    return new_pops",
          "objective": -0.53198,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, search_trajectory, xlb, xub, POP_SIZE, N_P, current_gen, max_gen):\n    import numpy as np\n\n    def crossover(parent1, parent2):\n        child = np.empty(N_P)\n        for i in range(N_P):\n            if np.random.rand() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutate(individual):\n        mutation_rate = 0.1 + (0.5 - 0.1) * current_gen / max_gen\n        for i in range(N_P):\n            if np.random.rand() < mutation_rate:\n                individual[i] += np.random.uniform(-1, 1) * (xub[i] - xlb[i]) * 0.1\n                individual[i] = np.clip(individual[i], xlb[i], xub[i])\n        return individual\n\n    def select_parents(ranked_individuals):\n        index1 = np.random.randint(POP_SIZE)\n        index2 = (index1 + np.random.randint(1, POP_SIZE)) % POP_SIZE\n        return ranked_individuals[index1], ranked_individuals[index2]\n\n    def create_new_population():\n        new_population = np.empty((POP_SIZE, N_P))\n        for i in range(POP_SIZE):\n            parent1, parent2 = select_parents(pops['individuals'])\n            child = crossover(parent1, parent2)\n            child = mutate(child)\n            new_population[i] = child\n        return new_population\n\n    new_pops = create_new_population()\n    return new_pops",
          "objective": -0.95647,
          "other_inf": null
     },
     {
          "algorithm": "A reproduction function that integrates tournament selection, simulated binary crossover (SBX), \n    Gaussian mutation, and search trajectory exploitation to generate the next population for \n    multi-objective optimization problems.",
          "code": "def next_generation(pops, search_trajectory, xlb, xub, POP_SIZE, N_P, current_gen, max_gen):\n    \"\"\"\n    {A reproduction function that integrates tournament selection, simulated binary crossover (SBX), \n    Gaussian mutation, and search trajectory exploitation to generate the next population for \n    multi-objective optimization problems.}\n    \"\"\"\n    import numpy as np\n\n    def tournament_selection(k=2):\n        best = None\n        for _ in range(k):\n            ind = np.random.randint(0, POP_SIZE)\n            if best is None or pops['rankings'][ind] < pops['rankings'][best]:\n                best = ind\n        return pops['individuals'][best]\n\n    def sbx_crossover(parent1, parent2, eta=2.0):\n        child1, child2 = np.copy(parent1), np.copy(parent2)\n        for i in range(N_P):\n            if np.random.rand() <= 0.5:\n                if abs(parent1[i] - parent2[i]) > 1e-14:\n                    x1 = min(parent1[i], parent2[i])\n                    x2 = max(parent1[i], parent2[i])\n                    beta = 1.0 + (2.0 * (x1 - xlb[i]) / (x2 - x1))\n                    alpha = 2.0 - beta**-(eta + 1)\n                    rand = np.random.rand()\n                    if rand <= 1.0 / alpha:\n                        beta_q = (rand * alpha)**(1.0 / (eta + 1))\n                    else:\n                        beta_q = (1.0 / (2.0 - rand * alpha))**(1.0 / (eta + 1))\n                    c1 = 0.5 * ((x1 + x2) - beta_q * (x2 - x1))\n                    \n                    beta = 1.0 + (2.0 * (xub[i] - x2) / (x2 - x1))\n                    alpha = 2.0 - beta**-(eta + 1)\n                    if rand <= 1.0 / alpha:\n                        beta_q = (rand * alpha)**(1.0 / (eta + 1))\n                    else:\n                        beta_q = (1.0 / (2.0 - rand * alpha))**(1.0 / (eta + 1))\n                    c2 = 0.5 * ((x1 + x2) + beta_q * (x2 - x1))\n                    \n                    c1 = np.clip(c1, xlb[i], xub[i])\n                    c2 = np.clip(c2, xlb[i], xub[i])\n                    \n                    if np.random.rand() <= 0.5:\n                        child1[i] = c2\n                        child2[i] = c1\n                    else:\n                        child1[i] = c1\n                        child2[i] = c2\n        return child1 if np.random.rand() <= 0.5 else child2\n\n    def gaussian_mutation(individual, mutation_prob=0.1):\n        for i in range(N_P):\n            if np.random.rand() < mutation_prob:\n                sigma = (xub[i] - xlb[i]) / 20.0\n                individual[i] += np.random.normal(0, sigma)\n                individual[i] = np.clip(individual[i], xlb[i], xub[i])\n        return individual\n\n    def exploit_search_trajectory():\n        if search_trajectory['individuals'] is not None and search_trajectory['rankings'] is not None:\n            best_idx = np.argmin(search_trajectory['rankings'])\n            return search_trajectory['individuals'][best_idx]\n        else:\n            return None\n\n    new_pops = np.zeros((POP_SIZE, N_P))\n    for i in range(POP_SIZE):\n        parent1 = tournament_selection()\n        if np.random.rand() < 0.9:  # High probability for crossover\n            parent2 = tournament_selection()\n            child = sbx_crossover(parent1, parent2)\n        else:\n            traj_ind = exploit_search_trajectory()\n            child = traj_ind if traj_ind is not None else parent1\n        child = gaussian_mutation(child)\n        new_pops[i, :] = child\n\n    return new_pops",
          "objective": -3.66608,
          "other_inf": null
     },
     {
          "algorithm": "A novel algorithm that integrates simulated annealing into the mutation process to adaptively control exploration and exploitation based on the current generation, alongside a crossover strategy that favors elite individuals.",
          "code": "def next_generation(pops, search_trajectory, xlb, xub, POP_SIZE, N_P, current_gen, max_gen):\n    \"\"\"\n    {A novel algorithm that integrates simulated annealing into the mutation process to adaptively control exploration and exploitation based on the current generation, alongside a crossover strategy that favors elite individuals.}\n    \"\"\"\n    import numpy as np\n\n    def simulated_annealing_mutation(individuals, current_gen, max_gen):\n        T_initial = 1.0\n        T_final = 0.01\n        T = T_initial * ((T_final / T_initial) ** (current_gen / max_gen))\n        new_individuals = np.empty_like(individuals)\n        for i in range(len(individuals)):\n            idxs = [idx for idx in range(len(individuals)) if idx != i]\n            a, b, c = individuals[np.random.choice(idxs, 3, replace=False)]\n            mutant = a + (b - c) * (T * np.random.randn(N_P))\n            mutant = np.clip(mutant, xlb, xub)\n            new_individuals[i] = mutant\n        return new_individuals\n\n    def elite_crossover(individuals, rankings):\n        CR = 0.7  # Crossover probability\n        elite = individuals[rankings.argmin()]\n        new_individuals = np.empty_like(individuals)\n        for i in range(len(individuals)):\n            cross_points = np.random.rand(N_P) < CR\n            trial = np.where(cross_points, individuals[i], elite)\n            new_individuals[i] = trial\n        return new_individuals\n\n    def create_new_population(individuals, rankings):\n        individuals = simulated_annealing_mutation(individuals, current_gen, max_gen)\n        individuals = elite_crossover(individuals, rankings)\n        return individuals\n\n    new_pops = create_new_population(pops['individuals'], pops['rankings'])\n    return new_pops",
          "objective": -4.12943,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm combines differential evolution with a local search heuristic to explore the search space effectively.",
          "code": "def next_generation(pops, search_trajectory, xlb, xub, POP_SIZE, N_P, current_gen, max_gen):\n    \"\"\"\n    {The new algorithm combines differential evolution with a local search heuristic to explore the search space effectively.}\n    \"\"\"\n    import numpy as np\n\n    def differential_evolution(individuals, F=0.8):\n        new_individuals = []\n        for i in range(len(individuals)):\n            idxs = [idx for idx in range(len(individuals)) if idx != i]\n            a, b, c = individuals[np.random.choice(idxs, 3, replace=False)]\n            mutant = np.clip(a + F * (b - c), xlb, xub)\n            new_individuals.append(mutant)\n        return np.array(new_individuals)\n\n    def local_search(individual, alpha=0.5):\n        search_direction = np.random.randn(N_P)\n        search_magnitude = (xub - xlb) * alpha * (max_gen - current_gen) / max_gen\n        return np.clip(individual + search_direction * search_magnitude, xlb, xub)\n\n    def blend_crossover(ind1, ind2, beta=0.5):\n        return beta * ind1 + (1 - beta) * ind2\n\n    def create_new_population(individuals):\n        new_population = differential_evolution(individuals)\n        for i in range(len(new_population)):\n            if np.random.rand() < 0.1:  # Local search with a small probability\n                new_population[i] = local_search(new_population[i])\n            if np.random.rand() < 0.5:  # Crossover with a certain probability\n                partner_idx = np.random.choice(len(individuals))\n                new_population[i] = blend_crossover(new_population[i], individuals[partner_idx])\n        return new_population\n\n    # Create the new population\n    new_pops = create_new_population(pops['individuals'])\n    \n    return new_pops",
          "objective": -7.12033,
          "other_inf": null
     },
     {
          "algorithm": "A new algorithm that employs differential evolution with adaptive mutation rates and heuristic crossover for enhanced exploration and exploitation balance.",
          "code": "def next_generation(pops, search_trajectory, xlb, xub, POP_SIZE, N_P, current_gen, max_gen):\n    \"\"\"\n    {A new algorithm that employs differential evolution with adaptive mutation rates and heuristic crossover for enhanced exploration and exploitation balance.}\n    \"\"\"\n    import numpy as np\n    \n    def adaptive_mutation_rate(current_gen, max_gen, min_rate=0.1, max_rate=0.9):\n        # Linearly decreasing mutation rate\n        return max_rate - (max_rate - min_rate) * (current_gen / max_gen)\n\n    def differential_mutation(individuals, F):\n        # Differential mutation strategy\n        idxs = np.random.choice(len(individuals), 3, replace=False)\n        x1, x2, x3 = individuals[idxs[0]], individuals[idxs[1]], individuals[idxs[2]]\n        mutant = x1 + F * (x2 - x3)\n        return np.clip(mutant, xlb, xub)\n\n    def heuristic_crossover(parent, donor):\n        # Heuristic crossover using the best individual and donor vector\n        child = np.where(np.random.rand(N_P) < 0.5, parent, donor)\n        return child\n\n    def create_new_population(individuals, rankings):\n        F = adaptive_mutation_rate(current_gen, max_gen)\n        best_individual = individuals[np.argmin(rankings)]\n        new_population = np.empty_like(individuals)\n        \n        for i in range(POP_SIZE):\n            donor = differential_mutation(individuals, F)\n            child = heuristic_crossover(best_individual, donor)\n            new_population[i] = child\n        \n        return new_population\n\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n    new_pops = create_new_population(individuals, rankings)\n    \n    return new_pops",
          "objective": -7.14166,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, search_trajectory, xlb, xub, POP_SIZE, N_P, current_gen, max_gen):\n    \"\"\"\n    This algorithm introduces a blending crossover along with adaptive mutation based on historical search trajectory and a cooling schedule for mutation intensity.\n    \"\"\"\n    import numpy as np\n    \n    def blending_crossover(parents):\n        alpha = 0.5  # blending ratio\n        new_individuals = np.empty_like(parents)\n        for i in range(len(parents)):\n            p1, p2 = np.random.choice(len(parents), 2, replace=False)\n            new_individuals[i] = alpha * parents[p1] + (1 - alpha) * parents[p2]\n        return new_individuals\n    \n    def adaptive_mutation(individuals, trajectory, current_gen, max_gen):\n        sigma_base = (xub - xlb) * 0.1\n        cooling_factor = (1 - (current_gen / max_gen))**2\n        sigma = sigma_base * cooling_factor\n        for i in range(len(individuals)):\n            if trajectory['individuals'] is not None and len(trajectory['individuals']) > 0:\n                historical_individual = trajectory['individuals'][np.random.randint(0, len(trajectory['individuals']))]\n                individuals[i] += np.random.normal(0, sigma) * (historical_individual - individuals[i])\n            individuals[i] = np.clip(individuals[i], xlb, xub)\n        return individuals\n    \n    def create_new_population(individuals):\n        quarter_pop_size = POP_SIZE // 4\n        crossover_individuals = blending_crossover(individuals[:quarter_pop_size])\n        mutated_individuals = adaptive_mutation(individuals[quarter_pop_size:], search_trajectory, current_gen, max_gen)\n        return np.vstack((crossover_individuals, mutated_individuals, individuals[quarter_pop_size:]))\n    \n    def validate_population(individuals):\n        return np.clip(individuals, xlb, xub)\n    \n    individuals = pops['individuals']\n    new_individuals = create_new_population(individuals)\n    new_pops = validate_population(new_individuals)\n    \n    return new_pops",
          "objective": -7.58174,
          "other_inf": null
     },
     {
          "algorithm": "A novel reproduction function that integrates an adaptive mutation strategy with an elitism-based crossover to enhance diversity and convergence.",
          "code": "def next_generation(pops, search_trajectory, xlb, xub, POP_SIZE, N_P, current_gen, max_gen):\n    \"\"\"\n    {A novel reproduction function that integrates an adaptive mutation strategy with an elitism-based crossover to enhance diversity and convergence.}\n    \"\"\"\n    import numpy as np\n\n    def adaptive_mutation(individuals):\n        # Mutation rate decreases over generations\n        mutation_rate = 0.1 * (1 - current_gen / max_gen)\n        mutation_scale = (xub - xlb) * mutation_rate\n        for i in range(len(individuals)):\n            mutation_vector = np.random.randn(N_P) * mutation_scale\n            individuals[i] = np.clip(individuals[i] + mutation_vector, xlb, xub)\n        return individuals\n\n    def elitism_based_crossover(parents):\n        new_individuals = np.empty_like(parents)\n        elite_size = int(0.1 * POP_SIZE)\n        elites = parents[:elite_size]\n        for i in range(POP_SIZE):\n            parent1 = elites[np.random.randint(0, elite_size)]\n            parent2 = parents[np.random.randint(0, POP_SIZE)]\n            crossover_point = np.random.randint(1, N_P)\n            child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n            new_individuals[i] = child\n        return new_individuals\n\n    def create_new_population(individuals):\n        mutated_individuals = adaptive_mutation(individuals)\n        new_individuals = elitism_based_crossover(mutated_individuals)\n        return new_individuals\n\n    def validate_population(individuals):\n        return np.clip(individuals, xlb, xub)\n\n    new_individuals = create_new_population(pops['individuals'])\n    new_pops = validate_population(new_individuals)\n\n    return new_pops",
          "objective": -10.46098,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, search_trajectory, xlb, xub, POP_SIZE, N_P, current_gen, max_gen):\n    import numpy as np\n\n    def mutate(individual, mutation_rate, xlb, xub):\n        if np.random.rand() < mutation_rate:\n            mutation_vector = np.random.uniform(-1, 1, individual.shape) * (xub - xlb)\n            new_individual = individual + mutation_vector\n            new_individual = np.clip(new_individual, xlb, xub)\n        else:\n            new_individual = individual\n        return new_individual\n\n    def crossover(parent1, parent2, crossover_rate):\n        if np.random.rand() < crossover_rate:\n            crossover_point = np.random.randint(0, N_P)\n            child1 = np.concatenate([parent1[:crossover_point], parent2[crossover_point:]])\n            child2 = np.concatenate([parent2[:crossover_point], parent1[crossover_point:]])\n            return child1, child2\n        else:\n            return parent1, parent2\n\n    def select_parents(population, rankings):\n        prob = 1 / (1 + rankings)\n        prob /= prob.sum()\n        idx = np.random.choice(np.arange(POP_SIZE), size=2, replace=False, p=prob)\n        return population[idx[0]], population[idx[1]]\n\n    def create_new_population(pops, POP_SIZE, N_P, xlb, xub, current_gen, max_gen):\n        new_population = np.empty((POP_SIZE, N_P))\n        mutation_rate = max(0.1, 1 - current_gen / max_gen)\n        crossover_rate = max(0.5, 1 - current_gen / max_gen)\n        \n        for i in range(0, POP_SIZE, 2):\n            parent1, parent2 = select_parents(pops['individuals'], pops['rankings'])\n            child1, child2 = crossover(parent1, parent2, crossover_rate)\n            child1 = mutate(child1, mutation_rate, xlb, xub)\n            child2 = mutate(child2, mutation_rate, xlb, xub)\n            new_population[i] = child1\n            if i + 1 < POP_SIZE:\n                new_population[i + 1] = child2\n\n        return new_population\n\n    new_pops = create_new_population(pops, POP_SIZE, N_P, xlb, xub, current_gen, max_gen)\n    return new_pops",
          "objective": -19.35809,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, search_trajectory, xlb, xub, POP_SIZE, N_P, current_gen, max_gen):\n    \"\"\"\n    A novel reproduction function that uses a blend of adaptive differential evolution and historical elite-guided mutation to generate the next population.\n    \"\"\"\n    import numpy as np\n\n    def adaptive_differential_evolution(individuals, rankings):\n        CR = 0.9  # Crossover probability\n        F_min, F_max = 0.5, 1.0  # Differential weight range\n        new_individuals = np.empty_like(individuals)\n        for i in range(len(individuals)):\n            idxs = [idx for idx in range(len(individuals)) if idx != i]\n            a, b, c = individuals[np.random.choice(idxs, 3, replace=False)]\n            F = F_min + (rankings[i] / (POP_SIZE - 1)) * (F_max - F_min)\n            mutant = np.clip(a + F * (b - c), xlb, xub)\n            cross_points = np.random.rand(N_P) < CR\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, N_P)] = True\n            trial = np.where(cross_points, mutant, individuals[i])\n            new_individuals[i] = trial\n        return new_individuals\n\n    def historical_elite_guided_mutation(individuals, trajectory, rankings):\n        sigma = (xub - xlb) * (1 - (current_gen / max_gen))**2\n        for i in range(len(individuals)):\n            if trajectory['individuals'] is not None and len(trajectory['individuals']) > 0:\n                elite_individuals = trajectory['individuals'][np.argsort(trajectory['rankings'])[:len(individuals)//5]]\n                historical_individual = elite_individuals[np.random.randint(0, len(elite_individuals))]\n                individuals[i] += np.random.normal(0, sigma) * (historical_individual - individuals[i])\n            individuals[i] = np.clip(individuals[i], xlb, xub)\n        return individuals\n\n    def create_new_population(individuals, rankings):\n        half_pop_size = POP_SIZE // 2\n        new_individuals = adaptive_differential_evolution(individuals[:half_pop_size], rankings[:half_pop_size])\n        mutated_individuals = historical_elite_guided_mutation(individuals[half_pop_size:], search_trajectory, rankings[half_pop_size:])\n        return np.vstack((new_individuals, mutated_individuals))\n\n    def validate_population(individuals):\n        return np.clip(individuals, xlb, xub)\n\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n    new_individuals = create_new_population(individuals, rankings)\n    new_pops = validate_population(new_individuals)\n\n    return new_pops",
          "objective": -20.0286,
          "other_inf": null
     }
]