[
     {
          "algorithm": "A reproduction function that uses simulated binary crossover and Gaussian mutation with an adaptive mutation rate, \n    influenced by the generation count and the individual's ranking.",
          "code": "def next_generation(pops, search_trajectory, xlb, xub, POP_SIZE, N_P, current_gen, max_gen):\n    \"\"\"\n    {A reproduction function that uses simulated binary crossover and Gaussian mutation with an adaptive mutation rate, \n    influenced by the generation count and the individual's ranking.}\n    \"\"\"\n    import numpy as np\n\n    def simulated_binary_crossover(parent1, parent2, eta_c=15):\n        child1, child2 = np.copy(parent1), np.copy(parent2)\n        for i in range(N_P):\n            if np.random.rand() <= 0.5:\n                if abs(parent1[i] - parent2[i]) > 1e-14:\n                    x1 = min(parent1[i], parent2[i])\n                    x2 = max(parent1[i], parent2[i])\n                    rand = np.random.rand()\n                    beta = 1.0 + (2.0 * (x1 - xlb[i]) / (x2 - x1))\n                    alpha = 2.0 - beta**-(eta_c + 1)\n                    betaq = 0\n                    if rand <= (1.0 / alpha):\n                        betaq = (rand * alpha)**(1.0 / (eta_c + 1))\n                    else:\n                        betaq = (1.0 / (2.0 - rand * alpha))**(1.0 / (eta_c + 1))\n                    child1[i] = 0.5 * ((x1 + x2) - betaq * (x2 - x1))\n                    \n                    beta = 1.0 + (2.0 * (xub[i] - x2) / (x2 - x1))\n                    alpha = 2.0 - beta**-(eta_c + 1)\n                    if rand <= (1.0 / alpha):\n                        betaq = (rand * alpha)**(1.0 / (eta_c + 1))\n                    else:\n                        betaq = (1.0 / (2.0 - rand * alpha))**(1.0 / (eta_c + 1))\n                    child2[i] = 0.5 * ((x1 + x2) + betaq * (x2 - x1))\n\n                    child1[i] = np.clip(child1[i], xlb[i], xub[i])\n                    child2[i] = np.clip(child2[i], xlb[i], xub[i])\n        return child1, child2\n\n    def gaussian_mutation(individual, rank, mutation_rate=0.1):\n        if rank < POP_SIZE // 2:  # Higher ranked individuals have a lower mutation rate\n            mutation_rate *= (1 - (current_gen / max_gen))\n        for i in range(N_P):\n            if np.random.rand() < mutation_rate:\n                individual[i] += np.random.normal(0, (xub[i] - xlb[i]) / 10)\n                individual[i] = np.clip(individual[i], xlb[i], xub[i])\n        return individual\n\n    new_pops = np.zeros((POP_SIZE, N_P))\n    for i in range(0, POP_SIZE, 2):\n        parent1_idx = i\n        parent2_idx = (i + 1) if (i + 1) < POP_SIZE else 0\n        parent1 = pops['individuals'][parent1_idx]\n        parent2 = pops['individuals'][parent2_idx]\n        child1, child2 = simulated_binary_crossover(parent1, parent2)\n        child1 = gaussian_mutation(child1, pops['rankings'][parent1_idx])\n        child2 = gaussian_mutation(child2, pops['rankings'][parent2_idx])\n        new_pops[i] = child1\n        if (i + 1) < POP_SIZE:\n            new_pops[i + 1] = child2\n\n    return new_pops",
          "objective": 0.68393,
          "other_inf": null
     },
     {
          "algorithm": "A reproduction function that combines rank-based roulette wheel selection, uniform crossover, and dynamic mutation rate adjustment with an optional elitism strategy to generate the next population.",
          "code": "def next_generation(pops, search_trajectory, xlb, xub, POP_SIZE, N_P, current_gen, max_gen):\n    \"\"\"\n    {A reproduction function that combines rank-based roulette wheel selection, uniform crossover, and dynamic mutation rate adjustment with an optional elitism strategy to generate the next population.}\n    \"\"\"\n    import numpy as np\n    \n    def roulette_wheel_selection(rankings):\n        max_rank = np.max(rankings)\n        selection_prob = (max_rank + 1 - rankings) / np.sum(max_rank + 1 - rankings)\n        selected_index = np.random.choice(np.arange(POP_SIZE), p=selection_prob)\n        return pops['individuals'][selected_index]\n\n    def uniform_crossover(parent1, parent2):\n        child = np.where(np.random.rand(N_P) < 0.5, parent1, parent2)\n        return child\n\n    def dynamic_mutation(individual, current_gen, max_gen):\n        mutation_rate = 0.1 * (1 - (current_gen / max_gen))\n        mutation_vector = np.random.rand(N_P) < mutation_rate\n        mutation_amount = np.random.normal(0, (xub - xlb) / 20.0, N_P)\n        individual = np.where(mutation_vector, individual + mutation_amount, individual)\n        return np.clip(individual, xlb, xub)\n\n    def elitism_strategy(elite_size=2):\n        elite_individuals = pops['individuals'][:elite_size]\n        return elite_individuals\n\n    new_pops = np.empty((POP_SIZE, N_P))\n    elite_individuals = elitism_strategy()\n    new_pops[:len(elite_individuals)] = elite_individuals\n\n    for i in range(len(elite_individuals), POP_SIZE):\n        parent1 = roulette_wheel_selection(pops['rankings'])\n        parent2 = roulette_wheel_selection(pops['rankings'])\n        child = uniform_crossover(parent1, parent2)\n        child = dynamic_mutation(child, current_gen, max_gen)\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.59486,
          "other_inf": null
     },
     {
          "algorithm": "A novel algorithm that utilizes a blend of rank-based selection, Gaussian mutation, and uniform crossover to promote diversity and convergence.",
          "code": "def next_generation(pops, search_trajectory, xlb, xub, POP_SIZE, N_P, current_gen, max_gen):\n    \"\"\"\n    {A novel algorithm that utilizes a blend of rank-based selection, Gaussian mutation, and uniform crossover to promote diversity and convergence.}\n    \"\"\"\n    import numpy as np\n\n    # Rank-based selection function\n    def rank_based_selection(individuals, rankings):\n        probabilities = 1 / (rankings + 1)\n        probabilities /= probabilities.sum()\n        selected_index = np.random.choice(len(individuals), p=probabilities)\n        return individuals[selected_index]\n\n    # Gaussian mutation function\n    def gaussian_mutation(individual, mutation_rate=0.1, sigma=0.1):\n        mutant = np.copy(individual)\n        for i in range(len(individual)):\n            if np.random.rand() < mutation_rate:\n                mutant[i] += np.random.normal(0, sigma)\n                mutant[i] = np.clip(mutant[i], xlb[i], xub[i])\n        return mutant\n\n    # Uniform crossover function\n    def uniform_crossover(parent1, parent2):\n        child = np.copy(parent1)\n        for i in range(N_P):\n            if np.random.rand() < 0.5:\n                child[i] = parent2[i]\n        return child\n\n    # Create new population function\n    def create_new_population(individuals, rankings):\n        new_population = np.empty_like(individuals)\n        for i in range(POP_SIZE):\n            parent1 = rank_based_selection(individuals, rankings)\n            parent2 = rank_based_selection(individuals, rankings)\n            child = uniform_crossover(parent1, parent2)\n            new_population[i] = gaussian_mutation(child)\n        return new_population\n\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n    new_pops = create_new_population(individuals, rankings)\n\n    return new_pops",
          "objective": 0.02511,
          "other_inf": null
     },
     {
          "algorithm": "A new algorithm that uses rank-based roulette wheel selection, differential evolution crossover, \n    and adaptive mutation rate based on generation count to ensure diversity and convergence.",
          "code": "def next_generation(pops, search_trajectory, xlb, xub, POP_SIZE, N_P, current_gen, max_gen):\n    \"\"\"\n    {A new algorithm that uses rank-based roulette wheel selection, differential evolution crossover, \n    and adaptive mutation rate based on generation count to ensure diversity and convergence.}\n    \"\"\"\n    import numpy as np\n\n    def roulette_wheel_selection(rankings):\n        max_rank = np.max(rankings)\n        selection_probs = (max_rank - rankings + 1) / np.sum(max_rank - rankings + 1)\n        selected_index = np.random.choice(np.arange(POP_SIZE), p=selection_probs)\n        return pops['individuals'][selected_index]\n\n    def differential_evolution_crossover(target, a, b, c, cr=0.5):\n        trial = np.copy(target)\n        j_rand = np.random.randint(N_P)\n        for j in range(N_P):\n            if np.random.rand() < cr or j == j_rand:\n                trial[j] = a[j] + 0.5 * (b[j] - c[j])\n                trial[j] = np.clip(trial[j], xlb[j], xub[j])\n        return trial\n\n    def adaptive_mutation(individual, gen_count, max_gen_count, mutation_scale=0.1):\n        mutation_rate = mutation_scale * (1 - gen_count / max_gen_count)\n        for i in range(N_P):\n            if np.random.rand() < mutation_rate:\n                delta = (xub[i] - xlb[i]) * (np.random.rand() - 0.5) * 2\n                individual[i] += delta\n                individual[i] = np.clip(individual[i], xlb[i], xub[i])\n        return individual\n\n    new_pops = np.zeros((POP_SIZE, N_P))\n    for i in range(POP_SIZE):\n        target = pops['individuals'][i]\n        a = roulette_wheel_selection(pops['rankings'])\n        b = roulette_wheel_selection(pops['rankings'])\n        c = roulette_wheel_selection(pops['rankings'])\n\n        trial = differential_evolution_crossover(target, a, b, c)\n        trial = adaptive_mutation(trial, current_gen, max_gen)\n        new_pops[i, :] = trial\n\n    return new_pops",
          "objective": -0.00621,
          "other_inf": null
     },
     {
          "algorithm": "A reproduction function that combines rank-based selection, uniform crossover, adaptive mutation, and historical population guidance to generate the next population.",
          "code": "def next_generation(pops, search_trajectory, xlb, xub, POP_SIZE, N_P, current_gen, max_gen):\n    \"\"\"\n    {A reproduction function that combines rank-based selection, uniform crossover, adaptive mutation, and historical population guidance to generate the next population.}\n    \"\"\"\n    import numpy as np\n\n    def rank_based_selection():\n        cumulative_rankings = np.cumsum(1 / (1 + np.arange(POP_SIZE)))\n        selection_prob = cumulative_rankings / cumulative_rankings[-1]\n        selected_index = np.searchsorted(selection_prob, np.random.rand())\n        return pops['individuals'][selected_index]\n\n    def uniform_crossover(parent1, parent2):\n        mask = np.random.rand(N_P) < 0.5\n        child = np.where(mask, parent1, parent2)\n        return child\n\n    def adaptive_mutation(individual, gen_factor):\n        for i in range(N_P):\n            if np.random.rand() < gen_factor:\n                mutation_range = gen_factor * (xub[i] - xlb[i])\n                individual[i] += np.random.uniform(-mutation_range, mutation_range)\n                individual[i] = np.clip(individual[i], xlb[i], xub[i])\n        return individual\n\n    def historical_population_guidance():\n        if search_trajectory['individuals'] is not None:\n            historical_best_idx = np.argmin(search_trajectory['rankings'])\n            return search_trajectory['individuals'][historical_best_idx]\n        else:\n            return None\n\n    gen_factor = (1 - current_gen / max_gen) ** 2  # Adaptive factor decreasing over generations\n    new_pops = np.zeros((POP_SIZE, N_P))\n\n    for i in range(POP_SIZE):\n        parent1 = rank_based_selection()\n        if np.random.rand() < 0.8:  # Probability for crossover\n            parent2 = rank_based_selection()\n            child = uniform_crossover(parent1, parent2)\n        else:\n            historical_best = historical_population_guidance()\n            child = historical_best if historical_best is not None else parent1\n        child = adaptive_mutation(child, gen_factor)\n        new_pops[i, :] = child\n\n    return new_pops",
          "objective": -0.14273,
          "other_inf": null
     },
     {
          "algorithm": "A novel reproduction function that combines simulated binary crossover and polynomial mutation to generate the next population.",
          "code": "def next_generation(pops, search_trajectory, xlb, xub, POP_SIZE, N_P, current_gen, max_gen):\n    \"\"\"\n    {A novel reproduction function that combines simulated binary crossover and polynomial mutation to generate the next population.}\n    \"\"\"\n    import numpy as np\n\n    def sbx_crossover(parent1, parent2, eta=30):\n        child1, child2 = np.copy(parent1), np.copy(parent2)\n        for i in range(N_P):\n            if np.random.rand() <= 0.5:\n                if abs(parent1[i] - parent2[i]) > 1e-14:\n                    x1 = min(parent1[i], parent2[i])\n                    x2 = max(parent1[i], parent2[i])\n                    xl = xlb[i]\n                    xu = xub[i]\n                    rand = np.random.rand()\n\n                    beta = 1.0 + (2.0 * (x1 - xl) / (x2 - x1))\n                    alpha = 2.0 - beta**-(eta + 1)\n                    if rand <= 1.0 / alpha:\n                        beta_q = (rand * alpha)**(1.0 / (eta + 1))\n                    else:\n                        beta_q = (1.0 / (2.0 - rand * alpha))**(1.0 / (eta + 1))\n\n                    c1 = 0.5 * ((x1 + x2) - beta_q * (x2 - x1))\n\n                    beta = 1.0 + (2.0 * (xu - x2) / (x2 - x1))\n                    alpha = 2.0 - beta**-(eta + 1)\n                    if rand <= 1.0 / alpha:\n                        beta_q = (rand * alpha)**(1.0 / (eta + 1))\n                    else:\n                        beta_q = (1.0 / (2.0 - rand * alpha))**(1.0 / (eta + 1))\n                    c2 = 0.5 * ((x1 + x2) + beta_q * (x2 - x1))\n\n                    c1 = np.clip(c1, xl, xu)\n                    c2 = np.clip(c2, xl, xu)\n\n                    if np.random.rand() <= 0.5:\n                        child1[i] = c2\n                        child2[i] = c1\n                    else:\n                        child1[i] = c1\n                        child2[i] = c2\n        return child1, child2\n\n    def polynomial_mutation(individual, eta_m=20):\n        mutant = np.copy(individual)\n        for i in range(N_P):\n            if np.random.rand() <= 1.0 / N_P:\n                xl = xlb[i]\n                xu = xub[i]\n                delta1 = (individual[i] - xl) / (xu - xl)\n                delta2 = (xu - individual[i]) / (xu - xl)\n                rand = np.random.rand()\n                mut_pow = 1.0 / (eta_m + 1.0)\n                if rand <= 0.5:\n                    delta_q = (2.0 * rand + (1.0 - 2.0 * rand) * (1.0 - delta1)**(eta_m + 1.0))**(mut_pow) - 1.0\n                else:\n                    delta_q = 1.0 - (2.0 * (1.0 - rand) + 2.0 * (rand - 0.5) * (1.0 - delta2)**(eta_m + 1.0))**(mut_pow)\n                mutant[i] = np.clip(individual[i] + delta_q * (xu - xl), xl, xu)\n        return mutant\n\n    def create_new_population(individuals):\n        new_population = []\n        for i in range(0, POP_SIZE, 2):\n            parent1 = individuals[np.random.randint(0, POP_SIZE)]\n            parent2 = individuals[np.random.randint(0, POP_SIZE)]\n            child1, child2 = sbx_crossover(parent1, parent2)\n            new_population.append(child1)\n            if len(new_population) < POP_SIZE:\n                new_population.append(child2)\n        return np.array(new_population)\n\n    def mutate_population(individuals):\n        mutated_population = []\n        for i in range(POP_SIZE):\n            mutated_individual = polynomial_mutation(individuals[i])\n            mutated_population.append(mutated_individual)\n        return np.array(mutated_population)\n\n    individuals = pops['individuals']\n    crossover_population = create_new_population(individuals)\n    mutated_population = mutate_population(crossover_population)\n    new_pops = np.clip(mutated_population, xlb, xub)\n\n    return new_pops",
          "objective": -0.53198,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, search_trajectory, xlb, xub, POP_SIZE, N_P, current_gen, max_gen):\n    import numpy as np\n\n    def crossover(parent1, parent2):\n        child = np.empty(N_P)\n        for i in range(N_P):\n            if np.random.rand() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutate(individual):\n        mutation_rate = 0.1 + (0.5 - 0.1) * current_gen / max_gen\n        for i in range(N_P):\n            if np.random.rand() < mutation_rate:\n                individual[i] += np.random.uniform(-1, 1) * (xub[i] - xlb[i]) * 0.1\n                individual[i] = np.clip(individual[i], xlb[i], xub[i])\n        return individual\n\n    def select_parents(ranked_individuals):\n        index1 = np.random.randint(POP_SIZE)\n        index2 = (index1 + np.random.randint(1, POP_SIZE)) % POP_SIZE\n        return ranked_individuals[index1], ranked_individuals[index2]\n\n    def create_new_population():\n        new_population = np.empty((POP_SIZE, N_P))\n        for i in range(POP_SIZE):\n            parent1, parent2 = select_parents(pops['individuals'])\n            child = crossover(parent1, parent2)\n            child = mutate(child)\n            new_population[i] = child\n        return new_population\n\n    new_pops = create_new_population()\n    return new_pops",
          "objective": -0.95647,
          "other_inf": null
     },
     {
          "algorithm": "A novel algorithm that combines tournament selection with polynomial mutation and simulated binary crossover (SBX) to maintain diversity and convergence.",
          "code": "def next_generation(pops, search_trajectory, xlb, xub, POP_SIZE, N_P, current_gen, max_gen):\n    \"\"\"\n    {A novel algorithm that combines tournament selection with polynomial mutation and simulated binary crossover (SBX) to maintain diversity and convergence.}\n    \"\"\"\n    import numpy as np\n\n    def tournament_selection(individuals, rankings, tournament_size=2):\n        selected = []\n        for _ in range(tournament_size):\n            i, j = np.random.randint(0, len(individuals), 2)\n            selected.append(i if rankings[i] < rankings[j] else j)\n        return individuals[min(selected, key=lambda x: rankings[x])]\n\n    def polynomial_mutation(individual, eta=20):\n        mutant = np.copy(individual)\n        for i in range(len(individual)):\n            if np.random.rand() < 1.0 / N_P:\n                u = np.random.rand()\n                delta = min((individual[i] - xlb[i]) / (xub[i] - xlb[i]), (xub[i] - individual[i]) / (xub[i] - xlb[i]))\n                if u <= 0.5:\n                    delta_q = (2 * u + (1 - 2 * u) * (1 - delta)**(eta + 1))**(1 / (eta + 1)) - 1\n                else:\n                    delta_q = 1 - (2 * (1 - u) + 2 * (u - 0.5) * (1 - delta)**(eta + 1))**(1 / (eta + 1))\n                mutant[i] = individual[i] + delta_q * (xub[i] - xlb[i])\n                mutant[i] = np.clip(mutant[i], xlb[i], xub[i])\n        return mutant\n\n    def sbx_crossover(parent1, parent2, eta=15):\n        child1, child2 = np.copy(parent1), np.copy(parent2)\n        for i in range(N_P):\n            if np.random.rand() <= 0.9:\n                if abs(parent1[i] - parent2[i]) > 1e-14:\n                    x1 = min(parent1[i], parent2[i])\n                    x2 = max(parent1[i], parent2[i])\n                    xl = xlb[i]\n                    xu = xub[i]\n                    beta = 1.0 + (2.0 * (x1 - xl) / (x2 - x1))\n                    alpha = 2.0 - beta**-(eta + 1)\n                    rand = np.random.rand()\n                    if rand <= 1.0 / alpha:\n                        beta_q = (rand * alpha)**(1.0 / (eta + 1))\n                    else:\n                        beta_q = (1.0 / (2.0 - rand * alpha))**(1.0 / (eta + 1))\n                    c1 = 0.5 * ((x1 + x2) - beta_q * (x2 - x1))\n\n                    beta = 1.0 + (2.0 * (xu - x2) / (x2 - x1))\n                    alpha = 2.0 - beta**-(eta + 1)\n                    if rand <= 1.0 / alpha:\n                        beta_q = (rand * alpha)**(1.0 / (eta + 1))\n                    else:\n                        beta_q = (1.0 / (2.0 - rand * alpha))**(1.0 / (eta + 1))\n                    c2 = 0.5 * ((x1 + x2) + beta_q * (x2 - x1))\n\n                    c1 = np.clip(c1, xl, xu)\n                    c2 = np.clip(c2, xl, xu)\n\n                    if np.random.rand() <= 0.5:\n                        child1[i] = c2\n                        child2[i] = c1\n                    else:\n                        child1[i] = c1\n                        child2[i] = c2\n        return (child1, child2)\n\n    def create_new_population(individuals, rankings):\n        new_population = np.empty_like(individuals)\n        for i in range(0, POP_SIZE, 2):\n            parent1 = tournament_selection(individuals, rankings)\n            parent2 = tournament_selection(individuals, rankings)\n            child1, child2 = sbx_crossover(parent1, parent2)\n            new_population[i] = polynomial_mutation(child1)\n            if i + 1 < POP_SIZE:\n                new_population[i + 1] = polynomial_mutation(child2)\n        return new_population\n\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n    new_pops = create_new_population(individuals, rankings)\n\n    return new_pops",
          "objective": -2.02579,
          "other_inf": null
     },
     {
          "algorithm": "A reproduction function that uses tournament selection, simulated binary crossover (SBX), Gaussian mutation, \n    and top-ranking elite preservation to generate the next population for multi-objective optimization problems.",
          "code": "def next_generation(pops, search_trajectory, xlb, xub, POP_SIZE, N_P, current_gen, max_gen):\n    \"\"\"\n    {A reproduction function that uses tournament selection, simulated binary crossover (SBX), Gaussian mutation, \n    and top-ranking elite preservation to generate the next population for multi-objective optimization problems.}\n    \"\"\"\n    import numpy as np\n\n    def tournament_selection(k=2):\n        best = None\n        for _ in range(k):\n            i = np.random.randint(0, POP_SIZE)\n            if best is None or pops['rankings'][i] < pops['rankings'][best]:\n                best = i\n        return pops['individuals'][best]\n\n    def sbx_crossover(parent1, parent2, eta=2.0):\n        child1, child2 = np.copy(parent1), np.copy(parent2)\n        for i in range(N_P):\n            if np.random.rand() <= 0.5:\n                if abs(parent1[i] - parent2[i]) > 1e-14:\n                    x1 = min(parent1[i], parent2[i])\n                    x2 = max(parent1[i], parent2[i])\n                    rand = np.random.rand()\n                    beta = 1.0 + (2.0 * (x1 - xlb[i]) / (x2 - x1))\n                    alpha = 2.0 - beta**-(eta + 1)\n                    if rand <= 1.0 / alpha:\n                        beta_q = (rand * alpha)**(1.0 / (eta + 1))\n                    else:\n                        beta_q = (1.0 / (2.0 - rand * alpha))**(1.0 / (eta + 1))\n                    c1 = 0.5 * ((x1 + x2) - beta_q * (x2 - x1))\n\n                    beta = 1.0 + (2.0 * (xub[i] - x2) / (x2 - x1))\n                    alpha = 2.0 - beta**-(eta + 1)\n                    if rand <= 1.0 / alpha:\n                        beta_q = (rand * alpha)**(1.0 / (eta + 1))\n                    else:\n                        beta_q = (1.0 / (2.0 - rand * alpha))**(1.0 / (eta + 1))\n                    c2 = 0.5 * ((x1 + x2) + beta_q * (x2 - x1))\n\n                    c1 = np.clip(c1, xlb[i], xub[i])\n                    c2 = np.clip(c2, xlb[i], xub[i])\n\n                    if np.random.rand() <= 0.5:\n                        child1[i] = c2\n                        child2[i] = c1\n                    else:\n                        child1[i] = c1\n                        child2[i] = c2\n        return child1 if np.random.rand() < 0.5 else child2\n\n    def gaussian_mutation(individual, sigma=0.1):\n        for i in range(N_P):\n            if np.random.rand() < 0.1:\n                individual[i] += np.random.normal(0, sigma * (xub[i] - xlb[i]))\n                individual[i] = np.clip(individual[i], xlb[i], xub[i])\n        return individual\n\n    def preserve_top_ranking_elites():\n        elite_count = max(2, int(POP_SIZE * 0.1))  # Preserve top 10% or at least two elites\n        return pops['individuals'][:elite_count]\n\n    new_pops = np.zeros((POP_SIZE, N_P))\n    elites = preserve_top_ranking_elites()\n\n    for i in range(POP_SIZE - len(elites)):\n        parent1 = tournament_selection()\n        parent2 = tournament_selection()\n        child = sbx_crossover(parent1, parent2)\n        child = gaussian_mutation(child)\n        new_pops[i, :] = child\n\n    # Fill the rest of the new population with elites\n    new_pops[-len(elites):, :] = elites\n\n    return new_pops",
          "objective": -2.72321,
          "other_inf": null
     },
     {
          "algorithm": "A reproduction function that integrates tournament selection, simulated binary crossover (SBX), \n    Gaussian mutation, and search trajectory exploitation to generate the next population for \n    multi-objective optimization problems.",
          "code": "def next_generation(pops, search_trajectory, xlb, xub, POP_SIZE, N_P, current_gen, max_gen):\n    \"\"\"\n    {A reproduction function that integrates tournament selection, simulated binary crossover (SBX), \n    Gaussian mutation, and search trajectory exploitation to generate the next population for \n    multi-objective optimization problems.}\n    \"\"\"\n    import numpy as np\n\n    def tournament_selection(k=2):\n        best = None\n        for _ in range(k):\n            ind = np.random.randint(0, POP_SIZE)\n            if best is None or pops['rankings'][ind] < pops['rankings'][best]:\n                best = ind\n        return pops['individuals'][best]\n\n    def sbx_crossover(parent1, parent2, eta=2.0):\n        child1, child2 = np.copy(parent1), np.copy(parent2)\n        for i in range(N_P):\n            if np.random.rand() <= 0.5:\n                if abs(parent1[i] - parent2[i]) > 1e-14:\n                    x1 = min(parent1[i], parent2[i])\n                    x2 = max(parent1[i], parent2[i])\n                    beta = 1.0 + (2.0 * (x1 - xlb[i]) / (x2 - x1))\n                    alpha = 2.0 - beta**-(eta + 1)\n                    rand = np.random.rand()\n                    if rand <= 1.0 / alpha:\n                        beta_q = (rand * alpha)**(1.0 / (eta + 1))\n                    else:\n                        beta_q = (1.0 / (2.0 - rand * alpha))**(1.0 / (eta + 1))\n                    c1 = 0.5 * ((x1 + x2) - beta_q * (x2 - x1))\n                    \n                    beta = 1.0 + (2.0 * (xub[i] - x2) / (x2 - x1))\n                    alpha = 2.0 - beta**-(eta + 1)\n                    if rand <= 1.0 / alpha:\n                        beta_q = (rand * alpha)**(1.0 / (eta + 1))\n                    else:\n                        beta_q = (1.0 / (2.0 - rand * alpha))**(1.0 / (eta + 1))\n                    c2 = 0.5 * ((x1 + x2) + beta_q * (x2 - x1))\n                    \n                    c1 = np.clip(c1, xlb[i], xub[i])\n                    c2 = np.clip(c2, xlb[i], xub[i])\n                    \n                    if np.random.rand() <= 0.5:\n                        child1[i] = c2\n                        child2[i] = c1\n                    else:\n                        child1[i] = c1\n                        child2[i] = c2\n        return child1 if np.random.rand() <= 0.5 else child2\n\n    def gaussian_mutation(individual, mutation_prob=0.1):\n        for i in range(N_P):\n            if np.random.rand() < mutation_prob:\n                sigma = (xub[i] - xlb[i]) / 20.0\n                individual[i] += np.random.normal(0, sigma)\n                individual[i] = np.clip(individual[i], xlb[i], xub[i])\n        return individual\n\n    def exploit_search_trajectory():\n        if search_trajectory['individuals'] is not None and search_trajectory['rankings'] is not None:\n            best_idx = np.argmin(search_trajectory['rankings'])\n            return search_trajectory['individuals'][best_idx]\n        else:\n            return None\n\n    new_pops = np.zeros((POP_SIZE, N_P))\n    for i in range(POP_SIZE):\n        parent1 = tournament_selection()\n        if np.random.rand() < 0.9:  # High probability for crossover\n            parent2 = tournament_selection()\n            child = sbx_crossover(parent1, parent2)\n        else:\n            traj_ind = exploit_search_trajectory()\n            child = traj_ind if traj_ind is not None else parent1\n        child = gaussian_mutation(child)\n        new_pops[i, :] = child\n\n    return new_pops",
          "objective": -3.66608,
          "other_inf": null
     }
]