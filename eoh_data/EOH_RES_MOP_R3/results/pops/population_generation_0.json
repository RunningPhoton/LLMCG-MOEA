[
     {
          "algorithm": "```",
          "code": "def next_generation(pops, search_trajectory, xlb, xub, POP_SIZE, N_P, current_gen, max_gen):\n    import numpy as np\n\n    def crossover(parent1, parent2):\n        child = np.empty(N_P)\n        for i in range(N_P):\n            if np.random.rand() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutate(individual):\n        mutation_rate = 0.1 + (0.5 - 0.1) * current_gen / max_gen\n        for i in range(N_P):\n            if np.random.rand() < mutation_rate:\n                individual[i] += np.random.uniform(-1, 1) * (xub[i] - xlb[i]) * 0.1\n                individual[i] = np.clip(individual[i], xlb[i], xub[i])\n        return individual\n\n    def select_parents(ranked_individuals):\n        index1 = np.random.randint(POP_SIZE)\n        index2 = (index1 + np.random.randint(1, POP_SIZE)) % POP_SIZE\n        return ranked_individuals[index1], ranked_individuals[index2]\n\n    def create_new_population():\n        new_population = np.empty((POP_SIZE, N_P))\n        for i in range(POP_SIZE):\n            parent1, parent2 = select_parents(pops['individuals'])\n            child = crossover(parent1, parent2)\n            child = mutate(child)\n            new_population[i] = child\n        return new_population\n\n    new_pops = create_new_population()\n    return new_pops",
          "objective": -0.95647,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, search_trajectory, xlb, xub, POP_SIZE, N_P, current_gen, max_gen):\n    import numpy as np\n\n    def mutate(individual, mutation_rate, xlb, xub):\n        if np.random.rand() < mutation_rate:\n            mutation_vector = np.random.uniform(-1, 1, individual.shape) * (xub - xlb)\n            new_individual = individual + mutation_vector\n            new_individual = np.clip(new_individual, xlb, xub)\n        else:\n            new_individual = individual\n        return new_individual\n\n    def crossover(parent1, parent2, crossover_rate):\n        if np.random.rand() < crossover_rate:\n            crossover_point = np.random.randint(0, N_P)\n            child1 = np.concatenate([parent1[:crossover_point], parent2[crossover_point:]])\n            child2 = np.concatenate([parent2[:crossover_point], parent1[crossover_point:]])\n            return child1, child2\n        else:\n            return parent1, parent2\n\n    def select_parents(population, rankings):\n        prob = 1 / (1 + rankings)\n        prob /= prob.sum()\n        idx = np.random.choice(np.arange(POP_SIZE), size=2, replace=False, p=prob)\n        return population[idx[0]], population[idx[1]]\n\n    def create_new_population(pops, POP_SIZE, N_P, xlb, xub, current_gen, max_gen):\n        new_population = np.empty((POP_SIZE, N_P))\n        mutation_rate = max(0.1, 1 - current_gen / max_gen)\n        crossover_rate = max(0.5, 1 - current_gen / max_gen)\n        \n        for i in range(0, POP_SIZE, 2):\n            parent1, parent2 = select_parents(pops['individuals'], pops['rankings'])\n            child1, child2 = crossover(parent1, parent2, crossover_rate)\n            child1 = mutate(child1, mutation_rate, xlb, xub)\n            child2 = mutate(child2, mutation_rate, xlb, xub)\n            new_population[i] = child1\n            if i + 1 < POP_SIZE:\n                new_population[i + 1] = child2\n\n        return new_population\n\n    new_pops = create_new_population(pops, POP_SIZE, N_P, xlb, xub, current_gen, max_gen)\n    return new_pops",
          "objective": -19.35809,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, search_trajectory, xlb, xub, POP_SIZE, N_P, current_gen, max_gen):\n    \"\"\"\n    The algorithm iteratively generates a new population by selecting parents, \n    applying crossover and mutation, and then selecting the best individuals based on rankings.\n    \"\"\"\n    import numpy as np\n\n    def crossover(parent1, parent2):\n        \"\"\"Perform crossover between two parents to produce an offspring.\"\"\"\n        alpha = np.random.rand(N_P)\n        return alpha * parent1 + (1 - alpha) * parent2\n\n    def mutate(individual):\n        \"\"\"Mutate an individual by randomly changing its genes within bounds.\"\"\"\n        mutation_strength = (xub - xlb) * (1 - current_gen / max_gen) * 0.1\n        mutation = np.random.randn(N_P) * mutation_strength\n        return np.clip(individual + mutation, xlb, xub)\n\n    def tournament_selection(population, k=2):\n        \"\"\"Select one individual from the population using k-tournament selection.\"\"\"\n        selected_indices = np.random.choice(len(population), k, replace=False)\n        selected_individuals = population[selected_indices]\n        selected_rankings = pops['rankings'][selected_indices]\n        winner_index = selected_indices[np.argmin(selected_rankings)]\n        return population[winner_index]\n\n    def create_new_population():\n        \"\"\"Create a new population using crossover, mutation, and selection.\"\"\"\n        new_population = []\n        while len(new_population) < POP_SIZE:\n            # Select parents\n            parent1 = tournament_selection(pops['individuals'])\n            parent2 = tournament_selection(pops['individuals'])\n            # Crossover\n            offspring = crossover(parent1, parent2)\n            # Mutation\n            offspring = mutate(offspring)\n            new_population.append(offspring)\n        return np.array(new_population)\n\n    # Generate the new population\n    new_pops = create_new_population()\n    \n    return new_pops",
          "objective": -27.17128,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, search_trajectory, xlb, xub, POP_SIZE, N_P, current_gen, max_gen):\n    import numpy as np\n\n    def crossover(parent1, parent2):\n        alpha = np.random.uniform(0, 1, size=N_P)\n        child = alpha * parent1 + (1 - alpha) * parent2\n        return child\n\n    def mutate(individual):\n        mutation_rate = 0.1 + (0.9 - 0.1) * current_gen / max_gen\n        for i in range(N_P):\n            if np.random.rand() < mutation_rate:\n                individual[i] += np.random.normal(0, (xub[i] - xlb[i]) / 10)\n                individual[i] = np.clip(individual[i], xlb[i], xub[i])\n        return individual\n\n    def select_parents(population, rankings):\n        prob = 1 / (rankings + 1)\n        prob /= prob.sum()\n        parents_indices = np.random.choice(len(population), size=2, p=prob, replace=False)\n        return population[parents_indices[0]], population[parents_indices[1]]\n\n    def create_new_individual(current_population, rankings):\n        parent1, parent2 = select_parents(current_population, rankings)\n        child = crossover(parent1, parent2)\n        child = mutate(child)\n        return child\n\n    new_pops = np.empty((POP_SIZE, N_P))\n    for i in range(POP_SIZE):\n        new_pops[i] = create_new_individual(pops['individuals'], pops['rankings'])\n\n    return new_pops",
          "objective": -29.97957,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, search_trajectory, xlb, xub, POP_SIZE, N_P, current_gen, max_gen):\n    \"\"\"\n    A novel reproduction function that employs a hybrid of differential evolution and trajectory-based mutation to generate the next population.\n    \"\"\"\n\n    import numpy as np\n\n    def differential_evolution(individuals):\n        CR = 0.9  # Crossover probability\n        F = 0.8  # Differential weight\n        new_individuals = np.empty_like(individuals)\n        for i in range(len(individuals)):\n            idxs = [idx for idx in range(len(individuals)) if idx != i]\n            a, b, c = individuals[np.random.choice(idxs, 3, replace=False)]\n            mutant = np.clip(a + F * (b - c), xlb, xub)\n            cross_points = np.random.rand(N_P) < CR\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, N_P)] = True\n            trial = np.where(cross_points, mutant, individuals[i])\n            new_individuals[i] = trial\n        return new_individuals\n\n    def trajectory_mutation(individuals, trajectory):\n        sigma = (xub - xlb) * (1 - (current_gen / max_gen))**2\n        for i in range(len(individuals)):\n            if trajectory['individuals'] is not None and len(trajectory['individuals']) > 0:\n                historical_individual = trajectory['individuals'][np.random.randint(0, len(trajectory['individuals']))]\n                individuals[i] += np.random.normal(0, sigma) * (historical_individual - individuals[i])\n            individuals[i] = np.clip(individuals[i], xlb, xub)\n        return individuals\n\n    def create_new_population(individuals):\n        half_pop_size = POP_SIZE // 2\n        new_individuals = differential_evolution(individuals[:half_pop_size])\n        mutated_individuals = trajectory_mutation(individuals[half_pop_size:], search_trajectory)\n        return np.vstack((new_individuals, mutated_individuals))\n\n    def validate_population(individuals):\n        return np.clip(individuals, xlb, xub)\n\n    individuals = pops['individuals']\n    new_individuals = create_new_population(individuals)\n    new_pops = validate_population(new_individuals)\n\n    return new_pops",
          "objective": -32.12739,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, search_trajectory, xlb, xub, POP_SIZE, N_P, current_gen, max_gen):\n    \"\"\"\n    The algorithm combines differential evolution with a local search heuristic that uses historical search information to guide mutation and crossover, aiming to converge towards the Pareto front.\n    \"\"\"\n    import numpy as np\n\n    def differential_evolution(individuals):\n        CR = 0.9  # Crossover probability\n        F = 0.8   # Differential weight\n        new_individuals = np.empty_like(individuals)\n        for i in range(len(individuals)):\n            idxs = [idx for idx in range(len(individuals)) if idx != i]\n            a, b, c = individuals[np.random.choice(idxs, 3, replace=False)]\n            mutant = np.clip(a + F * (b - c), xlb, xub)\n            cross_points = np.random.rand(N_P) < CR\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, N_P)] = True\n            trial = np.where(cross_points, mutant, individuals[i])\n            new_individuals[i] = trial\n        return new_individuals\n\n    def local_search(individuals):\n        LS_FACTOR = 0.1  # Local search factor\n        for i in range(len(individuals)):\n            if np.random.rand() < LS_FACTOR:\n                local_search_vector = np.random.randn(N_P) * (xub - xlb) * 0.1\n                individuals[i] = np.clip(individuals[i] + local_search_vector, xlb, xub)\n        return individuals\n\n    def historical_guided_mutation(individuals):\n        if search_trajectory['individuals'] is not None and len(search_trajectory['individuals']) > 0:\n            historical_individuals = search_trajectory['individuals']\n            for i in range(len(individuals)):\n                if np.random.rand() < 0.2:\n                    historical_idx = np.random.randint(len(historical_individuals))\n                    historical_individual = historical_individuals[historical_idx]\n                    mutation_vector = (historical_individual - individuals[i]) * np.random.rand(N_P)\n                    individuals[i] = np.clip(individuals[i] + mutation_vector, xlb, xub)\n        return individuals\n\n    def create_new_population(individuals):\n        individuals = differential_evolution(individuals)\n        individuals = local_search(individuals)\n        individuals = historical_guided_mutation(individuals)\n        return individuals\n\n    new_pops = create_new_population(pops['individuals'])\n    return new_pops",
          "objective": -35.09861,
          "other_inf": null
     },
     {
          "algorithm": "A novel reproduction function that combines crossover, mutation, and historical search trajectory \n    guidance to generate the next population for a multi-objective optimization problem.",
          "code": "def next_generation(pops, search_trajectory, xlb, xub, POP_SIZE, N_P, current_gen, max_gen):\n    \"\"\"\n    {A novel reproduction function that combines crossover, mutation, and historical search trajectory \n    guidance to generate the next population for a multi-objective optimization problem.}\n    \"\"\"\n    import numpy as np\n    \n    def crossover(parent1, parent2):\n        alpha = np.random.rand(N_P)\n        return alpha * parent1 + (1 - alpha) * parent2\n\n    def mutation(individual):\n        mutation_rate = 0.1 + (0.9 * current_gen / max_gen)  # Adaptive mutation rate\n        for i in range(N_P):\n            if np.random.rand() < mutation_rate:\n                individual[i] = individual[i] + np.random.normal(0, 1) * (xub[i] - xlb[i]) * 0.1\n        return np.clip(individual, xlb, xub)\n\n    def select_parents():\n        index1, index2 = np.random.choice(range(POP_SIZE), 2, replace=False)\n        return pops['individuals'][index1], pops['individuals'][index2]\n\n    def use_search_trajectory():\n        if search_trajectory['individuals'] is not None:\n            return search_trajectory['individuals'][np.random.choice(range(search_trajectory['individuals'].shape[0]))]\n        else:\n            return pops['individuals'][np.random.choice(range(POP_SIZE))]\n\n    new_pops = np.zeros((POP_SIZE, N_P))\n    for i in range(POP_SIZE):\n        if np.random.rand() < 0.5:  # Crossover probability\n            parent1, parent2 = select_parents()\n            child = crossover(parent1, parent2)\n        else:  # Use historical search trajectory\n            child = use_search_trajectory()\n        child = mutation(child)\n        new_pops[i, :] = child\n\n    return new_pops",
          "objective": -44.10059,
          "other_inf": null
     },
     {
          "algorithm": "'individuals': new_pops, 'rankings': np.empty(POP_SIZE,)",
          "code": "def next_generation(pops, search_trajectory, xlb, xub, POP_SIZE, N_P, current_gen, max_gen):\n    \"\"\"\n    The algorithm combines historical search trajectory and current population rankings to guide the generation of new individuals using a blend of mutation and crossover, with an emphasis on exploration in early generations and exploitation in later ones.\n    \"\"\"\n    import numpy as np\n    \n    def blend_crossover(parent1, parent2, alpha=0.5):\n        return alpha * parent1 + (1 - alpha) * parent2\n    \n    def mutate(individual, mutation_rate):\n        if np.random.rand() < mutation_rate:\n            mutation_vector = np.random.uniform(-1, 1, size=individual.shape)\n            individual += mutation_vector * (xub - xlb) * mutation_rate\n            individual = np.clip(individual, xlb, xub)\n        return individual\n    \n    def select_parents(ranked_population, method='tournament', tournament_size=2):\n        if method == 'tournament':\n            idx = np.random.choice(range(POP_SIZE), size=tournament_size, replace=False)\n            return ranked_population[np.argmin(pops['rankings'][idx])]\n        else:\n            return ranked_population[np.random.randint(0, POP_SIZE)]\n    \n    def create_new_individual(ranked_population, search_traj, gen, max_gen):\n        parent1 = select_parents(ranked_population)\n        parent2 = select_parents(ranked_population)\n        offspring = blend_crossover(parent1, parent2)\n        mutation_rate = 1.0 - (gen / max_gen)  # Decrease mutation rate over generations\n        offspring = mutate(offspring, mutation_rate)\n        return offspring\n    \n    ranked_population = pops['individuals']\n    new_pops = np.empty_like(ranked_population)\n    \n    for i in range(POP_SIZE):\n        new_pops[i] = create_new_individual(ranked_population, search_trajectory, current_gen, max_gen)\n    \n    return new_pops",
          "objective": -45.12032,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, search_trajectory, xlb, xub, POP_SIZE, N_P, current_gen, max_gen):\n    \"\"\"\n    The new algorithm iteratively generates a next population by applying crossover and mutation\n    operations based on the current population, historical search trajectory, and adaptive\n    mechanisms that adjust the intensity of these operations according to the current generation.\n    \"\"\"\n\n    import numpy as np\n\n    def crossover(parent1, parent2, cr_rate):\n        child = np.where(np.random.rand(N_P) < cr_rate, parent1, parent2)\n        return child\n\n    def mutation(individual, mu_rate):\n        mutant = individual + np.random.randn(N_P) * mu_rate * (xub - xlb)\n        return np.clip(mutant, xlb, xub)\n\n    def select_parents(ranked_individuals):\n        index1 = np.random.randint(POP_SIZE)\n        index2 = (index1 + np.random.randint(1, POP_SIZE)) % POP_SIZE\n        return ranked_individuals[index1], ranked_individuals[index2]\n\n    def adapt_rates(current_gen, max_gen):\n        cr_rate = 0.9 - 0.5 * (current_gen / max_gen)\n        mu_rate = 0.1 + 0.5 * (current_gen / max_gen)\n        return cr_rate, mu_rate\n\n    # Main function to generate the next population\n    def next_population(pops, search_trajectory, current_gen, max_gen):\n        new_pops = np.empty_like(pops['individuals'])\n        cr_rate, mu_rate = adapt_rates(current_gen, max_gen)\n\n        for i in range(POP_SIZE):\n            parent1, parent2 = select_parents(pops['individuals'])\n            child = crossover(parent1, parent2, cr_rate)\n            child = mutation(child, mu_rate)\n            new_pops[i] = child\n\n        return new_pops\n\n    new_pops = next_population(pops, search_trajectory, current_gen, max_gen)\n    return new_pops",
          "objective": -49.30074,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, search_trajectory, xlb, xub, POP_SIZE, N_P, current_gen, max_gen):\n    \"\"\"\n    A novel evolutionary algorithm that combines differential evolution with a local search heuristic,\n    using historical search trajectory for adaptive mutation, and elitism for preserving best solutions.\n    \"\"\"\n    import numpy as np\n    \n    def differential_mutation(individuals, F=0.8):\n        \"\"\"Performs differential mutation on the population.\"\"\"\n        new_individuals = np.empty_like(individuals)\n        for i in range(len(individuals)):\n            idxs = [idx for idx in range(len(individuals)) if idx != i]\n            a, b, c = individuals[np.random.choice(idxs, 3, replace=False)]\n            mutant = np.clip(a + F * (b - c), xlb, xub)\n            new_individuals[i] = mutant\n        return new_individuals\n    \n    def crossover(parents, mutants, CR=0.9):\n        \"\"\"Performs crossover between parents and mutants.\"\"\"\n        offspring = np.empty_like(parents)\n        for i in range(len(parents)):\n            cross_points = np.random.rand(N_P) < CR\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, N_P)] = True\n            offspring[i] = np.where(cross_points, mutants[i], parents[i])\n        return offspring\n    \n    def local_search(individuals, sigma=0.1):\n        \"\"\"Performs a local search on the population.\"\"\"\n        return np.clip(individuals + sigma * np.random.randn(*individuals.shape), xlb, xub)\n    \n    def select_elites(individuals, rankings, num_elites=POP_SIZE//5):\n        \"\"\"Selects elite individuals based on rankings.\"\"\"\n        return individuals[:num_elites]\n    \n    def create_new_population(individuals, rankings):\n        \"\"\"Creates a new population using mutation, crossover, local search, and elitism.\"\"\"\n        elites = select_elites(individuals, rankings)\n        mutants = differential_mutation(individuals)\n        offspring = crossover(individuals, mutants)\n        offspring = local_search(offspring)\n        new_population = np.vstack((elites, offspring[:POP_SIZE - len(elites)]))\n        return new_population\n    \n    individuals = pops['individuals']\n    rankings = pops['rankings']\n    new_pops = create_new_population(individuals, rankings)\n    \n    return new_pops",
          "objective": -50.9871,
          "other_inf": null
     }
]