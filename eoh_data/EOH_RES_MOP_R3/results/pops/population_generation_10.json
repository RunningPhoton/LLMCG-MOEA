[
     {
          "algorithm": "A reproduction function that uses simulated binary crossover and Gaussian mutation with an adaptive mutation rate, \n    influenced by the generation count and the individual's ranking.",
          "code": "def next_generation(pops, search_trajectory, xlb, xub, POP_SIZE, N_P, current_gen, max_gen):\n    \"\"\"\n    {A reproduction function that uses simulated binary crossover and Gaussian mutation with an adaptive mutation rate, \n    influenced by the generation count and the individual's ranking.}\n    \"\"\"\n    import numpy as np\n\n    def simulated_binary_crossover(parent1, parent2, eta_c=15):\n        child1, child2 = np.copy(parent1), np.copy(parent2)\n        for i in range(N_P):\n            if np.random.rand() <= 0.5:\n                if abs(parent1[i] - parent2[i]) > 1e-14:\n                    x1 = min(parent1[i], parent2[i])\n                    x2 = max(parent1[i], parent2[i])\n                    rand = np.random.rand()\n                    beta = 1.0 + (2.0 * (x1 - xlb[i]) / (x2 - x1))\n                    alpha = 2.0 - beta**-(eta_c + 1)\n                    betaq = 0\n                    if rand <= (1.0 / alpha):\n                        betaq = (rand * alpha)**(1.0 / (eta_c + 1))\n                    else:\n                        betaq = (1.0 / (2.0 - rand * alpha))**(1.0 / (eta_c + 1))\n                    child1[i] = 0.5 * ((x1 + x2) - betaq * (x2 - x1))\n                    \n                    beta = 1.0 + (2.0 * (xub[i] - x2) / (x2 - x1))\n                    alpha = 2.0 - beta**-(eta_c + 1)\n                    if rand <= (1.0 / alpha):\n                        betaq = (rand * alpha)**(1.0 / (eta_c + 1))\n                    else:\n                        betaq = (1.0 / (2.0 - rand * alpha))**(1.0 / (eta_c + 1))\n                    child2[i] = 0.5 * ((x1 + x2) + betaq * (x2 - x1))\n\n                    child1[i] = np.clip(child1[i], xlb[i], xub[i])\n                    child2[i] = np.clip(child2[i], xlb[i], xub[i])\n        return child1, child2\n\n    def gaussian_mutation(individual, rank, mutation_rate=0.1):\n        if rank < POP_SIZE // 2:  # Higher ranked individuals have a lower mutation rate\n            mutation_rate *= (1 - (current_gen / max_gen))\n        for i in range(N_P):\n            if np.random.rand() < mutation_rate:\n                individual[i] += np.random.normal(0, (xub[i] - xlb[i]) / 10)\n                individual[i] = np.clip(individual[i], xlb[i], xub[i])\n        return individual\n\n    new_pops = np.zeros((POP_SIZE, N_P))\n    for i in range(0, POP_SIZE, 2):\n        parent1_idx = i\n        parent2_idx = (i + 1) if (i + 1) < POP_SIZE else 0\n        parent1 = pops['individuals'][parent1_idx]\n        parent2 = pops['individuals'][parent2_idx]\n        child1, child2 = simulated_binary_crossover(parent1, parent2)\n        child1 = gaussian_mutation(child1, pops['rankings'][parent1_idx])\n        child2 = gaussian_mutation(child2, pops['rankings'][parent2_idx])\n        new_pops[i] = child1\n        if (i + 1) < POP_SIZE:\n            new_pops[i + 1] = child2\n\n    return new_pops",
          "objective": 0.68393,
          "other_inf": null
     },
     {
          "algorithm": "A reproduction function that combines rank-based roulette wheel selection, uniform crossover, and dynamic mutation rate adjustment with an optional elitism strategy to generate the next population.",
          "code": "def next_generation(pops, search_trajectory, xlb, xub, POP_SIZE, N_P, current_gen, max_gen):\n    \"\"\"\n    {A reproduction function that combines rank-based roulette wheel selection, uniform crossover, and dynamic mutation rate adjustment with an optional elitism strategy to generate the next population.}\n    \"\"\"\n    import numpy as np\n    \n    def roulette_wheel_selection(rankings):\n        max_rank = np.max(rankings)\n        selection_prob = (max_rank + 1 - rankings) / np.sum(max_rank + 1 - rankings)\n        selected_index = np.random.choice(np.arange(POP_SIZE), p=selection_prob)\n        return pops['individuals'][selected_index]\n\n    def uniform_crossover(parent1, parent2):\n        child = np.where(np.random.rand(N_P) < 0.5, parent1, parent2)\n        return child\n\n    def dynamic_mutation(individual, current_gen, max_gen):\n        mutation_rate = 0.1 * (1 - (current_gen / max_gen))\n        mutation_vector = np.random.rand(N_P) < mutation_rate\n        mutation_amount = np.random.normal(0, (xub - xlb) / 20.0, N_P)\n        individual = np.where(mutation_vector, individual + mutation_amount, individual)\n        return np.clip(individual, xlb, xub)\n\n    def elitism_strategy(elite_size=2):\n        elite_individuals = pops['individuals'][:elite_size]\n        return elite_individuals\n\n    new_pops = np.empty((POP_SIZE, N_P))\n    elite_individuals = elitism_strategy()\n    new_pops[:len(elite_individuals)] = elite_individuals\n\n    for i in range(len(elite_individuals), POP_SIZE):\n        parent1 = roulette_wheel_selection(pops['rankings'])\n        parent2 = roulette_wheel_selection(pops['rankings'])\n        child = uniform_crossover(parent1, parent2)\n        child = dynamic_mutation(child, current_gen, max_gen)\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.59486,
          "other_inf": null
     },
     {
          "algorithm": "A novel algorithm that utilizes a blend of rank-based selection, Gaussian mutation, and uniform crossover to promote diversity and convergence.",
          "code": "def next_generation(pops, search_trajectory, xlb, xub, POP_SIZE, N_P, current_gen, max_gen):\n    \"\"\"\n    {A novel algorithm that utilizes a blend of rank-based selection, Gaussian mutation, and uniform crossover to promote diversity and convergence.}\n    \"\"\"\n    import numpy as np\n\n    # Rank-based selection function\n    def rank_based_selection(individuals, rankings):\n        probabilities = 1 / (rankings + 1)\n        probabilities /= probabilities.sum()\n        selected_index = np.random.choice(len(individuals), p=probabilities)\n        return individuals[selected_index]\n\n    # Gaussian mutation function\n    def gaussian_mutation(individual, mutation_rate=0.1, sigma=0.1):\n        mutant = np.copy(individual)\n        for i in range(len(individual)):\n            if np.random.rand() < mutation_rate:\n                mutant[i] += np.random.normal(0, sigma)\n                mutant[i] = np.clip(mutant[i], xlb[i], xub[i])\n        return mutant\n\n    # Uniform crossover function\n    def uniform_crossover(parent1, parent2):\n        child = np.copy(parent1)\n        for i in range(N_P):\n            if np.random.rand() < 0.5:\n                child[i] = parent2[i]\n        return child\n\n    # Create new population function\n    def create_new_population(individuals, rankings):\n        new_population = np.empty_like(individuals)\n        for i in range(POP_SIZE):\n            parent1 = rank_based_selection(individuals, rankings)\n            parent2 = rank_based_selection(individuals, rankings)\n            child = uniform_crossover(parent1, parent2)\n            new_population[i] = gaussian_mutation(child)\n        return new_population\n\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n    new_pops = create_new_population(individuals, rankings)\n\n    return new_pops",
          "objective": 0.02511,
          "other_inf": null
     },
     {
          "algorithm": "A new algorithm that uses rank-based roulette wheel selection, differential evolution crossover, \n    and adaptive mutation rate based on generation count to ensure diversity and convergence.",
          "code": "def next_generation(pops, search_trajectory, xlb, xub, POP_SIZE, N_P, current_gen, max_gen):\n    \"\"\"\n    {A new algorithm that uses rank-based roulette wheel selection, differential evolution crossover, \n    and adaptive mutation rate based on generation count to ensure diversity and convergence.}\n    \"\"\"\n    import numpy as np\n\n    def roulette_wheel_selection(rankings):\n        max_rank = np.max(rankings)\n        selection_probs = (max_rank - rankings + 1) / np.sum(max_rank - rankings + 1)\n        selected_index = np.random.choice(np.arange(POP_SIZE), p=selection_probs)\n        return pops['individuals'][selected_index]\n\n    def differential_evolution_crossover(target, a, b, c, cr=0.5):\n        trial = np.copy(target)\n        j_rand = np.random.randint(N_P)\n        for j in range(N_P):\n            if np.random.rand() < cr or j == j_rand:\n                trial[j] = a[j] + 0.5 * (b[j] - c[j])\n                trial[j] = np.clip(trial[j], xlb[j], xub[j])\n        return trial\n\n    def adaptive_mutation(individual, gen_count, max_gen_count, mutation_scale=0.1):\n        mutation_rate = mutation_scale * (1 - gen_count / max_gen_count)\n        for i in range(N_P):\n            if np.random.rand() < mutation_rate:\n                delta = (xub[i] - xlb[i]) * (np.random.rand() - 0.5) * 2\n                individual[i] += delta\n                individual[i] = np.clip(individual[i], xlb[i], xub[i])\n        return individual\n\n    new_pops = np.zeros((POP_SIZE, N_P))\n    for i in range(POP_SIZE):\n        target = pops['individuals'][i]\n        a = roulette_wheel_selection(pops['rankings'])\n        b = roulette_wheel_selection(pops['rankings'])\n        c = roulette_wheel_selection(pops['rankings'])\n\n        trial = differential_evolution_crossover(target, a, b, c)\n        trial = adaptive_mutation(trial, current_gen, max_gen)\n        new_pops[i, :] = trial\n\n    return new_pops",
          "objective": -0.00621,
          "other_inf": null
     },
     {
          "algorithm": "A reproduction function that combines rank-based selection, uniform crossover, adaptive mutation, and historical population guidance to generate the next population.",
          "code": "def next_generation(pops, search_trajectory, xlb, xub, POP_SIZE, N_P, current_gen, max_gen):\n    \"\"\"\n    {A reproduction function that combines rank-based selection, uniform crossover, adaptive mutation, and historical population guidance to generate the next population.}\n    \"\"\"\n    import numpy as np\n\n    def rank_based_selection():\n        cumulative_rankings = np.cumsum(1 / (1 + np.arange(POP_SIZE)))\n        selection_prob = cumulative_rankings / cumulative_rankings[-1]\n        selected_index = np.searchsorted(selection_prob, np.random.rand())\n        return pops['individuals'][selected_index]\n\n    def uniform_crossover(parent1, parent2):\n        mask = np.random.rand(N_P) < 0.5\n        child = np.where(mask, parent1, parent2)\n        return child\n\n    def adaptive_mutation(individual, gen_factor):\n        for i in range(N_P):\n            if np.random.rand() < gen_factor:\n                mutation_range = gen_factor * (xub[i] - xlb[i])\n                individual[i] += np.random.uniform(-mutation_range, mutation_range)\n                individual[i] = np.clip(individual[i], xlb[i], xub[i])\n        return individual\n\n    def historical_population_guidance():\n        if search_trajectory['individuals'] is not None:\n            historical_best_idx = np.argmin(search_trajectory['rankings'])\n            return search_trajectory['individuals'][historical_best_idx]\n        else:\n            return None\n\n    gen_factor = (1 - current_gen / max_gen) ** 2  # Adaptive factor decreasing over generations\n    new_pops = np.zeros((POP_SIZE, N_P))\n\n    for i in range(POP_SIZE):\n        parent1 = rank_based_selection()\n        if np.random.rand() < 0.8:  # Probability for crossover\n            parent2 = rank_based_selection()\n            child = uniform_crossover(parent1, parent2)\n        else:\n            historical_best = historical_population_guidance()\n            child = historical_best if historical_best is not None else parent1\n        child = adaptive_mutation(child, gen_factor)\n        new_pops[i, :] = child\n\n    return new_pops",
          "objective": -0.14273,
          "other_inf": null
     },
     {
          "algorithm": "A new algorithm that employs differential evolution with an adaptive mutation strategy and elitism to balance exploration and exploitation.",
          "code": "def next_generation(pops, search_trajectory, xlb, xub, POP_SIZE, N_P, current_gen, max_gen):\n    \"\"\"\n    {A new algorithm that employs differential evolution with an adaptive mutation strategy and elitism to balance exploration and exploitation.}\n    \"\"\"\n    import numpy as np\n    \n    def differential_mutation(ind, F=0.8):\n        idxs = np.random.choice(range(POP_SIZE), 3, replace=False)\n        a, b, c = pops['individuals'][idxs[0]], pops['individuals'][idxs[1]], pops['individuals'][idxs[2]]\n        mutant = np.clip(a + F * (b - c), xlb, xub)\n        return mutant\n    \n    def crossover(parent, donor, CR=0.5):\n        child = np.array([donor[i] if np.random.rand() < CR else parent[i] for i in range(N_P)])\n        return child\n\n    def select_elite():\n        return pops['individuals'][0]\n    \n    def adapt_mutation_factor(gen, max_gen, F_min=0.5, F_max=0.9):\n        return F_min + (F_max - F_min) * (gen / max_gen)\n    \n    new_pops = np.zeros((POP_SIZE, N_P))\n    F = adapt_mutation_factor(current_gen, max_gen)\n    elite = select_elite()\n    new_pops[0] = elite  # Preserving the elite individual\n    \n    for i in range(1, POP_SIZE):\n        parent = pops['individuals'][i]\n        mutant = differential_mutation(parent, F=F)\n        child = crossover(parent, mutant)\n        new_pops[i] = child\n    \n    return new_pops",
          "objective": -0.4825,
          "other_inf": null
     },
     {
          "algorithm": "A novel reproduction function that combines simulated binary crossover and polynomial mutation to generate the next population.",
          "code": "def next_generation(pops, search_trajectory, xlb, xub, POP_SIZE, N_P, current_gen, max_gen):\n    \"\"\"\n    {A novel reproduction function that combines simulated binary crossover and polynomial mutation to generate the next population.}\n    \"\"\"\n    import numpy as np\n\n    def sbx_crossover(parent1, parent2, eta=30):\n        child1, child2 = np.copy(parent1), np.copy(parent2)\n        for i in range(N_P):\n            if np.random.rand() <= 0.5:\n                if abs(parent1[i] - parent2[i]) > 1e-14:\n                    x1 = min(parent1[i], parent2[i])\n                    x2 = max(parent1[i], parent2[i])\n                    xl = xlb[i]\n                    xu = xub[i]\n                    rand = np.random.rand()\n\n                    beta = 1.0 + (2.0 * (x1 - xl) / (x2 - x1))\n                    alpha = 2.0 - beta**-(eta + 1)\n                    if rand <= 1.0 / alpha:\n                        beta_q = (rand * alpha)**(1.0 / (eta + 1))\n                    else:\n                        beta_q = (1.0 / (2.0 - rand * alpha))**(1.0 / (eta + 1))\n\n                    c1 = 0.5 * ((x1 + x2) - beta_q * (x2 - x1))\n\n                    beta = 1.0 + (2.0 * (xu - x2) / (x2 - x1))\n                    alpha = 2.0 - beta**-(eta + 1)\n                    if rand <= 1.0 / alpha:\n                        beta_q = (rand * alpha)**(1.0 / (eta + 1))\n                    else:\n                        beta_q = (1.0 / (2.0 - rand * alpha))**(1.0 / (eta + 1))\n                    c2 = 0.5 * ((x1 + x2) + beta_q * (x2 - x1))\n\n                    c1 = np.clip(c1, xl, xu)\n                    c2 = np.clip(c2, xl, xu)\n\n                    if np.random.rand() <= 0.5:\n                        child1[i] = c2\n                        child2[i] = c1\n                    else:\n                        child1[i] = c1\n                        child2[i] = c2\n        return child1, child2\n\n    def polynomial_mutation(individual, eta_m=20):\n        mutant = np.copy(individual)\n        for i in range(N_P):\n            if np.random.rand() <= 1.0 / N_P:\n                xl = xlb[i]\n                xu = xub[i]\n                delta1 = (individual[i] - xl) / (xu - xl)\n                delta2 = (xu - individual[i]) / (xu - xl)\n                rand = np.random.rand()\n                mut_pow = 1.0 / (eta_m + 1.0)\n                if rand <= 0.5:\n                    delta_q = (2.0 * rand + (1.0 - 2.0 * rand) * (1.0 - delta1)**(eta_m + 1.0))**(mut_pow) - 1.0\n                else:\n                    delta_q = 1.0 - (2.0 * (1.0 - rand) + 2.0 * (rand - 0.5) * (1.0 - delta2)**(eta_m + 1.0))**(mut_pow)\n                mutant[i] = np.clip(individual[i] + delta_q * (xu - xl), xl, xu)\n        return mutant\n\n    def create_new_population(individuals):\n        new_population = []\n        for i in range(0, POP_SIZE, 2):\n            parent1 = individuals[np.random.randint(0, POP_SIZE)]\n            parent2 = individuals[np.random.randint(0, POP_SIZE)]\n            child1, child2 = sbx_crossover(parent1, parent2)\n            new_population.append(child1)\n            if len(new_population) < POP_SIZE:\n                new_population.append(child2)\n        return np.array(new_population)\n\n    def mutate_population(individuals):\n        mutated_population = []\n        for i in range(POP_SIZE):\n            mutated_individual = polynomial_mutation(individuals[i])\n            mutated_population.append(mutated_individual)\n        return np.array(mutated_population)\n\n    individuals = pops['individuals']\n    crossover_population = create_new_population(individuals)\n    mutated_population = mutate_population(crossover_population)\n    new_pops = np.clip(mutated_population, xlb, xub)\n\n    return new_pops",
          "objective": -0.53198,
          "other_inf": null
     },
     {
          "algorithm": "'individual': pops['individuals'][i], 'rank': pops['rankings'][i]",
          "code": "def next_generation(pops, search_trajectory, xlb, xub, POP_SIZE, N_P, current_gen, max_gen):\n    import numpy as np\n    \n    def tournament_selection(ranked_individuals, tournament_size):\n        best = None\n        for _ in range(tournament_size):\n            i = np.random.randint(POP_SIZE)\n            if best is None or ranked_individuals[i]['rank'] < best['rank']:\n                best = ranked_individuals[i]\n        return best['individual']\n\n    def simulated_binary_crossover(parent1, parent2, eta=15):\n        child1, child2 = np.copy(parent1), np.copy(parent2)\n        for i in range(N_P):\n            if np.random.rand() < 0.5:\n                if abs(parent1[i] - parent2[i]) > 1e-14:  # Avoid division by zero\n                    y1 = min(parent1[i], parent2[i])\n                    y2 = max(parent1[i], parent2[i])\n                    rand = np.random.rand()\n                    beta = 1.0 + (2.0 * (y1 - xlb[i]) / (y2 - y1))\n                    alpha = 2.0 - beta**-(eta + 1)\n                    if rand <= 1.0 / alpha:\n                        beta_q = (rand * alpha)**(1.0 / (eta + 1))\n                    else:\n                        beta_q = (1.0 / (2.0 - rand * alpha))**(1.0 / (eta + 1))\n                    child1[i] = 0.5 * ((y1 + y2) - beta_q * (y2 - y1))\n\n                    beta = 1.0 + (2.0 * (xub[i] - y2) / (y2 - y1))\n                    alpha = 2.0 - beta**-(eta + 1)\n                    if rand <= 1.0 / alpha:\n                        beta_q = (rand * alpha)**(1.0 / (eta + 1))\n                    else:\n                        beta_q = (1.0 / (2.0 - rand * alpha))**(1.0 / (eta + 1))\n                    child2[i] = 0.5 * ((y1 + y2) + beta_q * (y2 - y1))\n\n                    child1[i] = np.clip(child1[i], xlb[i], xub[i])\n                    child2[i] = np.clip(child2[i], xlb[i], xub[i])\n        return child1 if np.random.rand() < 0.5 else child2\n\n    def polynomial_mutation(individual, eta=20):\n        for i in range(N_P):\n            if np.random.rand() < 1.0 / N_P:\n                y = individual[i]\n                delta1 = (y - xlb[i]) / (xub[i] - xlb[i])\n                delta2 = (xub[i] - y) / (xub[i] - xlb[i])\n                rand = np.random.rand()\n                mut_pow = 1.0 / (eta + 1.0)\n                if rand < 0.5:\n                    xy = 1.0 - delta1\n                    val = 2.0 * rand + (1.0 - 2.0 * rand) * (xy**(eta + 1))\n                    delta_q = val**mut_pow - 1.0\n                else:\n                    xy = 1.0 - delta2\n                    val = 2.0 * (1.0 - rand) + 2.0 * (rand - 0.5) * (xy**(eta + 1))\n                    delta_q = 1.0 - val**mut_pow\n                y += delta_q * (xub[i] - xlb[i])\n                individual[i] = np.clip(y, xlb[i], xub[i])\n        return individual\n\n    def create_new_population():\n        ranked_individuals = [{'individual': pops['individuals'][i], 'rank': pops['rankings'][i]} for i in range(POP_SIZE)]\n        new_population = np.empty((POP_SIZE, N_P))\n        for i in range(POP_SIZE):\n            parent1 = tournament_selection(ranked_individuals, 3)\n            parent2 = tournament_selection(ranked_individuals, 3)\n            child = simulated_binary_crossover(parent1, parent2)\n            child = polynomial_mutation(child)\n            new_population[i] = child\n        return new_population\n    \n    new_pops = create_new_population()\n    return new_pops",
          "objective": -0.59677,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, search_trajectory, xlb, xub, POP_SIZE, N_P, current_gen, max_gen):\n    import numpy as np\n\n    def crossover(parent1, parent2):\n        child = np.empty(N_P)\n        for i in range(N_P):\n            if np.random.rand() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutate(individual):\n        mutation_rate = 0.1 + (0.5 - 0.1) * current_gen / max_gen\n        for i in range(N_P):\n            if np.random.rand() < mutation_rate:\n                individual[i] += np.random.uniform(-1, 1) * (xub[i] - xlb[i]) * 0.1\n                individual[i] = np.clip(individual[i], xlb[i], xub[i])\n        return individual\n\n    def select_parents(ranked_individuals):\n        index1 = np.random.randint(POP_SIZE)\n        index2 = (index1 + np.random.randint(1, POP_SIZE)) % POP_SIZE\n        return ranked_individuals[index1], ranked_individuals[index2]\n\n    def create_new_population():\n        new_population = np.empty((POP_SIZE, N_P))\n        for i in range(POP_SIZE):\n            parent1, parent2 = select_parents(pops['individuals'])\n            child = crossover(parent1, parent2)\n            child = mutate(child)\n            new_population[i] = child\n        return new_population\n\n    new_pops = create_new_population()\n    return new_pops",
          "objective": -0.95647,
          "other_inf": null
     },
     {
          "algorithm": "A novel algorithm that combines simulated binary crossover (SBX) and polynomial mutation to balance exploration and exploitation.",
          "code": "def next_generation(pops, search_trajectory, xlb, xub, POP_SIZE, N_P, current_gen, max_gen):\n    \"\"\"\n    {A novel algorithm that combines simulated binary crossover (SBX) and polynomial mutation to balance exploration and exploitation.}\n    \"\"\"\n    import numpy as np\n\n    def simulated_binary_crossover(p1, p2, eta_c=15):\n        child1, child2 = np.copy(p1), np.copy(p2)\n        for i in range(N_P):\n            if np.random.rand() <= 0.5:\n                if abs(p1[i] - p2[i]) > 1e-14:  # Prevent division by zero\n                    y1 = min(p1[i], p2[i])\n                    y2 = max(p1[i], p2[i])\n                    rand = np.random.rand()\n                    beta = 1.0 + (2.0 * (y1 - xlb[i]) / (y2 - y1))\n                    alpha = 2.0 - beta**-(eta_c + 1)\n                    betaq = 0\n                    if rand <= (1.0 / alpha):\n                        betaq = (rand * alpha)**(1.0 / (eta_c + 1))\n                    else:\n                        betaq = (1.0 / (2.0 - rand * alpha))**(1.0 / (eta_c + 1))\n                    c1 = 0.5 * ((y1 + y2) - betaq * (y2 - y1))\n\n                    beta = 1.0 + (2.0 * (xub[i] - y2) / (y2 - y1))\n                    alpha = 2.0 - beta**-(eta_c + 1)\n                    if rand <= (1.0 / alpha):\n                        betaq = (rand * alpha)**(1.0 / (eta_c + 1))\n                    else:\n                        betaq = (1.0 / (2.0 - rand * alpha))**(1.0 / (eta_c + 1))\n                    c2 = 0.5 * ((y1 + y2) + betaq * (y2 - y1))\n\n                    c1 = np.clip(c1, xlb[i], xub[i])\n                    c2 = np.clip(c2, xlb[i], xub[i])\n\n                    if np.random.rand() <= 0.5:\n                        child1[i] = c2\n                        child2[i] = c1\n                    else:\n                        child1[i] = c1\n                        child2[i] = c2\n        return child1, child2\n\n    def polynomial_mutation(individual, eta_m=20):\n        mutant = np.copy(individual)\n        for i in range(N_P):\n            if np.random.rand() < 1.0 / N_P:\n                y = mutant[i]\n                delta1 = (y - xlb[i]) / (xub[i] - xlb[i])\n                delta2 = (xub[i] - y) / (xub[i] - xlb[i])\n                rand = np.random.rand()\n                mut_pow = 1.0 / (eta_m + 1.0)\n                if rand < 0.5:\n                    xy = 1.0 - delta1\n                    val = 2.0 * rand + (1.0 - 2.0 * rand) * (xy**(eta_m + 1))\n                    deltaq = val**mut_pow - 1.0\n                else:\n                    xy = 1.0 - delta2\n                    val = 2.0 * (1.0 - rand) + 2.0 * (rand - 0.5) * (xy**(eta_m + 1))\n                    deltaq = 1.0 - val**mut_pow\n                mutant[i] = y + deltaq * (xub[i] - xlb[i])\n                mutant[i] = np.clip(mutant[i], xlb[i], xub[i])\n        return mutant\n\n    def create_new_population():\n        new_population = []\n        while len(new_population) < POP_SIZE:\n            idx1, idx2 = np.random.choice(POP_SIZE, 2, replace=False)\n            parent1, parent2 = pops['individuals'][idx1], pops['individuals'][idx2]\n            child1, child2 = simulated_binary_crossover(parent1, parent2)\n            new_population.append(polynomial_mutation(child1))\n            if len(new_population) < POP_SIZE:\n                new_population.append(polynomial_mutation(child2))\n        return np.array(new_population)\n\n    new_pops = create_new_population()\n    return new_pops",
          "objective": -1.15921,
          "other_inf": null
     }
]