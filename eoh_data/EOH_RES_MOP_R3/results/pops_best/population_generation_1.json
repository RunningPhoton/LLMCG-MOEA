{
     "algorithm": "```",
     "code": "def next_generation(pops, search_trajectory, xlb, xub, POP_SIZE, N_P, current_gen, max_gen):\n    import numpy as np\n\n    def crossover(parent1, parent2):\n        child = np.empty(N_P)\n        for i in range(N_P):\n            if np.random.rand() < 0.5:\n                child[i] = parent1[i]\n            else:\n                child[i] = parent2[i]\n        return child\n\n    def mutate(individual):\n        mutation_rate = 0.1 + (0.5 - 0.1) * current_gen / max_gen\n        for i in range(N_P):\n            if np.random.rand() < mutation_rate:\n                individual[i] += np.random.uniform(-1, 1) * (xub[i] - xlb[i]) * 0.1\n                individual[i] = np.clip(individual[i], xlb[i], xub[i])\n        return individual\n\n    def select_parents(ranked_individuals):\n        index1 = np.random.randint(POP_SIZE)\n        index2 = (index1 + np.random.randint(1, POP_SIZE)) % POP_SIZE\n        return ranked_individuals[index1], ranked_individuals[index2]\n\n    def create_new_population():\n        new_population = np.empty((POP_SIZE, N_P))\n        for i in range(POP_SIZE):\n            parent1, parent2 = select_parents(pops['individuals'])\n            child = crossover(parent1, parent2)\n            child = mutate(child)\n            new_population[i] = child\n        return new_population\n\n    new_pops = create_new_population()\n    return new_pops",
     "objective": -0.95647,
     "other_inf": null
}