{
     "algorithm": "A reproduction function that uses simulated binary crossover and Gaussian mutation with an adaptive mutation rate, \n    influenced by the generation count and the individual's ranking.",
     "code": "def next_generation(pops, search_trajectory, xlb, xub, POP_SIZE, N_P, current_gen, max_gen):\n    \"\"\"\n    {A reproduction function that uses simulated binary crossover and Gaussian mutation with an adaptive mutation rate, \n    influenced by the generation count and the individual's ranking.}\n    \"\"\"\n    import numpy as np\n\n    def simulated_binary_crossover(parent1, parent2, eta_c=15):\n        child1, child2 = np.copy(parent1), np.copy(parent2)\n        for i in range(N_P):\n            if np.random.rand() <= 0.5:\n                if abs(parent1[i] - parent2[i]) > 1e-14:\n                    x1 = min(parent1[i], parent2[i])\n                    x2 = max(parent1[i], parent2[i])\n                    rand = np.random.rand()\n                    beta = 1.0 + (2.0 * (x1 - xlb[i]) / (x2 - x1))\n                    alpha = 2.0 - beta**-(eta_c + 1)\n                    betaq = 0\n                    if rand <= (1.0 / alpha):\n                        betaq = (rand * alpha)**(1.0 / (eta_c + 1))\n                    else:\n                        betaq = (1.0 / (2.0 - rand * alpha))**(1.0 / (eta_c + 1))\n                    child1[i] = 0.5 * ((x1 + x2) - betaq * (x2 - x1))\n                    \n                    beta = 1.0 + (2.0 * (xub[i] - x2) / (x2 - x1))\n                    alpha = 2.0 - beta**-(eta_c + 1)\n                    if rand <= (1.0 / alpha):\n                        betaq = (rand * alpha)**(1.0 / (eta_c + 1))\n                    else:\n                        betaq = (1.0 / (2.0 - rand * alpha))**(1.0 / (eta_c + 1))\n                    child2[i] = 0.5 * ((x1 + x2) + betaq * (x2 - x1))\n\n                    child1[i] = np.clip(child1[i], xlb[i], xub[i])\n                    child2[i] = np.clip(child2[i], xlb[i], xub[i])\n        return child1, child2\n\n    def gaussian_mutation(individual, rank, mutation_rate=0.1):\n        if rank < POP_SIZE // 2:  # Higher ranked individuals have a lower mutation rate\n            mutation_rate *= (1 - (current_gen / max_gen))\n        for i in range(N_P):\n            if np.random.rand() < mutation_rate:\n                individual[i] += np.random.normal(0, (xub[i] - xlb[i]) / 10)\n                individual[i] = np.clip(individual[i], xlb[i], xub[i])\n        return individual\n\n    new_pops = np.zeros((POP_SIZE, N_P))\n    for i in range(0, POP_SIZE, 2):\n        parent1_idx = i\n        parent2_idx = (i + 1) if (i + 1) < POP_SIZE else 0\n        parent1 = pops['individuals'][parent1_idx]\n        parent2 = pops['individuals'][parent2_idx]\n        child1, child2 = simulated_binary_crossover(parent1, parent2)\n        child1 = gaussian_mutation(child1, pops['rankings'][parent1_idx])\n        child2 = gaussian_mutation(child2, pops['rankings'][parent2_idx])\n        new_pops[i] = child1\n        if (i + 1) < POP_SIZE:\n            new_pops[i + 1] = child2\n\n    return new_pops",
     "objective": 0.68393,
     "other_inf": null
}