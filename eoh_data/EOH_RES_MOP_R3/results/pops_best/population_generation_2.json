{
     "algorithm": "A novel reproduction function that combines simulated binary crossover and polynomial mutation to generate the next population.",
     "code": "def next_generation(pops, search_trajectory, xlb, xub, POP_SIZE, N_P, current_gen, max_gen):\n    \"\"\"\n    {A novel reproduction function that combines simulated binary crossover and polynomial mutation to generate the next population.}\n    \"\"\"\n    import numpy as np\n\n    def sbx_crossover(parent1, parent2, eta=30):\n        child1, child2 = np.copy(parent1), np.copy(parent2)\n        for i in range(N_P):\n            if np.random.rand() <= 0.5:\n                if abs(parent1[i] - parent2[i]) > 1e-14:\n                    x1 = min(parent1[i], parent2[i])\n                    x2 = max(parent1[i], parent2[i])\n                    xl = xlb[i]\n                    xu = xub[i]\n                    rand = np.random.rand()\n\n                    beta = 1.0 + (2.0 * (x1 - xl) / (x2 - x1))\n                    alpha = 2.0 - beta**-(eta + 1)\n                    if rand <= 1.0 / alpha:\n                        beta_q = (rand * alpha)**(1.0 / (eta + 1))\n                    else:\n                        beta_q = (1.0 / (2.0 - rand * alpha))**(1.0 / (eta + 1))\n\n                    c1 = 0.5 * ((x1 + x2) - beta_q * (x2 - x1))\n\n                    beta = 1.0 + (2.0 * (xu - x2) / (x2 - x1))\n                    alpha = 2.0 - beta**-(eta + 1)\n                    if rand <= 1.0 / alpha:\n                        beta_q = (rand * alpha)**(1.0 / (eta + 1))\n                    else:\n                        beta_q = (1.0 / (2.0 - rand * alpha))**(1.0 / (eta + 1))\n                    c2 = 0.5 * ((x1 + x2) + beta_q * (x2 - x1))\n\n                    c1 = np.clip(c1, xl, xu)\n                    c2 = np.clip(c2, xl, xu)\n\n                    if np.random.rand() <= 0.5:\n                        child1[i] = c2\n                        child2[i] = c1\n                    else:\n                        child1[i] = c1\n                        child2[i] = c2\n        return child1, child2\n\n    def polynomial_mutation(individual, eta_m=20):\n        mutant = np.copy(individual)\n        for i in range(N_P):\n            if np.random.rand() <= 1.0 / N_P:\n                xl = xlb[i]\n                xu = xub[i]\n                delta1 = (individual[i] - xl) / (xu - xl)\n                delta2 = (xu - individual[i]) / (xu - xl)\n                rand = np.random.rand()\n                mut_pow = 1.0 / (eta_m + 1.0)\n                if rand <= 0.5:\n                    delta_q = (2.0 * rand + (1.0 - 2.0 * rand) * (1.0 - delta1)**(eta_m + 1.0))**(mut_pow) - 1.0\n                else:\n                    delta_q = 1.0 - (2.0 * (1.0 - rand) + 2.0 * (rand - 0.5) * (1.0 - delta2)**(eta_m + 1.0))**(mut_pow)\n                mutant[i] = np.clip(individual[i] + delta_q * (xu - xl), xl, xu)\n        return mutant\n\n    def create_new_population(individuals):\n        new_population = []\n        for i in range(0, POP_SIZE, 2):\n            parent1 = individuals[np.random.randint(0, POP_SIZE)]\n            parent2 = individuals[np.random.randint(0, POP_SIZE)]\n            child1, child2 = sbx_crossover(parent1, parent2)\n            new_population.append(child1)\n            if len(new_population) < POP_SIZE:\n                new_population.append(child2)\n        return np.array(new_population)\n\n    def mutate_population(individuals):\n        mutated_population = []\n        for i in range(POP_SIZE):\n            mutated_individual = polynomial_mutation(individuals[i])\n            mutated_population.append(mutated_individual)\n        return np.array(mutated_population)\n\n    individuals = pops['individuals']\n    crossover_population = create_new_population(individuals)\n    mutated_population = mutate_population(crossover_population)\n    new_pops = np.clip(mutated_population, xlb, xub)\n\n    return new_pops",
     "objective": -0.53198,
     "other_inf": null
}