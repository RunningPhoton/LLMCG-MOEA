[
     {
          "algorithm": "i: set() for i in range(N_P)",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n\n    def edge_recombination(parent1, parent2):\n        # Create an edge map with neighbors for each city\n        edge_map = {i: set() for i in range(N_P)}\n        for i in range(N_P):\n            for parent in [parent1, parent2]:\n                neighbors = [parent[j] for j in [i-1, (i+1) % N_P]]\n                edge_map[parent[i]].update(neighbors)\n        \n        # Initialize child with the first city of the first parent\n        child = [-1] * N_P\n        current_city = parent1[0]\n        child[0] = current_city\n        \n        # Construct the child path using the edge map\n        for i in range(1, N_P):\n            # Remove the current city from the edge map\n            for neighbors in edge_map.values():\n                neighbors.discard(current_city)\n            # Choose the next city with the fewest neighbors\n            if edge_map[current_city]:\n                next_city = min(edge_map[current_city], key=lambda x: len(edge_map[x]))\n            else:\n                # Randomly choose a city if no neighbors are left\n                next_city = np.random.choice([c for c in range(N_P) if c not in child])\n            child[i] = next_city\n            current_city = next_city\n        \n        return np.array(child, dtype=np.int32)\n\n    def inversion_mutation(individual):\n        # Inversion mutation by inverting a subsequence\n        idx1, idx2 = sorted(np.random.choice(range(N_P), 2, replace=False))\n        individual[idx1:idx2+1] = individual[idx1:idx2+1][::-1]\n        return individual\n\n    def rank_based_selection(ranked_individuals):\n        # Select parents based on their rank (lower rank has higher chance)\n        probabilities = 1 / (ranked_individuals + 1)\n        probabilities /= probabilities.sum()\n        selected_indices = np.random.choice(range(POP_SIZE), size=2, p=probabilities, replace=False)\n        return pops['individuals'][selected_indices[0]], pops['individuals'][selected_indices[1]]\n\n    # Main steps of the novel algorithm\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    ranked_individuals = np.argsort(pops['rankings'])\n    for i in range(0, POP_SIZE, 2):\n        parent1, parent2 = rank_based_selection(ranked_individuals)\n        child1 = edge_recombination(parent1, parent2)\n        child1 = inversion_mutation(child1)\n        # For odd-sized populations, avoid index out of bounds\n        if i + 1 < POP_SIZE:\n            child2 = edge_recombination(parent2, parent1)\n            child2 = inversion_mutation(child2)\n            new_pops[i + 1] = child2\n        new_pops[i] = child1\n\n    return new_pops",
          "objective": 0.82543,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n\n    def crossover(parent1, parent2):\n        child = np.empty(N_P, dtype=np.int32)\n        child.fill(-1)\n        start_pos, end_pos = sorted(np.random.choice(range(N_P), 2, replace=False))\n        child[start_pos:end_pos+1] = parent1[start_pos:end_pos+1]\n        p2_filtered = [city for city in parent2 if city not in child]\n        child[child == -1] = p2_filtered\n        return child\n\n    def mutate(individual):\n        idx1, idx2 = np.random.choice(range(N_P), 2, replace=False)\n        individual[idx1], individual[idx2] = individual[idx2], individual[idx1]\n        return individual\n\n    def select_parents(ranked_individuals):\n        return ranked_individuals[np.random.choice(range(POP_SIZE), 2, p=selection_probs)]\n\n    ranked_individuals = pops['individuals'][np.argsort(pops['rankings'])]\n    fitness_values = 1 / (1 + np.argsort(np.argsort(pops['rankings'])))\n    selection_probs = fitness_values / fitness_values.sum()\n\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        parent1, parent2 = select_parents(ranked_individuals)\n        child = crossover(parent1, parent2)\n        if np.random.rand() < 0.2:  # mutation probability\n            child = mutate(child)\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.78892,
          "other_inf": null
     },
     {
          "algorithm": "A novel reproduction function using edge recombination and inversion mutation for path diversity and optimization}\n    import numpy as np\n\n    # Sub-function to perform edge recombination\n    def edge_recombination(parent1, parent2):\n        # Create the edge map from both parents\n        edge_map = {i: set() for i in range(N_P)}\n        for p in [parent1, parent2]:\n            for i in range(N_P):\n                next_city = p[(i + 1) % N_P]\n                prev_city = p[i - 1]\n                edge_map[p[i]].update({prev_city, next_city",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    # {A novel reproduction function using edge recombination and inversion mutation for path diversity and optimization}\n    import numpy as np\n\n    # Sub-function to perform edge recombination\n    def edge_recombination(parent1, parent2):\n        # Create the edge map from both parents\n        edge_map = {i: set() for i in range(N_P)}\n        for p in [parent1, parent2]:\n            for i in range(N_P):\n                next_city = p[(i + 1) % N_P]\n                prev_city = p[i - 1]\n                edge_map[p[i]].update({prev_city, next_city})\n\n        # Start with the first city of parent1 and build the child\n        current_city = parent1[0]\n        child = [current_city]\n        while len(child) < N_P:\n            # Remove the current city from the edge map\n            for edges in edge_map.values():\n                edges.discard(current_city)\n            # Choose the next city\n            if edge_map[current_city]:\n                next_city = min(edge_map[current_city], key=lambda x: len(edge_map[x]))\n            else:\n                next_city = np.random.choice(list(set(range(N_P)) - set(child)))\n            child.append(next_city)\n            current_city = next_city\n        return np.array(child, dtype=np.int32)\n\n    # Sub-function to perform inversion mutation\n    def inversion_mutation(individual):\n        if np.random.rand() < 0.1:  # mutation rate\n            start, end = sorted(np.random.choice(N_P, 2, replace=False))\n            individual[start:end + 1] = individual[start:end + 1][::-1]\n        return individual\n\n    # Create new population using edge recombination and inversion mutation\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(0, POP_SIZE, 2):\n        # Select parents based on rankings\n        sorted_indices = np.argsort(pops['rankings'])\n        parent1 = pops['individuals'][sorted_indices[i % POP_SIZE]]\n        parent2 = pops['individuals'][sorted_indices[(i + 1) % POP_SIZE]]\n\n        # Generate children and apply inversion mutation\n        child1 = edge_recombination(parent1, parent2)\n        child2 = edge_recombination(parent2, parent1)\n        child1 = inversion_mutation(child1)\n        child2 = inversion_mutation(child2)\n\n        # Assign children to new population\n        new_pops[i] = child1\n        if i + 1 < POP_SIZE:\n            new_pops[i + 1] = child2\n\n    return new_pops",
          "objective": 0.78006,
          "other_inf": null
     },
     {
          "algorithm": "city: set() for city in range(N_P)",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    # Novel algorithm: Edge recombination crossover with a preference for shorter edges and a simple inversion mutation.\n    import numpy as np\n\n    def edge_recombination_crossover(parent1, parent2):\n        # Create an edge map from both parents\n        edge_map = {city: set() for city in range(N_P)}\n        for p in [parent1, parent2]:\n            for i in range(len(p)):\n                left = p[i - 1]\n                right = p[(i + 1) % N_P]\n                edge_map[p[i]].update([left, right])\n\n        # Start with the first city of parent1 and build the child\n        current_city = parent1[0]\n        child = [current_city]\n        while len(child) < N_P:\n            # Remove current city from edge map\n            for edges in edge_map.values():\n                edges.discard(current_city)\n            # Choose next city with the fewest edges, preferring shorter distances\n            if edge_map[current_city]:\n                next_city = min(edge_map[current_city], key=lambda x: np.min(D_lst[:, current_city, x]))\n            else:  # No more edges, pick a random unvisited city\n                unvisited = list(set(range(N_P)) - set(child))\n                next_city = unvisited[np.random.randint(len(unvisited))]\n            child.append(next_city)\n            current_city = next_city\n\n        return np.array(child, dtype=np.int32)\n\n    def inversion_mutation(individual):\n        # Inversion mutation\n        idx1, idx2 = sorted(np.random.choice(N_P, 2, replace=False))\n        individual[idx1:idx2+1] = individual[idx1:idx2+1][::-1]\n        return individual\n\n    def select_parents(rankings):\n        # Tournament selection with a probability to choose the weaker opponent\n        idx1, idx2 = np.random.choice(np.arange(POP_SIZE), 2, replace=False)\n        return idx1 if (rankings[idx1] < rankings[idx2] and np.random.rand() < 0.75) else idx2\n\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n\n    # Main loop to generate new population\n    for i in range(0, POP_SIZE, 2):\n        parent1_idx = select_parents(pops['rankings'])\n        parent2_idx = select_parents(pops['rankings'])\n\n        parent1 = pops['individuals'][parent1_idx]\n        parent2 = pops['individuals'][parent2_idx]\n\n        child1 = edge_recombination_crossover(parent1, parent2)\n        child2 = edge_recombination_crossover(parent2, parent1)\n\n        child1 = inversion_mutation(child1)\n        child2 = inversion_mutation(child2)\n\n        new_pops[i, :] = child1\n        if i + 1 < POP_SIZE:\n            new_pops[i + 1, :] = child2\n\n    return new_pops",
          "objective": 0.77431,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n\n    def crossover(parent1, parent2):\n        child = np.empty(N_P, dtype=np.int32)\n        child.fill(-1)\n        start_pos, end_pos = sorted(np.random.choice(range(N_P), 2, replace=False))\n        child[start_pos:end_pos+1] = parent1[start_pos:end_pos+1]\n        for i in range(N_P):\n            if parent2[i] not in child:\n                for j in range(N_P):\n                    if child[j] == -1:\n                        child[j] = parent2[i]\n                        break\n        return child\n\n    def mutate(individual):\n        idx1, idx2 = np.random.choice(range(N_P), 2, replace=False)\n        individual[idx1], individual[idx2] = individual[idx2], individual[idx1]\n        return individual\n\n    def select_parents(ranking):\n        prob = 1 / (1 + ranking)\n        prob /= prob.sum()\n        parents_indices = np.random.choice(range(POP_SIZE), size=2, p=prob, replace=False)\n        return pops['individuals'][parents_indices[0]], pops['individuals'][parents_indices[1]]\n\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        parent1, parent2 = select_parents(pops['rankings'])\n        child = crossover(parent1, parent2)\n        if np.random.rand() < 0.2:  # Mutation probability\n            child = mutate(child)\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.76461,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n\n    # Intra-Sequence Ordered Crossover (ISOC) function\n    def ordered_crossover(parent1, parent2):\n        child = np.empty(N_P, dtype=np.int32)\n        child.fill(-1)\n        start_pos, end_pos = sorted(np.random.choice(range(N_P), 2, replace=False))\n        child[start_pos:end_pos+1] = parent1[start_pos:end_pos+1]\n        p2_filtered = [x for x in parent2 if x not in child[start_pos:end_pos+1]]\n        child[child == -1] = p2_filtered\n        return child\n\n    # Swap Mutation function\n    def swap_mutation(individual):\n        idx1, idx2 = np.random.choice(range(N_P), 2, replace=False)\n        individual[idx1], individual[idx2] = individual[idx2], individual[idx1]\n        return individual\n\n    # Tournament Selection function\n    def tournament_selection():\n        tournament_size = 3\n        selected_indices = np.random.choice(range(POP_SIZE), tournament_size, replace=False)\n        selected_rankings = pops['rankings'][selected_indices]\n        winner_index = selected_indices[np.argmin(selected_rankings)]\n        return pops['individuals'][winner_index]\n\n    # Generate new population\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        parent1 = tournament_selection()\n        parent2 = tournament_selection()\n        child = ordered_crossover(parent1, parent2)\n        if np.random.rand() < 0.15:  # Mutation probability\n            child = swap_mutation(child)\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.75341,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n\n    def crossover(parent1, parent2):\n        # Single point crossover\n        point = np.random.randint(1, N_P-1)\n        child = np.concatenate([parent1[:point], parent2[point:]])\n        return child\n\n    def mutate(individual):\n        # Swap mutation\n        idx1, idx2 = np.random.choice(N_P, 2, replace=False)\n        individual[idx1], individual[idx2] = individual[idx2], individual[idx1]\n        return individual\n\n    def repair(individual):\n        # Repair function to ensure all cities are included once\n        counts = np.bincount(individual, minlength=N_P)\n        for i in range(N_P):\n            while counts[i] > 1:\n                for j in range(N_P):\n                    if counts[j] == 0:\n                        individual[np.where(individual == i)[0][0]] = j\n                        counts = np.bincount(individual, minlength=N_P)\n                        break\n        return individual\n\n    def select_parents(rankings):\n        # Tournament selection\n        tournament_size = 5\n        indices = np.random.choice(np.arange(POP_SIZE), tournament_size, replace=False)\n        selected_index = indices[np.argmin(rankings[indices])]\n        return pops['individuals'][selected_index]\n\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    \n    for i in range(POP_SIZE):\n        # Selection\n        parent1 = select_parents(pops['rankings'])\n        parent2 = select_parents(pops['rankings'])\n        \n        # Crossover\n        child = crossover(parent1, parent2)\n        \n        # Mutation\n        child = mutate(child)\n        \n        # Repair\n        child = repair(child)\n        \n        new_pops[i, :] = child\n\n    return new_pops",
          "objective": 0.74719,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n\n    def crossover(parent1, parent2):\n        # Single-point crossover\n        point = np.random.randint(1, N_P - 1)\n        child1 = np.concatenate((parent1[:point], parent2[point:]))\n        child2 = np.concatenate((parent2[:point], parent1[point:]))\n        return child1, child2\n\n    def mutate(individual):\n        # Swap mutation\n        idx1, idx2 = np.random.choice(range(N_P), 2, replace=False)\n        individual[idx1], individual[idx2] = individual[idx2], individual[idx1]\n        return individual\n\n    def repair(individual):\n        # Repair function to handle duplicates and missing cities\n        counts = np.bincount(individual, minlength=N_P)\n        duplicates = np.where(counts > 1)[0]\n        missing = np.where(counts == 0)[0]\n        for dup, miss in zip(duplicates, missing):\n            individual[np.where(individual == dup)[0][0]] = miss\n        return individual\n\n    def select_parents(ranked_individuals):\n        # Tournament selection\n        tournament_size = 3\n        selected = []\n        for _ in range(2):\n            contenders_idx = np.random.choice(range(POP_SIZE), tournament_size, replace=False)\n            contenders = ranked_individuals[contenders_idx]\n            winner_idx = contenders_idx[np.argmin(contenders)]\n            selected.append(pops['individuals'][winner_idx])\n        return selected[0], selected[1]\n\n    # Main steps of the novel algorithm\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    ranked_individuals = pops['rankings'].argsort()\n    for i in range(0, POP_SIZE, 2):\n        parent1, parent2 = select_parents(ranked_individuals)\n        child1, child2 = crossover(parent1, parent2)\n        child1 = mutate(child1)\n        child2 = mutate(child2)\n        child1 = repair(child1)\n        child2 = repair(child2)\n        new_pops[i] = child1\n        if i + 1 < POP_SIZE:\n            new_pops[i + 1] = child2\n\n    return new_pops",
          "objective": 0.74334,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n\n    def crossover(parent1, parent2):\n        \"\"\"Perform ordered crossover between two parents.\"\"\"\n        start, end = sorted(np.random.choice(range(N_P), 2, replace=False))\n        child = -np.ones(N_P, dtype=np.int32)\n        child[start:end+1] = parent1[start:end+1]\n        pointer = 0\n        for city in parent2:\n            if city not in child:\n                while child[pointer] != -1:\n                    pointer += 1\n                child[pointer] = city\n        return child\n\n    def mutate(individual):\n        \"\"\"Perform swap mutation on an individual.\"\"\"\n        idx1, idx2 = np.random.choice(range(N_P), 2, replace=False)\n        individual[idx1], individual[idx2] = individual[idx2], individual[idx1]\n        return individual\n\n    def select_parents(ranked_population):\n        \"\"\"Select parents using tournament selection.\"\"\"\n        tournament_size = 2\n        selected_indices = np.random.choice(range(POP_SIZE), tournament_size, replace=False)\n        selected_rankings = ranked_population['rankings'][selected_indices]\n        winner_index = selected_indices[np.argmin(selected_rankings)]\n        return ranked_population['individuals'][winner_index]\n\n    # Main reproduction function\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        parent1 = select_parents(pops)\n        parent2 = select_parents(pops)\n        child = crossover(parent1, parent2)\n        child = mutate(child)\n        new_pops[i] = child\n    \n    return new_pops",
          "objective": 0.74185,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n\n    def crossover(parent1, parent2):\n        # Order crossover\n        start, end = sorted(np.random.choice(range(N_P), 2, replace=False))\n        child = [None]*N_P\n        child[start:end+1] = parent1[start:end+1]\n        pointer = 0\n        for city in parent2:\n            if city not in child:\n                while child[pointer] is not None:\n                    pointer += 1\n                child[pointer] = city\n        return child\n\n    def mutate(sequence):\n        # Swap mutation\n        idx1, idx2 = np.random.choice(range(N_P), 2, replace=False)\n        sequence[idx1], sequence[idx2] = sequence[idx2], sequence[idx1]\n        return sequence\n\n    def select_parents(ranked_individuals):\n        # Tournament selection\n        tournament_size = 2\n        selected_indices = np.random.choice(range(POP_SIZE), tournament_size, replace=False)\n        selected_individuals = ranked_individuals[selected_indices]\n        best_individual = selected_individuals[np.argmin(pops['rankings'][selected_indices])]\n        return best_individual\n\n    def repair(individual):\n        # Repair function to ensure all cities are visited once\n        counts = np.bincount(individual, minlength=N_P)\n        missing = np.where(counts == 0)[0]\n        for i in range(N_P):\n            if counts[individual[i]] > 1:\n                counts[individual[i]] -= 1\n                individual[i] = missing[-1]\n                missing = missing[:-1]\n        return individual\n\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    ranked_individuals = pops['individuals'][np.argsort(pops['rankings'])]\n\n    for i in range(POP_SIZE):\n        # Parent selection\n        parent1 = select_parents(ranked_individuals)\n        parent2 = select_parents(ranked_individuals)\n        # Crossover and mutation\n        child = crossover(parent1, parent2)\n        child = mutate(child)\n        # Repair the child if necessary\n        child = repair(child)\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.74134,
          "other_inf": null
     }
]