[
     {
          "algorithm": "i: set() for i in range(N_P)}\n        for i in range(N_P):\n            adjacency_list[parent1[i]].update({parent1[(i-1) % N_P], parent1[(i+1) % N_P]})\n            adjacency_list[parent2[i]].update({parent2[(i-1) % N_P], parent2[(i+1) % N_P]",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    \"\"\"\n    Introduce a novel reproduction function that combines edge recombination for crossover\n    and inversion mutation, followed by a fitness-based selection mechanism.\n    \"\"\"\n    import numpy as np\n    \n    def edge_recombination(parent1, parent2):\n        # Create the adjacency list for each node\n        adjacency_list = {i: set() for i in range(N_P)}\n        for i in range(N_P):\n            adjacency_list[parent1[i]].update({parent1[(i-1) % N_P], parent1[(i+1) % N_P]})\n            adjacency_list[parent2[i]].update({parent2[(i-1) % N_P], parent2[(i+1) % N_P]})\n        \n        # Start with a random city\n        current_city = np.random.choice(N_P)\n        child = [current_city]\n        \n        # Construct the child path\n        while len(child) < N_P:\n            for city in adjacency_list[current_city]:\n                adjacency_list[city].discard(current_city)\n            if adjacency_list[current_city]:\n                next_city = min(adjacency_list[current_city], key=lambda x: len(adjacency_list[x]))\n            else:\n                next_city = np.random.choice(list(set(range(N_P)) - set(child)))\n            child.append(next_city)\n            current_city = next_city\n        \n        return np.array(child, dtype=np.int32)\n    \n    def inversion_mutation(individual):\n        # Select two indices and invert the subsequence\n        idx1, idx2 = sorted(np.random.choice(range(N_P), 2, replace=False))\n        individual[idx1:idx2+1] = individual[idx1:idx2+1][::-1]\n        return individual\n    \n    def select_individual_by_fitness(ranking):\n        # Fitness proportionate selection\n        max_rank = np.max(ranking)\n        adjusted_fitness = max_rank + 1 - ranking\n        probabilities = adjusted_fitness / np.sum(adjusted_fitness)\n        selected_index = np.random.choice(range(POP_SIZE), p=probabilities)\n        return pops['individuals'][selected_index]\n    \n    # Generate the new population\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        parent1 = select_individual_by_fitness(pops['rankings'])\n        parent2 = select_individual_by_fitness(pops['rankings'])\n        child = edge_recombination(parent1, parent2)\n        if np.random.rand() < 0.2:  # Mutation probability\n            child = inversion_mutation(child)\n        new_pops[i] = child\n        \n    return new_pops",
          "objective": 0.83978,
          "other_inf": null
     },
     {
          "algorithm": "i: set() for i in range(N_P)}\n        for i in range(N_P):\n            edge_map[parent1[i]].update({parent1[(i - 1) % N_P], parent1[(i + 1) % N_P]})\n            edge_map[parent2[i]].update({parent2[(i - 1) % N_P], parent2[(i + 1) % N_P]",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n\n    # The common backbone idea: Generate a new population using selection, crossover, mutation, and repair mechanisms.\n    # New algorithm: Use edge recombination crossover with a heuristic mutation based on local travel cost improvements.\n\n    def edge_recombination_crossover(parent1, parent2):\n        # Create the edge map\n        edge_map = {i: set() for i in range(N_P)}\n        for i in range(N_P):\n            edge_map[parent1[i]].update({parent1[(i - 1) % N_P], parent1[(i + 1) % N_P]})\n            edge_map[parent2[i]].update({parent2[(i - 1) % N_P], parent2[(i + 1) % N_P]})\n\n        # Start with a random city\n        current_city = np.random.choice(range(N_P))\n        child = [current_city]\n\n        # Construct the child path\n        for _ in range(1, N_P):\n            for edges in edge_map.values():\n                edges.discard(current_city)  # Remove the current city from edge lists\n            if edge_map[current_city]:\n                next_city = min(edge_map[current_city], key=lambda x: len(edge_map[x]))\n            else:\n                next_city = np.random.choice(list(set(range(N_P)) - set(child)))\n            child.append(next_city)\n            current_city = next_city\n\n        return np.array(child, dtype=np.int32)\n\n    def heuristic_mutation(individual):\n        # Mutate based on the shortest travel cost between two cities\n        for _ in range(2):  # Perform two heuristic mutations\n            city1, city2 = np.random.choice(N_P, 2, replace=False)\n            if D_lst[0][city1, city2] + D_lst[0][city2, city1] < D_lst[0][city1, city1] + D_lst[0][city2, city2]:\n                individual[city1], individual[city2] = individual[city2], individual[city1]\n        return individual\n\n    def roulette_wheel_selection():\n        # Roulette wheel selection based on rankings\n        max_rank = np.max(pops['rankings']) + 1\n        selection_probs = (max_rank - pops['rankings']) / np.sum(max_rank - pops['rankings'])\n        selected_index = np.random.choice(range(POP_SIZE), p=selection_probs)\n        return pops['individuals'][selected_index]\n\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        parent1 = roulette_wheel_selection()\n        parent2 = roulette_wheel_selection()\n        child = edge_recombination_crossover(parent1, parent2)\n        child = heuristic_mutation(child)\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.82572,
          "other_inf": null
     },
     {
          "algorithm": "i: set() for i in range(N_P)",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n\n    def edge_recombination(parent1, parent2):\n        # Create an edge map with neighbors for each city\n        edge_map = {i: set() for i in range(N_P)}\n        for i in range(N_P):\n            for parent in [parent1, parent2]:\n                neighbors = [parent[j] for j in [i-1, (i+1) % N_P]]\n                edge_map[parent[i]].update(neighbors)\n        \n        # Initialize child with the first city of the first parent\n        child = [-1] * N_P\n        current_city = parent1[0]\n        child[0] = current_city\n        \n        # Construct the child path using the edge map\n        for i in range(1, N_P):\n            # Remove the current city from the edge map\n            for neighbors in edge_map.values():\n                neighbors.discard(current_city)\n            # Choose the next city with the fewest neighbors\n            if edge_map[current_city]:\n                next_city = min(edge_map[current_city], key=lambda x: len(edge_map[x]))\n            else:\n                # Randomly choose a city if no neighbors are left\n                next_city = np.random.choice([c for c in range(N_P) if c not in child])\n            child[i] = next_city\n            current_city = next_city\n        \n        return np.array(child, dtype=np.int32)\n\n    def inversion_mutation(individual):\n        # Inversion mutation by inverting a subsequence\n        idx1, idx2 = sorted(np.random.choice(range(N_P), 2, replace=False))\n        individual[idx1:idx2+1] = individual[idx1:idx2+1][::-1]\n        return individual\n\n    def rank_based_selection(ranked_individuals):\n        # Select parents based on their rank (lower rank has higher chance)\n        probabilities = 1 / (ranked_individuals + 1)\n        probabilities /= probabilities.sum()\n        selected_indices = np.random.choice(range(POP_SIZE), size=2, p=probabilities, replace=False)\n        return pops['individuals'][selected_indices[0]], pops['individuals'][selected_indices[1]]\n\n    # Main steps of the novel algorithm\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    ranked_individuals = np.argsort(pops['rankings'])\n    for i in range(0, POP_SIZE, 2):\n        parent1, parent2 = rank_based_selection(ranked_individuals)\n        child1 = edge_recombination(parent1, parent2)\n        child1 = inversion_mutation(child1)\n        # For odd-sized populations, avoid index out of bounds\n        if i + 1 < POP_SIZE:\n            child2 = edge_recombination(parent2, parent1)\n            child2 = inversion_mutation(child2)\n            new_pops[i + 1] = child2\n        new_pops[i] = child1\n\n    return new_pops",
          "objective": 0.82543,
          "other_inf": null
     },
     {
          "algorithm": "city: set() for city in range(N_P)",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n\n    # Novel reproduction function: Edge Recombination Crossover (ERX) with Distance-based Mutation\n    def edge_recombination_crossover(parent1, parent2):\n        # Create the edge map from both parents\n        def create_edge_map(p1, p2):\n            edge_map = {city: set() for city in range(N_P)}\n            for i in range(N_P):\n                prev_city = p1[i-1]\n                next_city = p1[(i+1) % N_P]\n                edge_map[p1[i]].update([prev_city, next_city])\n                prev_city = p2[i-1]\n                next_city = p2[(i+1) % N_P]\n                edge_map[p2[i]].update([prev_city, next_city])\n            return edge_map\n\n        # Build the child using the edge map\n        def build_child(edge_map):\n            current_city = np.random.choice(N_P)\n            child = [current_city]\n            while len(child) < N_P:\n                neighbors = edge_map[current_city]\n                for city in neighbors:\n                    edge_map[city].discard(current_city)\n                if neighbors:\n                    current_city = min(neighbors, key=lambda x: len(edge_map[x]))\n                else:\n                    remaining_cities = list(set(range(N_P)) - set(child))\n                    current_city = np.random.choice(remaining_cities)\n                child.append(current_city)\n            return child\n\n        edge_map = create_edge_map(parent1, parent2)\n        child = build_child(edge_map)\n        return child\n\n    def distance_based_mutation(individual):\n        # Find the two cities with the longest distance and swap them\n        max_distance = 0\n        idx1, idx2 = -1, -1\n        for i in range(N_P):\n            for j in range(i+1, N_P):\n                distance = D_lst[0][individual[i]][individual[j]]\n                if distance > max_distance:\n                    max_distance = distance\n                    idx1, idx2 = i, j\n        individual[idx1], individual[idx2] = individual[idx2], individual[idx1]\n        return individual\n\n    def tournament_selection():\n        # Select two random individuals and return the best one\n        i1, i2 = np.random.choice(range(POP_SIZE), 2, replace=False)\n        if pops['rankings'][i1] < pops['rankings'][i2]:\n            return pops['individuals'][i1]\n        else:\n            return pops['individuals'][i2]\n\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        parent1 = tournament_selection()\n        parent2 = tournament_selection()\n        child = edge_recombination_crossover(parent1, parent2)\n        if np.random.rand() < 0.1:  # Mutation probability\n            child = distance_based_mutation(child)\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.82198,
          "other_inf": null
     },
     {
          "algorithm": "i: set() for i in range(N_P)",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    \"\"\"\n    The new algorithm uses a simple edge recombination operator for crossover and a scramble mutation,\n    aiming to preserve edge information and introduce diversity.\n    \"\"\"\n    import numpy as np\n    \n    def edge_recombination(parent1, parent2):\n        # Create an adjacency list for both parents\n        adjacency_list = {i: set() for i in range(N_P)}\n        for p in [parent1, parent2]:\n            for i in range(N_P):\n                next_city = p[(i + 1) % N_P]\n                prev_city = p[(i - 1) % N_P]\n                adjacency_list[p[i]].update([next_city, prev_city])\n        \n        # Start with a random city\n        current_city = np.random.choice(N_P)\n        child = [current_city]\n        \n        # Build the child path\n        while len(child) < N_P:\n            # Remove the used city from the adjacency list\n            for neighbors in adjacency_list.values():\n                neighbors.discard(current_city)\n            # Choose the next city with the fewest choices in the adjacency list\n            if adjacency_list[current_city]:\n                next_city = min(adjacency_list[current_city], key=lambda x: len(adjacency_list[x]))\n            else:\n                remaining_cities = list(set(range(N_P)) - set(child))\n                next_city = np.random.choice(remaining_cities)\n            child.append(next_city)\n            current_city = next_city\n        \n        return child\n    \n    def scramble_mutation(individual):\n        # Choose a subsequence to shuffle\n        start, end = sorted(np.random.choice(range(N_P), 2, replace=False))\n        subseq = np.random.permutation(individual[start:end])\n        individual[start:end] = subseq\n        return individual\n    \n    def tournament_selection(ranked_individuals):\n        # Randomly select a small number of individuals and choose the best\n        tournament_size = 3\n        selected_indices = np.random.choice(ranked_individuals, size=tournament_size, replace=False)\n        best_index = np.argmin(pops['rankings'][selected_indices])\n        return pops['individuals'][selected_indices[best_index]]\n    \n    ranked_individuals = np.argsort(pops['rankings'])\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    \n    for i in range(POP_SIZE):\n        # Select parents using tournament selection\n        parent1 = tournament_selection(ranked_individuals)\n        parent2 = tournament_selection(ranked_individuals)\n        # Generate offspring using edge recombination\n        child = edge_recombination(parent1, parent2)\n        # Apply scramble mutation with a certain probability\n        if np.random.rand() < 0.1:  # mutation probability\n            child = scramble_mutation(child)\n        new_pops[i] = child\n    \n    return new_pops",
          "objective": 0.82085,
          "other_inf": null
     },
     {
          "algorithm": "i: set() for i in range(N_P)}\n            for i in range(N_P):\n                idx = np.where(p1 == i)[0][0]\n                neighbors = {p1[idx - 1], p1[(idx + 1) % N_P]}\n                idx = np.where(p2 == i)[0][0]\n                neighbors |= {p2[idx - 1], p2[(idx + 1) % N_P]",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n    \n    # Novel reproduction function: Edge Recombination Crossover (ERX) with Random Resetting Mutation (RRM)\n    \n    def edge_recombination_crossover(parent1, parent2):\n        # Create the edge map (adjacency list) for both parents\n        def create_edge_map(p1, p2):\n            edge_map = {i: set() for i in range(N_P)}\n            for i in range(N_P):\n                idx = np.where(p1 == i)[0][0]\n                neighbors = {p1[idx - 1], p1[(idx + 1) % N_P]}\n                idx = np.where(p2 == i)[0][0]\n                neighbors |= {p2[idx - 1], p2[(idx + 1) % N_P]}\n                edge_map[i] = neighbors\n            return edge_map\n        \n        edge_map = create_edge_map(parent1, parent2)\n        current_city = np.random.choice(N_P)\n        child = [current_city]\n        \n        # Construct the child path\n        while len(child) < N_P:\n            if edge_map[current_city]:\n                next_city = min(edge_map[current_city], key=lambda x: len(edge_map[x]))\n                edge_map[current_city].remove(next_city)\n            else:\n                next_city = np.random.choice(list(set(range(N_P)) - set(child)))\n            for edges in edge_map.values():\n                edges.discard(current_city)\n            current_city = next_city\n            child.append(current_city)\n        \n        return np.array(child, dtype=np.int32)\n    \n    def random_resetting_mutation(individual):\n        mutation_indices = np.random.choice(range(N_P), 2, replace=False)\n        individual[mutation_indices] = individual[np.flip(mutation_indices)]\n        return individual\n    \n    individuals = pops['individuals']\n    rankings = pops['rankings']\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    \n    # Generate new population\n    for i in range(POP_SIZE):\n        parent1 = individuals[np.argmin(rankings)]\n        parent2 = individuals[np.random.choice([j for j in range(POP_SIZE) if j != np.argmin(rankings)])]\n        child = edge_recombination_crossover(parent1, parent2)\n        if np.random.rand() < 0.1:  # mutation probability\n            child = random_resetting_mutation(child)\n        new_pops[i] = child\n    \n    return new_pops",
          "objective": 0.81595,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    \"\"\"\n    Novel algorithm: Order crossover with a preference for shorter paths and a swap mutation,\n    followed by a local search using 2-opt for path improvement.\n    \"\"\"\n    import numpy as np\n\n    def order_crossover(parent1, parent2):\n        # Order crossover operator\n        start, end = sorted(np.random.choice(N_P, 2, replace=False))\n        child = -np.ones(N_P, dtype=np.int32)\n        child[start:end+1] = parent1[start:end+1]\n        p2_extended = np.hstack((parent2[end+1:], parent2[:end+1]))\n        for city in p2_extended:\n            if city not in child:\n                idx = np.where(child == -1)[0][0]\n                child[idx] = city\n        return child\n\n    def swap_mutation(individual):\n        # Swap mutation\n        idx1, idx2 = np.random.choice(N_P, 2, replace=False)\n        individual[idx1], individual[idx2] = individual[idx2], individual[idx1]\n        return individual\n\n    def two_opt_local_search(individual, D):\n        # Local search using 2-opt\n        improved = True\n        while improved:\n            improved = False\n            for i in range(1, N_P - 1):\n                for j in range(i + 1, N_P):\n                    if D[individual[i-1], individual[i]] + D[individual[j], individual[(j+1)%N_P]] > \\\n                       D[individual[i-1], individual[j]] + D[individual[i], individual[(j+1)%N_P]]:\n                        individual[i:j+1] = individual[i:j+1][::-1]\n                        improved = True\n        return individual\n\n    def select_parents(rankings):\n        # Tournament selection with a probability to choose the weaker opponent\n        idx1, idx2 = np.random.choice(np.arange(POP_SIZE), 2, replace=False)\n        return idx1 if (rankings[idx1] < rankings[idx2] and np.random.rand() < 0.75) else idx2\n\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    D = np.mean(D_lst, axis=0)  # Average cost matrix for 2-opt heuristic\n\n    # Main loop to generate new population\n    for i in range(POP_SIZE):\n        parent1_idx = select_parents(pops['rankings'])\n        parent2_idx = select_parents(pops['rankings'])\n\n        parent1 = pops['individuals'][parent1_idx]\n        parent2 = pops['individuals'][parent2_idx]\n\n        child = order_crossover(parent1, parent2)\n        child = swap_mutation(child)\n        child = two_opt_local_search(child, D)\n\n        new_pops[i, :] = child\n\n    return new_pops",
          "objective": 0.81058,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n\n    def tournament_selection(individuals, rankings, tournament_size=3):\n        selected_indices = np.random.choice(len(rankings), tournament_size, replace=False)\n        tournament_individuals = rankings[selected_indices]\n        winner_index = selected_indices[np.argmin(tournament_individuals)]\n        return individuals[winner_index]\n\n    def order_crossover(parent1, parent2):\n        child = np.empty(N_P, dtype=np.int32)\n        child.fill(-1)\n        start_pos, end_pos = sorted(np.random.choice(range(N_P), 2, replace=False))\n        child[start_pos:end_pos+1] = parent1[start_pos:end_pos+1]\n        pos = end_pos + 1 if end_pos < (N_P - 1) else 0\n        for city in parent2:\n            if city not in child:\n                child[pos] = city\n                pos = pos + 1 if pos < (N_P - 1) else 0\n        return child\n\n    def inversion_mutation(individual):\n        start_pos, end_pos = sorted(np.random.choice(range(N_P), 2, replace=False))\n        individual[start_pos:end_pos+1] = individual[start_pos:end_pos+1][::-1]\n        return individual\n\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n\n    for i in range(POP_SIZE):\n        parent1 = tournament_selection(individuals, rankings)\n        parent2 = tournament_selection(individuals, rankings)\n        child = order_crossover(parent1, parent2)\n        if np.random.rand() < 0.2:  # mutation probability\n            child = inversion_mutation(child)\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.79781,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n\n    def ordered_crossover(parent1, parent2):\n        # Ordered crossover\n        start, end = sorted(np.random.choice(range(N_P), 2, replace=False))\n        child = np.full(N_P, -1, dtype=np.int32)\n        child[start:end] = parent1[start:end]\n        parent2_filtered = [city for city in parent2 if city not in child]\n        child[child == -1] = parent2_filtered\n        return child\n\n    def inversion_mutation(individual):\n        # Inversion mutation\n        start, end = sorted(np.random.choice(range(N_P), 2, replace=False))\n        individual[start:end] = individual[start:end][::-1]\n        return individual\n\n    def rank_based_selection(ranked_individuals):\n        # Rank-based selection\n        probabilities = 1 / (np.arange(1, POP_SIZE + 1))\n        probabilities /= probabilities.sum()\n        selected_indices = np.random.choice(ranked_individuals, size=2, p=probabilities, replace=False)\n        return pops['individuals'][selected_indices]\n\n    # Main steps of the novel algorithm\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    ranked_individuals = pops['rankings'].argsort()\n    for i in range(0, POP_SIZE, 2):\n        parent1, parent2 = rank_based_selection(ranked_individuals)\n        child1 = ordered_crossover(parent1, parent2)\n        child2 = ordered_crossover(parent2, parent1)\n        child1 = inversion_mutation(child1)\n        child2 = inversion_mutation(child2)\n        new_pops[i] = child1\n        if i + 1 < POP_SIZE:\n            new_pops[i + 1] = child2\n\n    return new_pops",
          "objective": 0.79537,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n\n    def crossover(parent1, parent2):\n        child = np.empty(N_P, dtype=np.int32)\n        child.fill(-1)\n        start_pos, end_pos = sorted(np.random.choice(range(N_P), 2, replace=False))\n        child[start_pos:end_pos+1] = parent1[start_pos:end_pos+1]\n        p2_filtered = [city for city in parent2 if city not in child]\n        child[child == -1] = p2_filtered\n        return child\n\n    def mutate(individual):\n        idx1, idx2 = np.random.choice(range(N_P), 2, replace=False)\n        individual[idx1], individual[idx2] = individual[idx2], individual[idx1]\n        return individual\n\n    def select_parents(ranked_individuals):\n        return ranked_individuals[np.random.choice(range(POP_SIZE), 2, p=selection_probs)]\n\n    ranked_individuals = pops['individuals'][np.argsort(pops['rankings'])]\n    fitness_values = 1 / (1 + np.argsort(np.argsort(pops['rankings'])))\n    selection_probs = fitness_values / fitness_values.sum()\n\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        parent1, parent2 = select_parents(ranked_individuals)\n        child = crossover(parent1, parent2)\n        if np.random.rand() < 0.2:  # mutation probability\n            child = mutate(child)\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.78892,
          "other_inf": null
     }
]