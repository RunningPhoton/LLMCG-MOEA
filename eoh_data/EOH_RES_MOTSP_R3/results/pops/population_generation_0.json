[
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n\n    def crossover(parent1, parent2):\n        child = np.empty(N_P, dtype=np.int32)\n        child.fill(-1)\n        start_pos, end_pos = sorted(np.random.choice(range(N_P), 2, replace=False))\n        child[start_pos:end_pos+1] = parent1[start_pos:end_pos+1]\n        p2_filtered = [city for city in parent2 if city not in child]\n        child[child == -1] = p2_filtered\n        return child\n\n    def mutate(individual):\n        idx1, idx2 = np.random.choice(range(N_P), 2, replace=False)\n        individual[idx1], individual[idx2] = individual[idx2], individual[idx1]\n        return individual\n\n    def select_parents(ranked_individuals):\n        return ranked_individuals[np.random.choice(range(POP_SIZE), 2, p=selection_probs)]\n\n    ranked_individuals = pops['individuals'][np.argsort(pops['rankings'])]\n    fitness_values = 1 / (1 + np.argsort(np.argsort(pops['rankings'])))\n    selection_probs = fitness_values / fitness_values.sum()\n\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        parent1, parent2 = select_parents(ranked_individuals)\n        child = crossover(parent1, parent2)\n        if np.random.rand() < 0.2:  # mutation probability\n            child = mutate(child)\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.78892,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n\n    def crossover(parent1, parent2):\n        child = np.empty(N_P, dtype=np.int32)\n        child.fill(-1)\n        start_pos, end_pos = sorted(np.random.choice(range(N_P), 2, replace=False))\n        child[start_pos:end_pos+1] = parent1[start_pos:end_pos+1]\n        for i in range(N_P):\n            if parent2[i] not in child:\n                for j in range(N_P):\n                    if child[j] == -1:\n                        child[j] = parent2[i]\n                        break\n        return child\n\n    def mutate(individual):\n        idx1, idx2 = np.random.choice(range(N_P), 2, replace=False)\n        individual[idx1], individual[idx2] = individual[idx2], individual[idx1]\n        return individual\n\n    def select_parents(ranking):\n        prob = 1 / (1 + ranking)\n        prob /= prob.sum()\n        parents_indices = np.random.choice(range(POP_SIZE), size=2, p=prob, replace=False)\n        return pops['individuals'][parents_indices[0]], pops['individuals'][parents_indices[1]]\n\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        parent1, parent2 = select_parents(pops['rankings'])\n        child = crossover(parent1, parent2)\n        if np.random.rand() < 0.2:  # Mutation probability\n            child = mutate(child)\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.76461,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n\n    def crossover(parent1, parent2):\n        # Single point crossover\n        point = np.random.randint(1, N_P-1)\n        child = np.concatenate([parent1[:point], parent2[point:]])\n        return child\n\n    def mutate(individual):\n        # Swap mutation\n        idx1, idx2 = np.random.choice(N_P, 2, replace=False)\n        individual[idx1], individual[idx2] = individual[idx2], individual[idx1]\n        return individual\n\n    def repair(individual):\n        # Repair function to ensure all cities are included once\n        counts = np.bincount(individual, minlength=N_P)\n        for i in range(N_P):\n            while counts[i] > 1:\n                for j in range(N_P):\n                    if counts[j] == 0:\n                        individual[np.where(individual == i)[0][0]] = j\n                        counts = np.bincount(individual, minlength=N_P)\n                        break\n        return individual\n\n    def select_parents(rankings):\n        # Tournament selection\n        tournament_size = 5\n        indices = np.random.choice(np.arange(POP_SIZE), tournament_size, replace=False)\n        selected_index = indices[np.argmin(rankings[indices])]\n        return pops['individuals'][selected_index]\n\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    \n    for i in range(POP_SIZE):\n        # Selection\n        parent1 = select_parents(pops['rankings'])\n        parent2 = select_parents(pops['rankings'])\n        \n        # Crossover\n        child = crossover(parent1, parent2)\n        \n        # Mutation\n        child = mutate(child)\n        \n        # Repair\n        child = repair(child)\n        \n        new_pops[i, :] = child\n\n    return new_pops",
          "objective": 0.74719,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n\n    def crossover(parent1, parent2):\n        # Single-point crossover\n        point = np.random.randint(1, N_P - 1)\n        child1 = np.concatenate((parent1[:point], parent2[point:]))\n        child2 = np.concatenate((parent2[:point], parent1[point:]))\n        return child1, child2\n\n    def mutate(individual):\n        # Swap mutation\n        idx1, idx2 = np.random.choice(range(N_P), 2, replace=False)\n        individual[idx1], individual[idx2] = individual[idx2], individual[idx1]\n        return individual\n\n    def repair(individual):\n        # Repair function to handle duplicates and missing cities\n        counts = np.bincount(individual, minlength=N_P)\n        duplicates = np.where(counts > 1)[0]\n        missing = np.where(counts == 0)[0]\n        for dup, miss in zip(duplicates, missing):\n            individual[np.where(individual == dup)[0][0]] = miss\n        return individual\n\n    def select_parents(ranked_individuals):\n        # Tournament selection\n        tournament_size = 3\n        selected = []\n        for _ in range(2):\n            contenders_idx = np.random.choice(range(POP_SIZE), tournament_size, replace=False)\n            contenders = ranked_individuals[contenders_idx]\n            winner_idx = contenders_idx[np.argmin(contenders)]\n            selected.append(pops['individuals'][winner_idx])\n        return selected[0], selected[1]\n\n    # Main steps of the novel algorithm\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    ranked_individuals = pops['rankings'].argsort()\n    for i in range(0, POP_SIZE, 2):\n        parent1, parent2 = select_parents(ranked_individuals)\n        child1, child2 = crossover(parent1, parent2)\n        child1 = mutate(child1)\n        child2 = mutate(child2)\n        child1 = repair(child1)\n        child2 = repair(child2)\n        new_pops[i] = child1\n        if i + 1 < POP_SIZE:\n            new_pops[i + 1] = child2\n\n    return new_pops",
          "objective": 0.74334,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n\n    def crossover(parent1, parent2):\n        \"\"\"Perform ordered crossover between two parents.\"\"\"\n        start, end = sorted(np.random.choice(range(N_P), 2, replace=False))\n        child = -np.ones(N_P, dtype=np.int32)\n        child[start:end+1] = parent1[start:end+1]\n        pointer = 0\n        for city in parent2:\n            if city not in child:\n                while child[pointer] != -1:\n                    pointer += 1\n                child[pointer] = city\n        return child\n\n    def mutate(individual):\n        \"\"\"Perform swap mutation on an individual.\"\"\"\n        idx1, idx2 = np.random.choice(range(N_P), 2, replace=False)\n        individual[idx1], individual[idx2] = individual[idx2], individual[idx1]\n        return individual\n\n    def select_parents(ranked_population):\n        \"\"\"Select parents using tournament selection.\"\"\"\n        tournament_size = 2\n        selected_indices = np.random.choice(range(POP_SIZE), tournament_size, replace=False)\n        selected_rankings = ranked_population['rankings'][selected_indices]\n        winner_index = selected_indices[np.argmin(selected_rankings)]\n        return ranked_population['individuals'][winner_index]\n\n    # Main reproduction function\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        parent1 = select_parents(pops)\n        parent2 = select_parents(pops)\n        child = crossover(parent1, parent2)\n        child = mutate(child)\n        new_pops[i] = child\n    \n    return new_pops",
          "objective": 0.74185,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n\n    def crossover(parent1, parent2):\n        # Order crossover\n        start, end = sorted(np.random.choice(range(N_P), 2, replace=False))\n        child = [None]*N_P\n        child[start:end+1] = parent1[start:end+1]\n        pointer = 0\n        for city in parent2:\n            if city not in child:\n                while child[pointer] is not None:\n                    pointer += 1\n                child[pointer] = city\n        return child\n\n    def mutate(sequence):\n        # Swap mutation\n        idx1, idx2 = np.random.choice(range(N_P), 2, replace=False)\n        sequence[idx1], sequence[idx2] = sequence[idx2], sequence[idx1]\n        return sequence\n\n    def select_parents(ranked_individuals):\n        # Tournament selection\n        tournament_size = 2\n        selected_indices = np.random.choice(range(POP_SIZE), tournament_size, replace=False)\n        selected_individuals = ranked_individuals[selected_indices]\n        best_individual = selected_individuals[np.argmin(pops['rankings'][selected_indices])]\n        return best_individual\n\n    def repair(individual):\n        # Repair function to ensure all cities are visited once\n        counts = np.bincount(individual, minlength=N_P)\n        missing = np.where(counts == 0)[0]\n        for i in range(N_P):\n            if counts[individual[i]] > 1:\n                counts[individual[i]] -= 1\n                individual[i] = missing[-1]\n                missing = missing[:-1]\n        return individual\n\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    ranked_individuals = pops['individuals'][np.argsort(pops['rankings'])]\n\n    for i in range(POP_SIZE):\n        # Parent selection\n        parent1 = select_parents(ranked_individuals)\n        parent2 = select_parents(ranked_individuals)\n        # Crossover and mutation\n        child = crossover(parent1, parent2)\n        child = mutate(child)\n        # Repair the child if necessary\n        child = repair(child)\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.74134,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n    \n    def crossover(parent1, parent2):\n        # Single-point crossover\n        point = np.random.randint(1, N_P - 1)\n        child1 = np.concatenate((parent1[:point], parent2[point:]))\n        child2 = np.concatenate((parent2[:point], parent1[point:]))\n        return child1, child2\n\n    def mutate(individual):\n        # Swap mutation\n        idx1, idx2 = np.random.choice(N_P, 2, replace=False)\n        individual[idx1], individual[idx2] = individual[idx2], individual[idx1]\n        return individual\n\n    def repair(individual):\n        # Repair to handle any duplicate cities\n        counts = np.bincount(individual, minlength=N_P)\n        duplicates = np.where(counts > 1)[0]\n        missing = np.where(counts == 0)[0]\n        for dup, miss in zip(duplicates, missing):\n            individual[np.where(individual == dup)[0][0]] = miss\n        return individual\n\n    def select_parents(rankings):\n        # Tournament selection\n        idx1, idx2 = np.random.choice(np.arange(POP_SIZE), 2, replace=False)\n        return idx1 if rankings[idx1] < rankings[idx2] else idx2\n    \n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    \n    # Main loop to generate new population\n    for i in range(0, POP_SIZE, 2):\n        parent1_idx = select_parents(pops['rankings'])\n        parent2_idx = select_parents(pops['rankings'])\n        \n        parent1 = pops['individuals'][parent1_idx]\n        parent2 = pops['individuals'][parent2_idx]\n        \n        child1, child2 = crossover(parent1, parent2)\n        child1 = mutate(child1)\n        child2 = mutate(child2)\n        \n        child1 = repair(child1)\n        child2 = repair(child2)\n        \n        new_pops[i, :] = child1\n        if i + 1 < POP_SIZE:\n            new_pops[i + 1, :] = child2\n    \n    return new_pops",
          "objective": 0.73323,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n\n    def crossover(parent1, parent2):\n        \"\"\"Perform a simple crossover between two parents to produce two children.\"\"\"\n        crossover_point = np.random.randint(1, N_P)\n        child1 = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        child2 = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))\n        return child1, child2\n\n    def mutate(individual):\n        \"\"\"Perform a simple swap mutation on an individual.\"\"\"\n        idx1, idx2 = np.random.choice(N_P, 2, replace=False)\n        individual[idx1], individual[idx2] = individual[idx2], individual[idx1]\n        return individual\n\n    def repair(individual):\n        \"\"\"Repair an individual if it contains duplicate cities.\"\"\"\n        unique, counts = np.unique(individual, return_counts=True)\n        duplicates = unique[counts > 1]\n        missing = np.setdiff1d(np.arange(N_P), unique)\n        for dup in duplicates:\n            idx = np.where(individual == dup)[0]\n            individual[np.random.choice(idx[1:])] = missing[0]\n            missing = missing[1:]\n        return individual\n\n    def create_new_individual():\n        \"\"\"Create a new individual by crossover and mutation.\"\"\"\n        parents_indices = np.random.choice(POP_SIZE, 2, replace=False, p=selection_probs)\n        parent1, parent2 = pops['individuals'][parents_indices]\n        child1, child2 = crossover(parent1, parent2)\n        child1 = mutate(child1)\n        child2 = mutate(child2)\n        child1 = repair(child1)\n        child2 = repair(child2)\n        return child1 if np.random.rand() < 0.5 else child2\n\n    # Calculate selection probabilities inversely proportional to rankings\n    min_rank = np.min(pops['rankings'])\n    max_rank = np.max(pops['rankings'])\n    ranks_normalized = (pops['rankings'] - min_rank) / (max_rank - min_rank + 1e-6)\n    selection_probs = (1 - ranks_normalized) / np.sum(1 - ranks_normalized)\n\n    # Generate new population\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        new_pops[i] = create_new_individual()\n\n    return new_pops",
          "objective": 0.73252,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n\n    def crossover(parent1, parent2):\n        # Single-point crossover\n        point = np.random.randint(1, N_P - 1)\n        child1 = np.concatenate((parent1[:point], parent2[point:]))\n        child2 = np.concatenate((parent2[:point], parent1[point:]))\n        return child1, child2\n\n    def mutate(individual):\n        # Swap mutation\n        idx1, idx2 = np.random.choice(N_P, 2, replace=False)\n        individual[idx1], individual[idx2] = individual[idx2], individual[idx1]\n        return individual\n\n    def repair(individual):\n        # Repair function to ensure every city is visited once\n        unique, counts = np.unique(individual, return_counts=True)\n        surplus = unique[counts > 1]\n        missing = np.setdiff1d(np.arange(N_P), unique)\n        for s in surplus:\n            idx = np.where(individual == s)[0]\n            individual[np.random.choice(idx)] = missing[0]\n            missing = missing[1:]\n        return individual\n\n    def select_parents(ranking):\n        # Tournament selection\n        tournament_size = 2\n        selected_indices = np.random.choice(POP_SIZE, tournament_size, replace=False)\n        selected_rankings = ranking[selected_indices]\n        return selected_indices[np.argmin(selected_rankings)]\n\n    # Main reproduction function\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(0, POP_SIZE, 2):\n        parent1_idx = select_parents(pops['rankings'])\n        parent2_idx = select_parents(pops['rankings'])\n        parent1, parent2 = pops['individuals'][parent1_idx], pops['individuals'][parent2_idx]\n        child1, child2 = crossover(parent1, parent2)\n        child1, child2 = mutate(child1), mutate(child2)\n        child1, child2 = repair(child1), repair(child2)\n        new_pops[i], new_pops[i + 1] = child1, child2\n\n    return new_pops",
          "objective": 0.72696,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n\n    def tournament_selection(rankings, tournament_size=2):\n        selected_indices = []\n        for _ in range(POP_SIZE):\n            participants = np.random.choice(np.arange(POP_SIZE), tournament_size, replace=False)\n            winner = participants[np.argmin(rankings[participants])]\n            selected_indices.append(winner)\n        return selected_indices\n\n    def crossover(parent1, parent2):\n        crossover_point = np.random.randint(1, N_P - 1)\n        child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        return np.array([child[np.searchsorted(child, i, side='right') % len(child)] for i in range(N_P)], dtype=np.int32)\n\n    def mutate(individual, mutation_rate=0.1):\n        if np.random.rand() < mutation_rate:\n            swap_indices = np.random.choice(N_P, 2, replace=False)\n            individual[swap_indices[0]], individual[swap_indices[1]] = individual[swap_indices[1]], individual[swap_indices[0]]\n        return individual\n\n    def repair(individual):\n        counts = np.bincount(individual, minlength=N_P)\n        for i in range(N_P):\n            while counts[i] > 1:\n                for j in range(N_P):\n                    if counts[j] == 0:\n                        individual[np.where(individual == i)[0][0]] = j\n                        counts[i] -= 1\n                        counts[j] += 1\n                        break\n        return individual\n\n    def create_new_individual():\n        individual = np.random.permutation(N_P)\n        return repair(mutate(individual))\n\n    selected_indices = tournament_selection(pops['rankings'])\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(0, POP_SIZE, 2):\n        parent1 = pops['individuals'][selected_indices[i]]\n        parent2 = pops['individuals'][selected_indices[(i + 1) % POP_SIZE]]\n        new_pops[i] = repair(crossover(parent1, parent2))\n        if i + 1 < POP_SIZE:\n            new_pops[i + 1] = repair(crossover(parent2, parent1))\n\n    # Fill the rest of the new population with new individuals\n    for i in range(POP_SIZE):\n        if np.random.rand() < 0.05:  # Randomly introduce new individuals\n            new_pops[i] = create_new_individual()\n\n    return new_pops",
          "objective": 0.33488,
          "other_inf": null
     }
]