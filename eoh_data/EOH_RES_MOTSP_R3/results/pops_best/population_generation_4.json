{
     "algorithm": "i: set() for i in range(N_P)}\n        for i in range(N_P):\n            adjacency_list[parent1[i]].update({parent1[(i-1) % N_P], parent1[(i+1) % N_P]})\n            adjacency_list[parent2[i]].update({parent2[(i-1) % N_P], parent2[(i+1) % N_P]",
     "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    \"\"\"\n    Introduce a novel reproduction function that combines edge recombination for crossover\n    and inversion mutation, followed by a fitness-based selection mechanism.\n    \"\"\"\n    import numpy as np\n    \n    def edge_recombination(parent1, parent2):\n        # Create the adjacency list for each node\n        adjacency_list = {i: set() for i in range(N_P)}\n        for i in range(N_P):\n            adjacency_list[parent1[i]].update({parent1[(i-1) % N_P], parent1[(i+1) % N_P]})\n            adjacency_list[parent2[i]].update({parent2[(i-1) % N_P], parent2[(i+1) % N_P]})\n        \n        # Start with a random city\n        current_city = np.random.choice(N_P)\n        child = [current_city]\n        \n        # Construct the child path\n        while len(child) < N_P:\n            for city in adjacency_list[current_city]:\n                adjacency_list[city].discard(current_city)\n            if adjacency_list[current_city]:\n                next_city = min(adjacency_list[current_city], key=lambda x: len(adjacency_list[x]))\n            else:\n                next_city = np.random.choice(list(set(range(N_P)) - set(child)))\n            child.append(next_city)\n            current_city = next_city\n        \n        return np.array(child, dtype=np.int32)\n    \n    def inversion_mutation(individual):\n        # Select two indices and invert the subsequence\n        idx1, idx2 = sorted(np.random.choice(range(N_P), 2, replace=False))\n        individual[idx1:idx2+1] = individual[idx1:idx2+1][::-1]\n        return individual\n    \n    def select_individual_by_fitness(ranking):\n        # Fitness proportionate selection\n        max_rank = np.max(ranking)\n        adjusted_fitness = max_rank + 1 - ranking\n        probabilities = adjusted_fitness / np.sum(adjusted_fitness)\n        selected_index = np.random.choice(range(POP_SIZE), p=probabilities)\n        return pops['individuals'][selected_index]\n    \n    # Generate the new population\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        parent1 = select_individual_by_fitness(pops['rankings'])\n        parent2 = select_individual_by_fitness(pops['rankings'])\n        child = edge_recombination(parent1, parent2)\n        if np.random.rand() < 0.2:  # Mutation probability\n            child = inversion_mutation(child)\n        new_pops[i] = child\n        \n    return new_pops",
     "objective": 0.83978,
     "other_inf": null
}