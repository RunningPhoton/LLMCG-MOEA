{
     "algorithm": "i: set() for i in range(N_P)",
     "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n\n    def edge_recombination(parent1, parent2):\n        # Create an edge map with neighbors for each city\n        edge_map = {i: set() for i in range(N_P)}\n        for i in range(N_P):\n            for parent in [parent1, parent2]:\n                neighbors = [parent[j] for j in [i-1, (i+1) % N_P]]\n                edge_map[parent[i]].update(neighbors)\n        \n        # Initialize child with the first city of the first parent\n        child = [-1] * N_P\n        current_city = parent1[0]\n        child[0] = current_city\n        \n        # Construct the child path using the edge map\n        for i in range(1, N_P):\n            # Remove the current city from the edge map\n            for neighbors in edge_map.values():\n                neighbors.discard(current_city)\n            # Choose the next city with the fewest neighbors\n            if edge_map[current_city]:\n                next_city = min(edge_map[current_city], key=lambda x: len(edge_map[x]))\n            else:\n                # Randomly choose a city if no neighbors are left\n                next_city = np.random.choice([c for c in range(N_P) if c not in child])\n            child[i] = next_city\n            current_city = next_city\n        \n        return np.array(child, dtype=np.int32)\n\n    def inversion_mutation(individual):\n        # Inversion mutation by inverting a subsequence\n        idx1, idx2 = sorted(np.random.choice(range(N_P), 2, replace=False))\n        individual[idx1:idx2+1] = individual[idx1:idx2+1][::-1]\n        return individual\n\n    def rank_based_selection(ranked_individuals):\n        # Select parents based on their rank (lower rank has higher chance)\n        probabilities = 1 / (ranked_individuals + 1)\n        probabilities /= probabilities.sum()\n        selected_indices = np.random.choice(range(POP_SIZE), size=2, p=probabilities, replace=False)\n        return pops['individuals'][selected_indices[0]], pops['individuals'][selected_indices[1]]\n\n    # Main steps of the novel algorithm\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    ranked_individuals = np.argsort(pops['rankings'])\n    for i in range(0, POP_SIZE, 2):\n        parent1, parent2 = rank_based_selection(ranked_individuals)\n        child1 = edge_recombination(parent1, parent2)\n        child1 = inversion_mutation(child1)\n        # For odd-sized populations, avoid index out of bounds\n        if i + 1 < POP_SIZE:\n            child2 = edge_recombination(parent2, parent1)\n            child2 = inversion_mutation(child2)\n            new_pops[i + 1] = child2\n        new_pops[i] = child1\n\n    return new_pops",
     "objective": 0.82543,
     "other_inf": null
}