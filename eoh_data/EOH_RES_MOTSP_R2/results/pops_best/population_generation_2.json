{
     "algorithm": "Use Edge Recombination Crossover (ERX) to preserve edge adjacency information and apply inversion mutation for diversity, with a fitness-proportionate selection mechanism.}\n\n    def edge_recombination_crossover(parent1, parent2):\n        # Create the adjacency list for both parents\n        def create_adjacency_list(p):\n            adjacency_list = {i: set() for i in range(N_P)}\n            for i in range(N_P):\n                left = p[i - 1]\n                right = p[(i + 1) % N_P]\n                adjacency_list[p[i]].update([left, right])\n            return adjacency_list\n        \n        adjacency_list1 = create_adjacency_list(parent1)\n        adjacency_list2 = create_adjacency_list(parent2)\n        \n        # Merge the two adjacency lists\n        merged_adjacency_list = {i: adjacency_list1[i] | adjacency_list2[i] for i in range(N_P)",
     "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n    \n    # Backbone idea: Generate new populations using crossover and mutation operations guided by selection mechanisms.\n    # New algorithm description: {Use Edge Recombination Crossover (ERX) to preserve edge adjacency information and apply inversion mutation for diversity, with a fitness-proportionate selection mechanism.}\n\n    def edge_recombination_crossover(parent1, parent2):\n        # Create the adjacency list for both parents\n        def create_adjacency_list(p):\n            adjacency_list = {i: set() for i in range(N_P)}\n            for i in range(N_P):\n                left = p[i - 1]\n                right = p[(i + 1) % N_P]\n                adjacency_list[p[i]].update([left, right])\n            return adjacency_list\n        \n        adjacency_list1 = create_adjacency_list(parent1)\n        adjacency_list2 = create_adjacency_list(parent2)\n        \n        # Merge the two adjacency lists\n        merged_adjacency_list = {i: adjacency_list1[i] | adjacency_list2[i] for i in range(N_P)}\n\n        # Start with a random city\n        current_city = np.random.choice(N_P)\n        child = [current_city]\n\n        # Build the child path\n        while len(child) < N_P:\n            # Remove the current city from all adjacency lists\n            for adj in merged_adjacency_list.values():\n                adj.discard(current_city)\n            # Choose the next city with the fewest neighbors\n            if merged_adjacency_list[current_city]:\n                next_city = min(merged_adjacency_list[current_city], key=lambda x: len(merged_adjacency_list[x]))\n            else:\n                remaining_cities = set(range(N_P)) - set(child)\n                next_city = np.random.choice(list(remaining_cities))\n            child.append(next_city)\n            current_city = next_city\n\n        return child\n\n    def inversion_mutation(individual):\n        start, end = np.sort(np.random.choice(range(N_P), 2, replace=False))\n        individual[start:end] = individual[start:end][::-1]\n        return individual\n\n    def fitness_proportionate_selection():\n        total_fitness = np.sum(pops['rankings'])\n        probabilities = (1 - (pops['rankings'] / total_fitness))\n        probabilities /= probabilities.sum()\n        selected_index = np.random.choice(range(POP_SIZE), p=probabilities)\n        return pops['individuals'][selected_index]\n\n    # Main function body\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        parent1 = fitness_proportionate_selection()\n        parent2 = fitness_proportionate_selection()\n        child = edge_recombination_crossover(parent1, parent2)\n        child = inversion_mutation(child)\n        new_pops[i] = child\n\n    return new_pops",
     "objective": 0.81921,
     "other_inf": null
}