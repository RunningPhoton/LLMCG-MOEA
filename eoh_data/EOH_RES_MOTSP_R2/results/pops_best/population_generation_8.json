{
     "algorithm": "i: set() for i in range(N_P)",
     "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    \"\"\"\n    New algorithm: Edge Recombination Crossover (ERX) with Swap Mutation and Roulette Wheel Selection\n    \"\"\"\n    import numpy as np\n\n    def edge_recombination_crossover(parent1, parent2):\n        # Create edge map\n        edge_map = {i: set() for i in range(N_P)}\n        for p in [parent1, parent2]:\n            for i in range(N_P):\n                left = p[i - 1]\n                right = p[(i + 1) % N_P]\n                edge_map[p[i]].update([left, right])\n\n        # Start constructing the child\n        current = np.random.choice(parent1)\n        child = [current]\n        used = set([current])\n        while len(child) < N_P:\n            if edge_map[current]:\n                next_city = min(edge_map[current], key=lambda x: len(edge_map[x]))\n                edge_map[current].remove(next_city)\n            else:\n                next_city = np.random.choice(list(set(range(N_P)) - used))\n            for edges in edge_map.values():\n                edges.discard(current)\n            current = next_city\n            child.append(current)\n            used.add(current)\n        return child\n\n    def swap_mutation(individual):\n        idx1, idx2 = np.random.choice(range(N_P), 2, replace=False)\n        individual[idx1], individual[idx2] = individual[idx2], individual[idx1]\n        return individual\n\n    def roulette_wheel_selection(rankings):\n        total_fitness = np.sum(1 / (1 + rankings))\n        selection_probs = (1 / (1 + rankings)) / total_fitness\n        selected_index = np.random.choice(range(POP_SIZE), p=selection_probs)\n        return pops['individuals'][selected_index]\n\n    # Get rankings\n    rankings = pops['rankings']\n\n    # Create new population\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        parent1 = roulette_wheel_selection(rankings)\n        parent2 = roulette_wheel_selection(rankings)\n        child = edge_recombination_crossover(parent1, parent2)\n        if np.random.rand() < 0.1:  # mutation probability\n            child = swap_mutation(child)\n        new_pops[i] = child\n\n    return new_pops",
     "objective": 0.82993,
     "other_inf": null
}