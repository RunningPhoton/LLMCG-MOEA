{
     "algorithm": "i: set() for i in range(N_P)",
     "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n    \n    # Sub-function: Edge Recombination Crossover (ERX)\n    def erx(parent1, parent2):\n        # Create adjacency list for each node\n        adj_list = {i: set() for i in range(N_P)}\n        for i in range(N_P):\n            adj_set = set()\n            for parent in [parent1, parent2]:\n                idx = np.where(parent == i)[0][0]\n                adj_set.add(parent[(idx - 1) % N_P])\n                adj_set.add(parent[(idx + 1) % N_P])\n            adj_list[i] = adj_set\n        \n        # Start constructing the child with a random initial city\n        child = [-1] * N_P\n        current_city = np.random.choice(N_P)\n        child[0] = current_city\n        \n        # Construct the remaining path\n        for i in range(1, N_P):\n            # Remove current city from adjacency lists\n            for adj in adj_list.values():\n                adj.discard(current_city)\n            # Choose the next city with the fewest options in the adjacency list\n            if adj_list[current_city]:\n                next_city = min(adj_list[current_city], key=lambda x: len(adj_list[x]))\n            else:\n                remaining_cities = [city for city in range(N_P) if city not in child]\n                next_city = np.random.choice(remaining_cities)\n            child[i] = next_city\n            current_city = next_city\n        \n        return np.array(child, dtype=np.int32)\n\n    # Sub-function: Inversion Mutation\n    def inversion_mutation(individual):\n        start, end = np.sort(np.random.choice(range(N_P), 2, replace=False))\n        individual[start:end+1] = individual[start:end+1][::-1]\n        return individual\n\n    # Sub-function: Roulette Wheel Selection\n    def roulette_wheel_selection():\n        max_rank = np.max(pops['rankings']) + 1\n        # Convert rankings to fitness (higher is better)\n        fitness = max_rank - pops['rankings']\n        total_fitness = np.sum(fitness)\n        probabilities = fitness / total_fitness\n        selected_idx = np.random.choice(range(POP_SIZE), p=probabilities)\n        return pops['individuals'][selected_idx]\n\n    # Main function body\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        parent1 = roulette_wheel_selection()\n        parent2 = roulette_wheel_selection()\n        child = erx(parent1, parent2)\n        child = inversion_mutation(child)\n        new_pops[i] = child\n\n    return new_pops",
     "objective": 0.81989,
     "other_inf": null
}