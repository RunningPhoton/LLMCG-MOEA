{
     "algorithm": "i: set() for i in range(N_P)}\n        for i in range(N_P):\n            adjacency_list[parent1[i]].update({parent1[(i-1) % N_P], parent1[(i+1) % N_P]})\n            adjacency_list[parent2[i]].update({parent2[(i-1) % N_P], parent2[(i+1) % N_P]",
     "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    \"\"\"\n    Novel reproduction function using edge recombination crossover and inversion mutation to create a new population.\n    \"\"\"\n    import numpy as np\n\n    def edge_recombination_crossover(parent1, parent2):\n        # Create an adjacency list for each city\n        adjacency_list = {i: set() for i in range(N_P)}\n        for i in range(N_P):\n            adjacency_list[parent1[i]].update({parent1[(i-1) % N_P], parent1[(i+1) % N_P]})\n            adjacency_list[parent2[i]].update({parent2[(i-1) % N_P], parent2[(i+1) % N_P]})\n        \n        # Start with a random city\n        current_city = np.random.choice(range(N_P))\n        child = [current_city]\n        \n        # Build the child path\n        while len(child) < N_P:\n            # Remove the current city from other cities' adjacency lists\n            for city in adjacency_list:\n                adjacency_list[city].discard(current_city)\n            \n            # If current city has neighbors, select the one with the fewest neighbors, otherwise randomly\n            if adjacency_list[current_city]:\n                next_city = min(adjacency_list[current_city], key=lambda x: len(adjacency_list[x]))\n            else:\n                remaining_cities = list(set(range(N_P)) - set(child))\n                next_city = np.random.choice(remaining_cities)\n            \n            child.append(next_city)\n            current_city = next_city\n        \n        return child\n\n    def inversion_mutation(individual):\n        idx1, idx2 = np.random.choice(range(N_P), 2, replace=False)\n        if idx1 > idx2:\n            idx1, idx2 = idx2, idx1\n        individual[idx1:idx2+1] = individual[idx1:idx2+1][::-1]\n        return individual\n\n    def select_parents(fitness):\n        indices = np.random.choice(range(POP_SIZE), size=2, p=fitness, replace=False)\n        return pops['individuals'][indices[0]], pops['individuals'][indices[1]]\n\n    def compute_fitness(ranked_population):\n        # Invert rankings to compute fitness\n        fitness = 1 / (1 + ranked_population)\n        total_fitness = np.sum(fitness)\n        return fitness / total_fitness\n\n    # Calculate fitness and select parents\n    fitness = compute_fitness(pops['rankings'])\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n\n    # Generate new population\n    for i in range(POP_SIZE):\n        parent1, parent2 = select_parents(fitness)\n        child = edge_recombination_crossover(parent1, parent2)\n        child = inversion_mutation(child)\n        new_pops[i] = child\n\n    return new_pops",
     "objective": 0.81766,
     "other_inf": null
}