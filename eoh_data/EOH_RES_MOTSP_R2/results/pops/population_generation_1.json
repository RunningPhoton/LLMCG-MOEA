[
     {
          "algorithm": "i: set() for i in range(N_P)}\n        for i in range(N_P):\n            adjacency_list[parent1[i]].update({parent1[(i-1) % N_P], parent1[(i+1) % N_P]})\n            adjacency_list[parent2[i]].update({parent2[(i-1) % N_P], parent2[(i+1) % N_P]",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    \"\"\"\n    Novel reproduction function using edge recombination crossover and inversion mutation to create a new population.\n    \"\"\"\n    import numpy as np\n\n    def edge_recombination_crossover(parent1, parent2):\n        # Create an adjacency list for each city\n        adjacency_list = {i: set() for i in range(N_P)}\n        for i in range(N_P):\n            adjacency_list[parent1[i]].update({parent1[(i-1) % N_P], parent1[(i+1) % N_P]})\n            adjacency_list[parent2[i]].update({parent2[(i-1) % N_P], parent2[(i+1) % N_P]})\n        \n        # Start with a random city\n        current_city = np.random.choice(range(N_P))\n        child = [current_city]\n        \n        # Build the child path\n        while len(child) < N_P:\n            # Remove the current city from other cities' adjacency lists\n            for city in adjacency_list:\n                adjacency_list[city].discard(current_city)\n            \n            # If current city has neighbors, select the one with the fewest neighbors, otherwise randomly\n            if adjacency_list[current_city]:\n                next_city = min(adjacency_list[current_city], key=lambda x: len(adjacency_list[x]))\n            else:\n                remaining_cities = list(set(range(N_P)) - set(child))\n                next_city = np.random.choice(remaining_cities)\n            \n            child.append(next_city)\n            current_city = next_city\n        \n        return child\n\n    def inversion_mutation(individual):\n        idx1, idx2 = np.random.choice(range(N_P), 2, replace=False)\n        if idx1 > idx2:\n            idx1, idx2 = idx2, idx1\n        individual[idx1:idx2+1] = individual[idx1:idx2+1][::-1]\n        return individual\n\n    def select_parents(fitness):\n        indices = np.random.choice(range(POP_SIZE), size=2, p=fitness, replace=False)\n        return pops['individuals'][indices[0]], pops['individuals'][indices[1]]\n\n    def compute_fitness(ranked_population):\n        # Invert rankings to compute fitness\n        fitness = 1 / (1 + ranked_population)\n        total_fitness = np.sum(fitness)\n        return fitness / total_fitness\n\n    # Calculate fitness and select parents\n    fitness = compute_fitness(pops['rankings'])\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n\n    # Generate new population\n    for i in range(POP_SIZE):\n        parent1, parent2 = select_parents(fitness)\n        child = edge_recombination_crossover(parent1, parent2)\n        child = inversion_mutation(child)\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.81766,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n\n    def select_parents(fitness_probs):\n        return np.random.choice(range(POP_SIZE), size=2, replace=False, p=fitness_probs)\n\n    def order_crossover(parent1, parent2):\n        child = np.empty(N_P, dtype=np.int32)\n        child.fill(-1)\n        start, end = sorted(np.random.choice(range(N_P), 2, replace=False))\n        child[start:end+1] = parent1[start:end+1]\n        pos = (end + 1) % N_P\n        for gene in parent2:\n            if gene not in child:\n                child[pos] = gene\n                pos = (pos + 1) % N_P\n        return child\n\n    def swap_mutation(individual):\n        idx1, idx2 = np.random.choice(range(N_P), 2, replace=False)\n        individual[idx1], individual[idx2] = individual[idx2], individual[idx1]\n        return individual\n\n    def calculate_fitness(individual):\n        fitness = 0\n        for D in D_lst:\n            for i in range(N_P - 1):\n                fitness += D[individual[i], individual[i+1]]\n            fitness += D[individual[-1], individual[0]]\n        return fitness\n\n    individuals = pops['individuals']\n    fitness_values = np.array([calculate_fitness(ind) for ind in individuals])\n    fitness_probs = 1 / (fitness_values + 1)\n    fitness_probs /= fitness_probs.sum()\n\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        parent1_idx, parent2_idx = select_parents(fitness_probs)\n        parent1, parent2 = individuals[parent1_idx], individuals[parent2_idx]\n        child = order_crossover(parent1, parent2)\n        if np.random.rand() < 0.1:  # mutation probability\n            child = swap_mutation(child)\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.80201,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n\n    def crossover(parent1, parent2):\n        child = np.empty(N_P, dtype=np.int32)\n        child.fill(-1)\n        start_pos, end_pos = sorted(np.random.choice(range(N_P), 2, replace=False))\n        child[start_pos:end_pos+1] = parent1[start_pos:end_pos+1]\n        for i in range(N_P):\n            if parent2[i] not in child:\n                for j in range(N_P):\n                    if child[j] == -1:\n                        child[j] = parent2[i]\n                        break\n        return child\n\n    def mutate(individual):\n        idx1, idx2 = np.random.choice(range(N_P), 2, replace=False)\n        individual[idx1], individual[idx2] = individual[idx2], individual[idx1]\n        return individual\n\n    def select_parents(ranked_individuals):\n        index = np.random.choice(range(POP_SIZE), size=2, replace=False, p=selection_probs)\n        return ranked_individuals[index[0]], ranked_individuals[index[1]]\n\n    rankings = pops['rankings']\n    individuals = pops['individuals']\n    ranked_individuals = individuals[np.argsort(rankings)]\n    selection_probs = 1 / (rankings + 1)\n    selection_probs /= selection_probs.sum()\n\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        parent1, parent2 = select_parents(ranked_individuals)\n        child = crossover(parent1, parent2)\n        if np.random.rand() < 0.1:  # mutation probability\n            child = mutate(child)\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.75851,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n\n    def breed(parent1, parent2):\n        # Order crossover\n        start, end = sorted(np.random.choice(range(N_P), 2, replace=False))\n        child = np.full(N_P, -1, dtype=np.int32)\n        child[start:end+1] = parent1[start:end+1]\n        pointer = 0\n        for city in parent2:\n            if city not in child:\n                while child[pointer] != -1:\n                    pointer += 1\n                child[pointer] = city\n        return child\n\n    def mutate(individual):\n        # Swap mutation\n        idx1, idx2 = np.random.choice(range(N_P), 2, replace=False)\n        individual[idx1], individual[idx2] = individual[idx2], individual[idx1]\n        return individual\n\n    def select_parents(ranked_individuals):\n        # Tournament selection\n        tournament_size = 4\n        selected_indices = np.random.choice(range(POP_SIZE), tournament_size, replace=False)\n        selected_individuals = ranked_individuals[selected_indices]\n        selected_rankings = pops['rankings'][selected_indices]\n        parent_idx = selected_individuals[np.argmin(selected_rankings)]\n        return pops['individuals'][parent_idx]\n\n    ranked_individuals = np.argsort(pops['rankings'])\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        parent1 = select_parents(ranked_individuals)\n        parent2 = select_parents(ranked_individuals)\n        child = breed(parent1, parent2)\n        child = mutate(child)\n        new_pops[i] = child\n    return new_pops",
          "objective": 0.75702,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n    \n    # Sub-function: Partially-Mapped Crossover (PMX)\n    def pmx(parent1, parent2):\n        start, end = np.sort(np.random.choice(range(N_P), 2, replace=False))\n        child = np.array(parent1, dtype=np.int32)\n        child[start:end] = parent2[start:end]\n        for ind in range(start, end):\n            if parent1[ind] not in child[start:end]:\n                pos = ind\n                while start <= pos < end:\n                    pos = np.where(parent1 == parent2[pos])[0][0]\n                child[pos] = parent1[ind]\n        return child\n\n    # Sub-function: Swap Mutation\n    def swap_mutation(individual):\n        idx1, idx2 = np.random.choice(range(N_P), 2, replace=False)\n        individual[idx1], individual[idx2] = individual[idx2], individual[idx1]\n        return individual\n\n    # Sub-function: Tournament Selection\n    def tournament_selection():\n        participants = np.random.choice(range(POP_SIZE), 3, replace=False)\n        best_idx = participants[np.argmin(pops['rankings'][participants])]\n        return pops['individuals'][best_idx]\n\n    # Main function body\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        parent1 = tournament_selection()\n        parent2 = tournament_selection()\n        child = pmx(parent1, parent2)\n        child = swap_mutation(child)\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.74817,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n\n    def crossover(parent1, parent2):\n        \"\"\"Perform Order Crossover (OX) to produce offspring.\"\"\"\n        start, end = sorted(np.random.choice(range(N_P), 2, replace=False))\n        child = [None] * N_P\n        child[start:end] = parent1[start:end]\n        filled_positions = set(range(start, end))\n        parent2_positions = [i for i in range(N_P) if i not in filled_positions]\n\n        for i in parent2_positions:\n            for city in parent2:\n                if city not in child:\n                    child[i] = city\n                    break\n        return child\n\n    def mutate(individual):\n        \"\"\"Perform swap mutation on an individual.\"\"\"\n        idx1, idx2 = np.random.choice(range(N_P), 2, replace=False)\n        individual[idx1], individual[idx2] = individual[idx2], individual[idx1]\n        return individual\n\n    def select_parents():\n        \"\"\"Select parents using binary tournament selection.\"\"\"\n        idx1, idx2 = np.random.choice(range(POP_SIZE), 2, replace=False)\n        parent1 = pops['individuals'][idx1] if pops['rankings'][idx1] < pops['rankings'][idx2] else pops['individuals'][idx2]\n        idx3, idx4 = np.random.choice(range(POP_SIZE), 2, replace=False)\n        parent2 = pops['individuals'][idx3] if pops['rankings'][idx3] < pops['rankings'][idx4] else pops['individuals'][idx4]\n        return parent1, parent2\n\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n\n    # Main loop to fill the new population\n    for i in range(POP_SIZE):\n        parent1, parent2 = select_parents()\n        child = crossover(parent1, parent2)\n        child = mutate(child)\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.73984,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n\n    def crossover(parent1, parent2):\n        start = np.random.randint(0, N_P - 1)\n        end = np.random.randint(start + 1, N_P)\n        child = [-1] * N_P\n        child[start:end] = parent1[start:end]\n        pointer = 0\n        for city in parent2:\n            if city not in child:\n                while child[pointer] != -1:\n                    pointer += 1\n                child[pointer] = city\n        return child\n\n    def mutate(individual):\n        idx1, idx2 = np.random.choice(range(N_P), 2, replace=False)\n        individual[idx1], individual[idx2] = individual[idx2], individual[idx1]\n        return individual\n\n    def select_parents(ranked_population):\n        fitness = 1 / (1 + ranked_population['rankings'])\n        total_fitness = np.sum(fitness)\n        probabilities = fitness / total_fitness\n        indices = np.random.choice(range(POP_SIZE), size=2, p=probabilities, replace=False)\n        return ranked_population['individuals'][indices[0]], ranked_population['individuals'][indices[1]]\n\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        parent1, parent2 = select_parents(pops)\n        child = crossover(parent1, parent2)\n        child = mutate(child)\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.73854,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n\n    def crossover(parent1, parent2):\n        # Order crossover operator\n        start, end = sorted(np.random.randint(0, N_P, 2))\n        child = [None] * N_P\n        child[start:end] = parent1[start:end]\n        pointer = end\n        for city in parent2:\n            if city not in child:\n                if pointer >= N_P:\n                    pointer = 0\n                child[pointer] = city\n                pointer += 1\n        return child\n\n    def mutate(individual):\n        # Swap mutation operator\n        idx1, idx2 = np.random.randint(0, N_P, 2)\n        individual[idx1], individual[idx2] = individual[idx2], individual[idx1]\n        return individual\n\n    def select_parents(ranked_individuals):\n        # Tournament selection\n        tournament_size = 2\n        selected_indices = np.random.choice(POP_SIZE, tournament_size, replace=False)\n        tournament = ranked_individuals[selected_indices]\n        parent_index = tournament[np.argmin(pops['rankings'][selected_indices])]\n        return pops['individuals'][parent_index]\n\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    ranked_individuals = np.argsort(pops['rankings'])\n\n    for i in range(POP_SIZE):\n        parent1 = select_parents(ranked_individuals)\n        parent2 = select_parents(ranked_individuals)\n        child = crossover(parent1, parent2)\n        child = mutate(child)\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.73067,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n\n    def crossover(parent1, parent2):\n        \"\"\"Perform Order Crossover (OX) to maintain city sequence.\"\"\"\n        start, end = sorted(np.random.choice(range(N_P), 2, replace=False))\n        child = [None]*N_P\n        child[start:end+1] = parent1[start:end+1]\n        child_pos = (end + 1) % N_P\n        for city in parent2:\n            if city not in child:\n                child[child_pos] = city\n                child_pos = (child_pos + 1) % N_P\n        return np.array(child, dtype=np.int32)\n\n    def mutate(individual):\n        \"\"\"Swap Mutation: Swap two cities in the route.\"\"\"\n        idx1, idx2 = np.random.choice(range(N_P), 2, replace=False)\n        individual[idx1], individual[idx2] = individual[idx2], individual[idx1]\n        return individual\n\n    def select_parents(ranked_pops):\n        \"\"\"Tournament Selection: Select parents based on rankings.\"\"\"\n        tournament_size = 3\n        selected_indices = np.random.choice(range(POP_SIZE), tournament_size, replace=False)\n        selected_rankings = ranked_pops['rankings'][selected_indices]\n        best_index = selected_indices[np.argmin(selected_rankings)]\n        return ranked_pops['individuals'][best_index]\n\n    def create_new_population():\n        \"\"\"Create new population using crossover and mutation.\"\"\"\n        new_population = []\n        for _ in range(POP_SIZE):\n            parent1 = select_parents(pops)\n            parent2 = select_parents(pops)\n            child = crossover(parent1, parent2)\n            child = mutate(child)\n            new_population.append(child)\n        return np.array(new_population, dtype=np.int32)\n\n    new_pops = create_new_population()\n    return new_pops",
          "objective": 0.72634,
          "other_inf": null
     },
     {
          "algorithm": "city: set() for city in range(N_P)}\n            for i in range(N_P):\n                next_city = (i + 1) % N_P\n                prev_city = (i - 1) % N_P\n                edge_map[p1[i]].update({p1[prev_city], p1[next_city]})\n                edge_map[p2[i]].update({p2[prev_city], p2[next_city]",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n    \n    # Edge Recombination Crossover inspired by genetic algorithms for TSP\n    def edge_recombination_crossover(parent1, parent2):\n        def create_edge_map(p1, p2):\n            edge_map = {city: set() for city in range(N_P)}\n            for i in range(N_P):\n                next_city = (i + 1) % N_P\n                prev_city = (i - 1) % N_P\n                edge_map[p1[i]].update({p1[prev_city], p1[next_city]})\n                edge_map[p2[i]].update({p2[prev_city], p2[next_city]})\n            return edge_map\n        \n        def select_next_city(edge_map, current_city):\n            if edge_map[current_city]:\n                return edge_map[current_city].pop()\n            else:\n                return np.random.choice(list(set(range(N_P)) - set(child)))\n        \n        edge_map = create_edge_map(parent1, parent2)\n        child = [np.random.choice(range(N_P))]\n        while len(child) < N_P:\n            current_city = child[-1]\n            for city_set in edge_map.values():\n                city_set.discard(current_city)\n            next_city = select_next_city(edge_map, current_city)\n            child.append(next_city)\n        return child\n    \n    # Scramble Mutation\n    def scramble_mutation(individual):\n        start, end = sorted(np.random.choice(range(N_P), 2, replace=False))\n        individual[start:end] = np.random.permutation(individual[start:end])\n        return individual\n    \n    # Tournament Selection\n    def tournament_selection(ranked_individuals):\n        tournament_size = 3\n        selected_indices = np.random.choice(range(POP_SIZE), tournament_size, replace=False)\n        tournament_individuals = ranked_individuals[selected_indices]\n        tournament_rankings = pops['rankings'][selected_indices]\n        winner_index = selected_indices[np.argmin(tournament_rankings)]\n        return ranked_individuals[winner_index]\n    \n    # Creating the new population\n    rankings = pops['rankings']\n    individuals = pops['individuals']\n    ranked_individuals = individuals[np.argsort(rankings)]\n    \n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        parent1 = tournament_selection(ranked_individuals)\n        parent2 = tournament_selection(ranked_individuals)\n        child = edge_recombination_crossover(parent1, parent2)\n        if np.random.rand() < 0.1:  # mutation probability\n            child = scramble_mutation(child)\n        new_pops[i] = child\n    \n    return new_pops",
          "objective": 0.71861,
          "other_inf": null
     }
]