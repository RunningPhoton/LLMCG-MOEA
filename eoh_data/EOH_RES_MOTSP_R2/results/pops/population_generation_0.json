[
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n\n    def crossover(parent1, parent2):\n        child = np.empty(N_P, dtype=np.int32)\n        child.fill(-1)\n        start_pos, end_pos = sorted(np.random.choice(range(N_P), 2, replace=False))\n        child[start_pos:end_pos+1] = parent1[start_pos:end_pos+1]\n        for i in range(N_P):\n            if parent2[i] not in child:\n                for j in range(N_P):\n                    if child[j] == -1:\n                        child[j] = parent2[i]\n                        break\n        return child\n\n    def mutate(individual):\n        idx1, idx2 = np.random.choice(range(N_P), 2, replace=False)\n        individual[idx1], individual[idx2] = individual[idx2], individual[idx1]\n        return individual\n\n    def select_parents(ranked_individuals):\n        index = np.random.choice(range(POP_SIZE), size=2, replace=False, p=selection_probs)\n        return ranked_individuals[index[0]], ranked_individuals[index[1]]\n\n    rankings = pops['rankings']\n    individuals = pops['individuals']\n    ranked_individuals = individuals[np.argsort(rankings)]\n    selection_probs = 1 / (rankings + 1)\n    selection_probs /= selection_probs.sum()\n\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        parent1, parent2 = select_parents(ranked_individuals)\n        child = crossover(parent1, parent2)\n        if np.random.rand() < 0.1:  # mutation probability\n            child = mutate(child)\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.75851,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n\n    def breed(parent1, parent2):\n        # Order crossover\n        start, end = sorted(np.random.choice(range(N_P), 2, replace=False))\n        child = np.full(N_P, -1, dtype=np.int32)\n        child[start:end+1] = parent1[start:end+1]\n        pointer = 0\n        for city in parent2:\n            if city not in child:\n                while child[pointer] != -1:\n                    pointer += 1\n                child[pointer] = city\n        return child\n\n    def mutate(individual):\n        # Swap mutation\n        idx1, idx2 = np.random.choice(range(N_P), 2, replace=False)\n        individual[idx1], individual[idx2] = individual[idx2], individual[idx1]\n        return individual\n\n    def select_parents(ranked_individuals):\n        # Tournament selection\n        tournament_size = 4\n        selected_indices = np.random.choice(range(POP_SIZE), tournament_size, replace=False)\n        selected_individuals = ranked_individuals[selected_indices]\n        selected_rankings = pops['rankings'][selected_indices]\n        parent_idx = selected_individuals[np.argmin(selected_rankings)]\n        return pops['individuals'][parent_idx]\n\n    ranked_individuals = np.argsort(pops['rankings'])\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        parent1 = select_parents(ranked_individuals)\n        parent2 = select_parents(ranked_individuals)\n        child = breed(parent1, parent2)\n        child = mutate(child)\n        new_pops[i] = child\n    return new_pops",
          "objective": 0.75702,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n\n    def crossover(parent1, parent2):\n        \"\"\"Perform Order Crossover (OX) to produce offspring.\"\"\"\n        start, end = sorted(np.random.choice(range(N_P), 2, replace=False))\n        child = [None] * N_P\n        child[start:end] = parent1[start:end]\n        filled_positions = set(range(start, end))\n        parent2_positions = [i for i in range(N_P) if i not in filled_positions]\n\n        for i in parent2_positions:\n            for city in parent2:\n                if city not in child:\n                    child[i] = city\n                    break\n        return child\n\n    def mutate(individual):\n        \"\"\"Perform swap mutation on an individual.\"\"\"\n        idx1, idx2 = np.random.choice(range(N_P), 2, replace=False)\n        individual[idx1], individual[idx2] = individual[idx2], individual[idx1]\n        return individual\n\n    def select_parents():\n        \"\"\"Select parents using binary tournament selection.\"\"\"\n        idx1, idx2 = np.random.choice(range(POP_SIZE), 2, replace=False)\n        parent1 = pops['individuals'][idx1] if pops['rankings'][idx1] < pops['rankings'][idx2] else pops['individuals'][idx2]\n        idx3, idx4 = np.random.choice(range(POP_SIZE), 2, replace=False)\n        parent2 = pops['individuals'][idx3] if pops['rankings'][idx3] < pops['rankings'][idx4] else pops['individuals'][idx4]\n        return parent1, parent2\n\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n\n    # Main loop to fill the new population\n    for i in range(POP_SIZE):\n        parent1, parent2 = select_parents()\n        child = crossover(parent1, parent2)\n        child = mutate(child)\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.73984,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n\n    def crossover(parent1, parent2):\n        start = np.random.randint(0, N_P - 1)\n        end = np.random.randint(start + 1, N_P)\n        child = [-1] * N_P\n        child[start:end] = parent1[start:end]\n        pointer = 0\n        for city in parent2:\n            if city not in child:\n                while child[pointer] != -1:\n                    pointer += 1\n                child[pointer] = city\n        return child\n\n    def mutate(individual):\n        idx1, idx2 = np.random.choice(range(N_P), 2, replace=False)\n        individual[idx1], individual[idx2] = individual[idx2], individual[idx1]\n        return individual\n\n    def select_parents(ranked_population):\n        fitness = 1 / (1 + ranked_population['rankings'])\n        total_fitness = np.sum(fitness)\n        probabilities = fitness / total_fitness\n        indices = np.random.choice(range(POP_SIZE), size=2, p=probabilities, replace=False)\n        return ranked_population['individuals'][indices[0]], ranked_population['individuals'][indices[1]]\n\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        parent1, parent2 = select_parents(pops)\n        child = crossover(parent1, parent2)\n        child = mutate(child)\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.73854,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n\n    def crossover(parent1, parent2):\n        # Order crossover operator\n        start, end = sorted(np.random.randint(0, N_P, 2))\n        child = [None] * N_P\n        child[start:end] = parent1[start:end]\n        pointer = end\n        for city in parent2:\n            if city not in child:\n                if pointer >= N_P:\n                    pointer = 0\n                child[pointer] = city\n                pointer += 1\n        return child\n\n    def mutate(individual):\n        # Swap mutation operator\n        idx1, idx2 = np.random.randint(0, N_P, 2)\n        individual[idx1], individual[idx2] = individual[idx2], individual[idx1]\n        return individual\n\n    def select_parents(ranked_individuals):\n        # Tournament selection\n        tournament_size = 2\n        selected_indices = np.random.choice(POP_SIZE, tournament_size, replace=False)\n        tournament = ranked_individuals[selected_indices]\n        parent_index = tournament[np.argmin(pops['rankings'][selected_indices])]\n        return pops['individuals'][parent_index]\n\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    ranked_individuals = np.argsort(pops['rankings'])\n\n    for i in range(POP_SIZE):\n        parent1 = select_parents(ranked_individuals)\n        parent2 = select_parents(ranked_individuals)\n        child = crossover(parent1, parent2)\n        child = mutate(child)\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.73067,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n\n    def crossover(parent1, parent2):\n        \"\"\"Perform Order Crossover (OX) to maintain city sequence.\"\"\"\n        start, end = sorted(np.random.choice(range(N_P), 2, replace=False))\n        child = [None]*N_P\n        child[start:end+1] = parent1[start:end+1]\n        child_pos = (end + 1) % N_P\n        for city in parent2:\n            if city not in child:\n                child[child_pos] = city\n                child_pos = (child_pos + 1) % N_P\n        return np.array(child, dtype=np.int32)\n\n    def mutate(individual):\n        \"\"\"Swap Mutation: Swap two cities in the route.\"\"\"\n        idx1, idx2 = np.random.choice(range(N_P), 2, replace=False)\n        individual[idx1], individual[idx2] = individual[idx2], individual[idx1]\n        return individual\n\n    def select_parents(ranked_pops):\n        \"\"\"Tournament Selection: Select parents based on rankings.\"\"\"\n        tournament_size = 3\n        selected_indices = np.random.choice(range(POP_SIZE), tournament_size, replace=False)\n        selected_rankings = ranked_pops['rankings'][selected_indices]\n        best_index = selected_indices[np.argmin(selected_rankings)]\n        return ranked_pops['individuals'][best_index]\n\n    def create_new_population():\n        \"\"\"Create new population using crossover and mutation.\"\"\"\n        new_population = []\n        for _ in range(POP_SIZE):\n            parent1 = select_parents(pops)\n            parent2 = select_parents(pops)\n            child = crossover(parent1, parent2)\n            child = mutate(child)\n            new_population.append(child)\n        return np.array(new_population, dtype=np.int32)\n\n    new_pops = create_new_population()\n    return new_pops",
          "objective": 0.72634,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n\n    def crossover(parent1, parent2):\n        \"\"\"Perform ordered crossover between two parents.\"\"\"\n        start, end = sorted(np.random.choice(range(N_P), 2, replace=False))\n        child = np.array([-1] * N_P, dtype=np.int32)\n        child[start:end+1] = parent1[start:end+1]\n        place_idx = end + 1 if end < N_P - 1 else 0\n        for city in parent2:\n            if city not in child:\n                child[place_idx] = city\n                place_idx = place_idx + 1 if place_idx < N_P - 1 else 0\n        return child\n\n    def mutate(individual):\n        \"\"\"Swap mutation on an individual.\"\"\"\n        idx1, idx2 = np.random.choice(range(N_P), 2, replace=False)\n        individual[idx1], individual[idx2] = individual[idx2], individual[idx1]\n        return individual\n\n    def select_parents(ranked_population):\n        \"\"\"Tournament selection.\"\"\"\n        participants = np.random.choice(ranked_population, 4, replace=False)\n        best_two = participants[np.argsort(pops['rankings'][participants])][:2]\n        return pops['individuals'][best_two]\n\n    def create_new_individual():\n        \"\"\"Create a new individual using crossover and mutation.\"\"\"\n        parent1, parent2 = select_parents(np.arange(POP_SIZE))\n        child = crossover(parent1, parent2)\n        child = mutate(child)\n        return child\n\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        new_pops[i] = create_new_individual()\n\n    return new_pops",
          "objective": 0.7178,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n\n    # Define a function that performs crossover between two parents to produce an offspring\n    def ordered_crossover(parent1, parent2):\n        start, end = sorted(np.random.choice(range(N_P), 2, replace=False))\n        child = [None]*N_P\n        child[start:end] = parent1[start:end]\n        filled_positions = set(range(start, end))\n        parent2_idx = 0\n        for i in range(N_P):\n            if child[i] is None:\n                while parent2[parent2_idx] in child:\n                    parent2_idx += 1\n                child[i] = parent2[parent2_idx]\n        return child\n\n    # Define a function that performs mutation on an individual\n    def swap_mutation(individual):\n        idx1, idx2 = np.random.choice(range(N_P), 2, replace=False)\n        individual[idx1], individual[idx2] = individual[idx2], individual[idx1]\n        return individual\n\n    # Generate new population\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        # Select parents based on rankings (tournament selection)\n        tournament_size = 2\n        candidates = np.random.choice(range(POP_SIZE), tournament_size, replace=False)\n        parent1_rank = pops['rankings'][candidates[0]]\n        parent2_rank = pops['rankings'][candidates[1]]\n        parent1 = pops['individuals'][candidates[0]] if parent1_rank <= parent2_rank else pops['individuals'][candidates[1]]\n        parent2 = pops['individuals'][candidates[1]] if parent1_rank <= parent2_rank else pops['individuals'][candidates[0]]\n\n        # Perform crossover and mutation to produce a new individual\n        child = ordered_crossover(parent1, parent2)\n        child = swap_mutation(child)\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.69857,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n\n    # Novel reproduction function: 'Hybrid Crossover with Local Improvement'\n    # 1. Select parents using tournament selection based on rankings.\n    # 2. Apply a hybrid crossover that combines ordered crossover and edge recombination.\n    # 3. Perform local improvement using 2-opt swaps.\n    # 4. Mutate the offspring by swapping two random cities.\n    # 5. Replace the worst individuals in the population with the new offspring.\n\n    def tournament_selection():\n        # Select two individuals based on their rankings for crossover\n        participants = np.random.choice(POP_SIZE, size=2, replace=False)\n        if pops['rankings'][participants[0]] < pops['rankings'][participants[1]]:\n            return pops['individuals'][participants[0]]\n        else:\n            return pops['individuals'][participants[1]]\n\n    def hybrid_crossover(parent1, parent2):\n        # Ordered crossover\n        start, end = sorted(np.random.choice(N_P, size=2, replace=False))\n        offspring = -np.ones(N_P, dtype=np.int32)\n        offspring[start:end+1] = parent1[start:end+1]\n        # Fill the remaining positions with cities from parent2\n        for city in parent2:\n            if city not in offspring:\n                idx = np.where(offspring == -1)[0][0]\n                offspring[idx] = city\n        return offspring\n\n    def local_improvement(offspring):\n        # 2-opt swaps to improve the tour\n        improved = True\n        while improved:\n            improved = False\n            for i in range(1, N_P - 2):\n                for j in range(i+1, N_P):\n                    if j - i == 1: continue  # Skip adjacent edges\n                    new_offspring = offspring.copy()\n                    new_offspring[i:j] = offspring[j-1:i-1:-1]  # 2-opt swap\n                    if np.all(new_offspring != offspring):\n                        improved = True\n                        offspring = new_offspring\n                        break\n                if improved:\n                    break\n        return offspring\n\n    def mutate(offspring):\n        # Swap two random cities to mutate the offspring\n        i, j = np.random.choice(N_P, size=2, replace=False)\n        offspring[i], offspring[j] = offspring[j], offspring[i]\n        return offspring\n\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        parent1 = tournament_selection()\n        parent2 = tournament_selection()\n        offspring = hybrid_crossover(parent1, parent2)\n        offspring = local_improvement(offspring)\n        offspring = mutate(offspring)\n        new_pops[i] = offspring\n\n    # Replace the worst individuals\n    worst_indices = np.argsort(pops['rankings'])[-POP_SIZE//2:]\n    new_pops[worst_indices] = new_pops[:POP_SIZE//2]\n\n    return new_pops",
          "objective": 0.69676,
          "other_inf": null
     },
     {
          "algorithm": "A novel reproduction function for a multi-objective TSP that creates the next generation by performing \n    crossover between top-ranked individuals and mutation with a probability that decreases with ranking.",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    \"\"\"\n    {A novel reproduction function for a multi-objective TSP that creates the next generation by performing \n    crossover between top-ranked individuals and mutation with a probability that decreases with ranking.}\n    \"\"\"\n    \n    import numpy as np\n    \n    def crossover(parent1, parent2):\n        \"\"\"Perform ordered crossover between two parents.\"\"\"\n        start, end = sorted(np.random.choice(range(N_P), 2, replace=False))\n        child = np.array([-1] * N_P, dtype=np.int32)\n        child[start:end+1] = parent1[start:end+1]\n        child_indices = set(range(start, end+1))\n        for i in range(N_P):\n            if parent2[i] not in child:\n                for j in range(N_P):\n                    if child[j] == -1:\n                        child[j] = parent2[i]\n                        break\n        return child\n\n    def mutate(individual):\n        \"\"\"Swap mutation with two random cities.\"\"\"\n        idx1, idx2 = np.random.choice(range(N_P), 2, replace=False)\n        individual[idx1], individual[idx2] = individual[idx2], individual[idx1]\n        return individual\n\n    def select_parents(ranked_individuals):\n        \"\"\"Select parents based on rankings using a tournament selection.\"\"\"\n        tournament_size = max(2, POP_SIZE // 10)\n        selected_indices = np.random.choice(range(POP_SIZE), tournament_size, replace=False)\n        selected_rankings = ranked_individuals[selected_indices]\n        parents_indices = selected_indices[np.argsort(selected_rankings)][:2]\n        return pops['individuals'][parents_indices[0]], pops['individuals'][parents_indices[1]]\n\n    # Initialize new population\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    \n    # Sort individuals based on rankings\n    ranked_individuals = np.argsort(pops['rankings'])\n    \n    # Elitism: directly pass the best individual to the next generation\n    new_pops[0] = pops['individuals'][ranked_individuals[0]]\n    \n    # Generate new individuals for the next generation\n    for i in range(1, POP_SIZE):\n        parent1, parent2 = select_parents(ranked_individuals)\n        child = crossover(parent1, parent2)\n        \n        # Mutation probability inversely related to ranking\n        if np.random.rand() < (1 / (i + 1)):\n            child = mutate(child)\n            \n        new_pops[i] = child\n    \n    return new_pops",
          "objective": 0.68787,
          "other_inf": null
     }
]