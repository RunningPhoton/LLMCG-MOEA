[
     {
          "algorithm": "Use Edge Recombination Crossover (ERX) to preserve edge adjacency information and apply inversion mutation for diversity, with a fitness-proportionate selection mechanism.}\n\n    def edge_recombination_crossover(parent1, parent2):\n        # Create the adjacency list for both parents\n        def create_adjacency_list(p):\n            adjacency_list = {i: set() for i in range(N_P)}\n            for i in range(N_P):\n                left = p[i - 1]\n                right = p[(i + 1) % N_P]\n                adjacency_list[p[i]].update([left, right])\n            return adjacency_list\n        \n        adjacency_list1 = create_adjacency_list(parent1)\n        adjacency_list2 = create_adjacency_list(parent2)\n        \n        # Merge the two adjacency lists\n        merged_adjacency_list = {i: adjacency_list1[i] | adjacency_list2[i] for i in range(N_P)",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n    \n    # Backbone idea: Generate new populations using crossover and mutation operations guided by selection mechanisms.\n    # New algorithm description: {Use Edge Recombination Crossover (ERX) to preserve edge adjacency information and apply inversion mutation for diversity, with a fitness-proportionate selection mechanism.}\n\n    def edge_recombination_crossover(parent1, parent2):\n        # Create the adjacency list for both parents\n        def create_adjacency_list(p):\n            adjacency_list = {i: set() for i in range(N_P)}\n            for i in range(N_P):\n                left = p[i - 1]\n                right = p[(i + 1) % N_P]\n                adjacency_list[p[i]].update([left, right])\n            return adjacency_list\n        \n        adjacency_list1 = create_adjacency_list(parent1)\n        adjacency_list2 = create_adjacency_list(parent2)\n        \n        # Merge the two adjacency lists\n        merged_adjacency_list = {i: adjacency_list1[i] | adjacency_list2[i] for i in range(N_P)}\n\n        # Start with a random city\n        current_city = np.random.choice(N_P)\n        child = [current_city]\n\n        # Build the child path\n        while len(child) < N_P:\n            # Remove the current city from all adjacency lists\n            for adj in merged_adjacency_list.values():\n                adj.discard(current_city)\n            # Choose the next city with the fewest neighbors\n            if merged_adjacency_list[current_city]:\n                next_city = min(merged_adjacency_list[current_city], key=lambda x: len(merged_adjacency_list[x]))\n            else:\n                remaining_cities = set(range(N_P)) - set(child)\n                next_city = np.random.choice(list(remaining_cities))\n            child.append(next_city)\n            current_city = next_city\n\n        return child\n\n    def inversion_mutation(individual):\n        start, end = np.sort(np.random.choice(range(N_P), 2, replace=False))\n        individual[start:end] = individual[start:end][::-1]\n        return individual\n\n    def fitness_proportionate_selection():\n        total_fitness = np.sum(pops['rankings'])\n        probabilities = (1 - (pops['rankings'] / total_fitness))\n        probabilities /= probabilities.sum()\n        selected_index = np.random.choice(range(POP_SIZE), p=probabilities)\n        return pops['individuals'][selected_index]\n\n    # Main function body\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        parent1 = fitness_proportionate_selection()\n        parent2 = fitness_proportionate_selection()\n        child = edge_recombination_crossover(parent1, parent2)\n        child = inversion_mutation(child)\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.81921,
          "other_inf": null
     },
     {
          "algorithm": "i: set() for i in range(N_P)}\n        for i in range(N_P):\n            adjacency_list[parent1[i]].update({parent1[(i-1) % N_P], parent1[(i+1) % N_P]})\n            adjacency_list[parent2[i]].update({parent2[(i-1) % N_P], parent2[(i+1) % N_P]",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    \"\"\"\n    Novel reproduction function using edge recombination crossover and inversion mutation to create a new population.\n    \"\"\"\n    import numpy as np\n\n    def edge_recombination_crossover(parent1, parent2):\n        # Create an adjacency list for each city\n        adjacency_list = {i: set() for i in range(N_P)}\n        for i in range(N_P):\n            adjacency_list[parent1[i]].update({parent1[(i-1) % N_P], parent1[(i+1) % N_P]})\n            adjacency_list[parent2[i]].update({parent2[(i-1) % N_P], parent2[(i+1) % N_P]})\n        \n        # Start with a random city\n        current_city = np.random.choice(range(N_P))\n        child = [current_city]\n        \n        # Build the child path\n        while len(child) < N_P:\n            # Remove the current city from other cities' adjacency lists\n            for city in adjacency_list:\n                adjacency_list[city].discard(current_city)\n            \n            # If current city has neighbors, select the one with the fewest neighbors, otherwise randomly\n            if adjacency_list[current_city]:\n                next_city = min(adjacency_list[current_city], key=lambda x: len(adjacency_list[x]))\n            else:\n                remaining_cities = list(set(range(N_P)) - set(child))\n                next_city = np.random.choice(remaining_cities)\n            \n            child.append(next_city)\n            current_city = next_city\n        \n        return child\n\n    def inversion_mutation(individual):\n        idx1, idx2 = np.random.choice(range(N_P), 2, replace=False)\n        if idx1 > idx2:\n            idx1, idx2 = idx2, idx1\n        individual[idx1:idx2+1] = individual[idx1:idx2+1][::-1]\n        return individual\n\n    def select_parents(fitness):\n        indices = np.random.choice(range(POP_SIZE), size=2, p=fitness, replace=False)\n        return pops['individuals'][indices[0]], pops['individuals'][indices[1]]\n\n    def compute_fitness(ranked_population):\n        # Invert rankings to compute fitness\n        fitness = 1 / (1 + ranked_population)\n        total_fitness = np.sum(fitness)\n        return fitness / total_fitness\n\n    # Calculate fitness and select parents\n    fitness = compute_fitness(pops['rankings'])\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n\n    # Generate new population\n    for i in range(POP_SIZE):\n        parent1, parent2 = select_parents(fitness)\n        child = edge_recombination_crossover(parent1, parent2)\n        child = inversion_mutation(child)\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.81766,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n\n    def select_parents(fitness_probs):\n        return np.random.choice(range(POP_SIZE), size=2, replace=False, p=fitness_probs)\n\n    def order_crossover(parent1, parent2):\n        child = np.empty(N_P, dtype=np.int32)\n        child.fill(-1)\n        start, end = sorted(np.random.choice(range(N_P), 2, replace=False))\n        child[start:end+1] = parent1[start:end+1]\n        pos = (end + 1) % N_P\n        for gene in parent2:\n            if gene not in child:\n                child[pos] = gene\n                pos = (pos + 1) % N_P\n        return child\n\n    def swap_mutation(individual):\n        idx1, idx2 = np.random.choice(range(N_P), 2, replace=False)\n        individual[idx1], individual[idx2] = individual[idx2], individual[idx1]\n        return individual\n\n    def calculate_fitness(individual):\n        fitness = 0\n        for D in D_lst:\n            for i in range(N_P - 1):\n                fitness += D[individual[i], individual[i+1]]\n            fitness += D[individual[-1], individual[0]]\n        return fitness\n\n    individuals = pops['individuals']\n    fitness_values = np.array([calculate_fitness(ind) for ind in individuals])\n    fitness_probs = 1 / (fitness_values + 1)\n    fitness_probs /= fitness_probs.sum()\n\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        parent1_idx, parent2_idx = select_parents(fitness_probs)\n        parent1, parent2 = individuals[parent1_idx], individuals[parent2_idx]\n        child = order_crossover(parent1, parent2)\n        if np.random.rand() < 0.1:  # mutation probability\n            child = swap_mutation(child)\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.80201,
          "other_inf": null
     },
     {
          "algorithm": "Use a combination of edge recombination for crossover and inversion mutation to generate offspring.}\n    \n    def edge_recombination_crossover(parent1, parent2):\n        # Create the edge map for both parents\n        edge_map = {i: set() for i in range(N_P)}\n        for p in [parent1, parent2]:\n            for i in range(N_P):\n                next_city = p[(i + 1) % N_P]\n                prev_city = p[i - 1]\n                edge_map[p[i]].update({prev_city, next_city",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n\n    # The common backbone idea: Generate new populations by selecting parents based on fitness and applying crossover and mutation operations.\n    # The new algorithm: {Use a combination of edge recombination for crossover and inversion mutation to generate offspring.}\n    \n    def edge_recombination_crossover(parent1, parent2):\n        # Create the edge map for both parents\n        edge_map = {i: set() for i in range(N_P)}\n        for p in [parent1, parent2]:\n            for i in range(N_P):\n                next_city = p[(i + 1) % N_P]\n                prev_city = p[i - 1]\n                edge_map[p[i]].update({prev_city, next_city})\n        \n        # Start from the first city of parent1 and build the child\n        current_city = parent1[0]\n        child = [current_city]\n        while len(child) < N_P:\n            # Remove current city from edge map\n            for edges in edge_map.values():\n                edges.discard(current_city)\n            # Pick the next city with the fewest edges\n            if edge_map[current_city]:\n                next_city = min(edge_map[current_city], key=lambda x: len(edge_map[x]))\n            else:\n                next_city = np.random.choice([city for city in range(N_P) if city not in child])\n            child.append(next_city)\n            current_city = next_city\n        return child\n\n    def inversion_mutation(individual):\n        start, end = sorted(np.random.choice(range(N_P), 2, replace=False))\n        individual[start:end] = individual[start:end][::-1]\n        return individual\n    \n    def calculate_fitness(individual):\n        fitness = 0\n        for D in D_lst:\n            for i in range(N_P - 1):\n                fitness += D[individual[i], individual[i+1]]\n            fitness += D[individual[-1], individual[0]]\n        return fitness\n\n    def roulette_wheel_selection(fitness_values):\n        total_fitness = np.sum(fitness_values)\n        probabilities = fitness_values / total_fitness\n        selected_index = np.random.choice(range(POP_SIZE), p=probabilities)\n        return selected_index\n\n    individuals = pops['individuals']\n    fitness_values = np.array([calculate_fitness(ind) for ind in individuals])\n    # Invert fitness values for minimization problem\n    fitness_values = 1 / (fitness_values + 1e-9)\n\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        # Select parents using roulette wheel selection\n        parent1_idx = roulette_wheel_selection(fitness_values)\n        parent2_idx = roulette_wheel_selection(fitness_values)\n        parent1, parent2 = individuals[parent1_idx], individuals[parent2_idx]\n\n        # Apply edge recombination crossover\n        child = edge_recombination_crossover(parent1, parent2)\n        \n        # Apply inversion mutation with a certain probability\n        if np.random.rand() < 0.1:  # mutation probability\n            child = inversion_mutation(child)\n        \n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.79811,
          "other_inf": null
     },
     {
          "algorithm": "'rankings': ranked_population['rankings']",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n\n    def crossover(parent1, parent2):\n        child = []\n        childP1 = []\n        childP2 = []\n        \n        geneA = int(np.random.random() * len(parent1))\n        geneB = int(np.random.random() * len(parent1))\n        \n        startGene = min(geneA, geneB)\n        endGene = max(geneA, geneB)\n\n        for i in range(startGene, endGene):\n            childP1.append(parent1[i])\n            \n        childP2 = [item for item in parent2 if item not in childP1]\n\n        child = childP1 + childP2\n        return child\n\n    def mutate(individual, mutation_rate=0.01):\n        for swapped in range(len(individual)):\n            if(np.random.random() < mutation_rate):\n                swapWith = int(np.random.random() * len(individual))\n                \n                city1 = individual[swapped]\n                city2 = individual[swapWith]\n                \n                individual[swapped] = city2\n                individual[swapWith] = city1\n        return individual\n\n    def rank_selection(ranked_population, elite_size):\n        selection_results = []\n        df = {'rankings': ranked_population['rankings']}\n        df['cum_sum'] = np.cumsum(df['rankings'])\n        df['cum_perc'] = 100*df['cum_sum']/df['rankings'].sum()\n        \n        for i in range(0, elite_size):\n            selection_results.append(ranked_population['individuals'][i])\n        for i in range(0, len(ranked_population['individuals']) - elite_size):\n            pick = 100*np.random.random()\n            for i in range(0, len(ranked_population['individuals'])):\n                if pick <= df['cum_perc'][i]:\n                    selection_results.append(ranked_population['individuals'][i])\n                    break\n        return selection_results\n\n    def breed_population(matingpool, elite_size):\n        children = []\n        length = len(matingpool) - elite_size\n        pool = np.random.permutation(matingpool)\n\n        for i in range(0,elite_size):\n            children.append(matingpool[i])\n        \n        for i in range(0, length):\n            child = crossover(pool[i], pool[len(matingpool)-i-1])\n            children.append(child)\n        return children\n\n    def mutate_population(population, mutation_rate):\n        mutated_pop = []\n        \n        for ind in range(0, len(population)):\n            mutated_ind = mutate(population[ind], mutation_rate)\n            mutated_pop.append(mutated_ind)\n        return mutated_pop\n\n    elite_size = POP_SIZE // 10 if POP_SIZE >= 10 else 1\n    mutation_rate = 0.01\n\n    matingpool = rank_selection(pops, elite_size)\n    children = breed_population(matingpool, elite_size)\n    new_pops = np.array(mutate_population(children, mutation_rate), dtype=np.int32)\n\n    return new_pops",
          "objective": 0.79373,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n    \n    # Novel reproduction function: Partially-Mapped Crossover (PMX) and Inversion Mutation\n    def pmx_crossover(parent1, parent2):\n        # Randomly select a crossover point\n        cx_point1, cx_point2 = sorted(np.random.choice(range(N_P), 2, replace=False))\n        # Initialize the child with placeholder values\n        child = np.empty_like(parent1)\n        child.fill(-1)\n        # Copy the segment from first parent to the child\n        child[cx_point1:cx_point2+1] = parent1[cx_point1:cx_point2+1]\n        # Map the remaining positions from the second parent to the child\n        for i in range(cx_point1, cx_point2+1):\n            if parent2[i] not in child:\n                j = i\n                while child[j] != -1:\n                    j = np.where(parent2 == parent1[j])[0][0]\n                child[j] = parent2[i]\n        # Fill the rest of the positions in the child with the remaining cities from parent2\n        for i in range(N_P):\n            if child[i] == -1:\n                child[i] = parent2[i]\n        return child\n    \n    def inversion_mutation(individual):\n        # Randomly select two points for inversion\n        inv_point1, inv_point2 = sorted(np.random.choice(range(N_P), 2, replace=False))\n        # Invert the segment between the two points\n        individual[inv_point1:inv_point2+1] = individual[inv_point1:inv_point2+1][::-1]\n        return individual\n\n    def tournament_selection(ranked_individuals):\n        tournament_size = 3\n        selected_indices = np.random.choice(range(POP_SIZE), tournament_size, replace=False)\n        tournament_individuals = ranked_individuals[selected_indices]\n        tournament_rankings = pops['rankings'][selected_indices]\n        winner_index = selected_indices[np.argmin(tournament_rankings)]\n        return ranked_individuals[winner_index]\n    \n    # Creating the new population\n    rankings = pops['rankings']\n    individuals = pops['individuals']\n    ranked_individuals = individuals[np.argsort(rankings)]\n    \n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        parent1 = tournament_selection(ranked_individuals)\n        parent2 = tournament_selection(ranked_individuals)\n        child = pmx_crossover(parent1, parent2)\n        if np.random.rand() < 0.1:  # mutation probability\n            child = inversion_mutation(child)\n        new_pops[i] = child\n    \n    return new_pops",
          "objective": 0.76325,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n    \n    def cycle_crossover(parent1, parent2):\n        child = np.empty(N_P, dtype=np.int32)\n        child.fill(-1)\n        cycle_start = np.random.randint(N_P)\n        in_cycle = set([cycle_start])\n        current_city = cycle_start\n        while True:\n            child[current_city] = parent1[current_city]\n            current_city = np.where(parent2 == parent1[current_city])[0][0]\n            if current_city in in_cycle:\n                break\n            in_cycle.add(current_city)\n        for i in range(N_P):\n            if child[i] == -1:\n                child[i] = parent2[i]\n        return child\n    \n    def inversion_mutation(individual):\n        idx1, idx2 = np.random.choice(range(N_P), 2, replace=False)\n        individual[idx1:idx2+1] = individual[idx1:idx2+1][::-1]\n        return individual\n    \n    def fitness_proportional_selection(ranked_individuals):\n        max_rank = np.max(pops['rankings'])\n        selection_probs = (max_rank + 1) - pops['rankings']\n        selection_probs = selection_probs / np.sum(selection_probs)\n        selected_idx = np.random.choice(ranked_individuals, p=selection_probs)\n        return pops['individuals'][selected_idx]\n    \n    ranked_individuals = np.argsort(pops['rankings'])\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        parent1 = fitness_proportional_selection(ranked_individuals)\n        parent2 = fitness_proportional_selection(ranked_individuals)\n        child = cycle_crossover(parent1, parent2)\n        child = inversion_mutation(child)\n        new_pops[i] = child\n    return new_pops",
          "objective": 0.75973,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n\n    def crossover(parent1, parent2):\n        child = np.empty(N_P, dtype=np.int32)\n        child.fill(-1)\n        start_pos, end_pos = sorted(np.random.choice(range(N_P), 2, replace=False))\n        child[start_pos:end_pos+1] = parent1[start_pos:end_pos+1]\n        for i in range(N_P):\n            if parent2[i] not in child:\n                for j in range(N_P):\n                    if child[j] == -1:\n                        child[j] = parent2[i]\n                        break\n        return child\n\n    def mutate(individual):\n        idx1, idx2 = np.random.choice(range(N_P), 2, replace=False)\n        individual[idx1], individual[idx2] = individual[idx2], individual[idx1]\n        return individual\n\n    def select_parents(ranked_individuals):\n        index = np.random.choice(range(POP_SIZE), size=2, replace=False, p=selection_probs)\n        return ranked_individuals[index[0]], ranked_individuals[index[1]]\n\n    rankings = pops['rankings']\n    individuals = pops['individuals']\n    ranked_individuals = individuals[np.argsort(rankings)]\n    selection_probs = 1 / (rankings + 1)\n    selection_probs /= selection_probs.sum()\n\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        parent1, parent2 = select_parents(ranked_individuals)\n        child = crossover(parent1, parent2)\n        if np.random.rand() < 0.1:  # mutation probability\n            child = mutate(child)\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.75851,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n\n    def breed(parent1, parent2):\n        # Order crossover\n        start, end = sorted(np.random.choice(range(N_P), 2, replace=False))\n        child = np.full(N_P, -1, dtype=np.int32)\n        child[start:end+1] = parent1[start:end+1]\n        pointer = 0\n        for city in parent2:\n            if city not in child:\n                while child[pointer] != -1:\n                    pointer += 1\n                child[pointer] = city\n        return child\n\n    def mutate(individual):\n        # Swap mutation\n        idx1, idx2 = np.random.choice(range(N_P), 2, replace=False)\n        individual[idx1], individual[idx2] = individual[idx2], individual[idx1]\n        return individual\n\n    def select_parents(ranked_individuals):\n        # Tournament selection\n        tournament_size = 4\n        selected_indices = np.random.choice(range(POP_SIZE), tournament_size, replace=False)\n        selected_individuals = ranked_individuals[selected_indices]\n        selected_rankings = pops['rankings'][selected_indices]\n        parent_idx = selected_individuals[np.argmin(selected_rankings)]\n        return pops['individuals'][parent_idx]\n\n    ranked_individuals = np.argsort(pops['rankings'])\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        parent1 = select_parents(ranked_individuals)\n        parent2 = select_parents(ranked_individuals)\n        child = breed(parent1, parent2)\n        child = mutate(child)\n        new_pops[i] = child\n    return new_pops",
          "objective": 0.75702,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n    \n    # Sub-function: Partially-Mapped Crossover (PMX)\n    def pmx(parent1, parent2):\n        start, end = np.sort(np.random.choice(range(N_P), 2, replace=False))\n        child = np.array(parent1, dtype=np.int32)\n        child[start:end] = parent2[start:end]\n        for ind in range(start, end):\n            if parent1[ind] not in child[start:end]:\n                pos = ind\n                while start <= pos < end:\n                    pos = np.where(parent1 == parent2[pos])[0][0]\n                child[pos] = parent1[ind]\n        return child\n\n    # Sub-function: Swap Mutation\n    def swap_mutation(individual):\n        idx1, idx2 = np.random.choice(range(N_P), 2, replace=False)\n        individual[idx1], individual[idx2] = individual[idx2], individual[idx1]\n        return individual\n\n    # Sub-function: Tournament Selection\n    def tournament_selection():\n        participants = np.random.choice(range(POP_SIZE), 3, replace=False)\n        best_idx = participants[np.argmin(pops['rankings'][participants])]\n        return pops['individuals'][best_idx]\n\n    # Main function body\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        parent1 = tournament_selection()\n        parent2 = tournament_selection()\n        child = pmx(parent1, parent2)\n        child = swap_mutation(child)\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.74817,
          "other_inf": null
     }
]