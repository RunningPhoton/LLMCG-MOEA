[
     {
          "algorithm": "i: set() for i in range(N_P)",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    \"\"\"\n    New algorithm: Edge Recombination Crossover (ERX) with Swap Mutation and Roulette Wheel Selection\n    \"\"\"\n    import numpy as np\n\n    def edge_recombination_crossover(parent1, parent2):\n        # Create edge map\n        edge_map = {i: set() for i in range(N_P)}\n        for p in [parent1, parent2]:\n            for i in range(N_P):\n                left = p[i - 1]\n                right = p[(i + 1) % N_P]\n                edge_map[p[i]].update([left, right])\n\n        # Start constructing the child\n        current = np.random.choice(parent1)\n        child = [current]\n        used = set([current])\n        while len(child) < N_P:\n            if edge_map[current]:\n                next_city = min(edge_map[current], key=lambda x: len(edge_map[x]))\n                edge_map[current].remove(next_city)\n            else:\n                next_city = np.random.choice(list(set(range(N_P)) - used))\n            for edges in edge_map.values():\n                edges.discard(current)\n            current = next_city\n            child.append(current)\n            used.add(current)\n        return child\n\n    def swap_mutation(individual):\n        idx1, idx2 = np.random.choice(range(N_P), 2, replace=False)\n        individual[idx1], individual[idx2] = individual[idx2], individual[idx1]\n        return individual\n\n    def roulette_wheel_selection(rankings):\n        total_fitness = np.sum(1 / (1 + rankings))\n        selection_probs = (1 / (1 + rankings)) / total_fitness\n        selected_index = np.random.choice(range(POP_SIZE), p=selection_probs)\n        return pops['individuals'][selected_index]\n\n    # Get rankings\n    rankings = pops['rankings']\n\n    # Create new population\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        parent1 = roulette_wheel_selection(rankings)\n        parent2 = roulette_wheel_selection(rankings)\n        child = edge_recombination_crossover(parent1, parent2)\n        if np.random.rand() < 0.1:  # mutation probability\n            child = swap_mutation(child)\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.82993,
          "other_inf": null
     },
     {
          "algorithm": "i: set() for i in range(N_P)",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n    \n    # Sub-function: Edge Recombination Crossover (ERX)\n    def erx(parent1, parent2):\n        # Create adjacency list for each node\n        adj_list = {i: set() for i in range(N_P)}\n        for i in range(N_P):\n            adj_set = set()\n            for parent in [parent1, parent2]:\n                idx = np.where(parent == i)[0][0]\n                adj_set.add(parent[(idx - 1) % N_P])\n                adj_set.add(parent[(idx + 1) % N_P])\n            adj_list[i] = adj_set\n        \n        # Start constructing the child with a random initial city\n        child = [-1] * N_P\n        current_city = np.random.choice(N_P)\n        child[0] = current_city\n        \n        # Construct the remaining path\n        for i in range(1, N_P):\n            # Remove current city from adjacency lists\n            for adj in adj_list.values():\n                adj.discard(current_city)\n            # Choose the next city with the fewest options in the adjacency list\n            if adj_list[current_city]:\n                next_city = min(adj_list[current_city], key=lambda x: len(adj_list[x]))\n            else:\n                remaining_cities = [city for city in range(N_P) if city not in child]\n                next_city = np.random.choice(remaining_cities)\n            child[i] = next_city\n            current_city = next_city\n        \n        return np.array(child, dtype=np.int32)\n\n    # Sub-function: Inversion Mutation\n    def inversion_mutation(individual):\n        start, end = np.sort(np.random.choice(range(N_P), 2, replace=False))\n        individual[start:end+1] = individual[start:end+1][::-1]\n        return individual\n\n    # Sub-function: Roulette Wheel Selection\n    def roulette_wheel_selection():\n        max_rank = np.max(pops['rankings']) + 1\n        # Convert rankings to fitness (higher is better)\n        fitness = max_rank - pops['rankings']\n        total_fitness = np.sum(fitness)\n        probabilities = fitness / total_fitness\n        selected_idx = np.random.choice(range(POP_SIZE), p=probabilities)\n        return pops['individuals'][selected_idx]\n\n    # Main function body\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        parent1 = roulette_wheel_selection()\n        parent2 = roulette_wheel_selection()\n        child = erx(parent1, parent2)\n        child = inversion_mutation(child)\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.81989,
          "other_inf": null
     },
     {
          "algorithm": "i: set() for i in range(N_P)}\n        for i in range(N_P):\n            edges[parent1[i]].update({parent1[(i-1) % N_P], parent1[(i+1) % N_P]})\n            edges[parent2[i]].update({parent2[(i-1) % N_P], parent2[(i+1) % N_P]",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n\n    # Edge Recombination Crossover (ERX)\n    def edge_recombination(parent1, parent2):\n        # Create the edge map\n        edges = {i: set() for i in range(N_P)}\n        for i in range(N_P):\n            edges[parent1[i]].update({parent1[(i-1) % N_P], parent1[(i+1) % N_P]})\n            edges[parent2[i]].update({parent2[(i-1) % N_P], parent2[(i+1) % N_P]})\n\n        # Start with a random city\n        current_city = np.random.choice(range(N_P))\n        child = [current_city]\n\n        # Construct the child\n        while len(child) < N_P:\n            for edge in edges.values():\n                edge.discard(current_city)\n            next_city = min(edges[current_city], key=lambda x: len(edges[x]), default=-1)\n            if next_city == -1:\n                next_city = np.random.choice(list(set(range(N_P)) - set(child)))\n            child.append(next_city)\n            current_city = next_city\n        return np.array(child, dtype=np.int32)\n\n    # Inversion Mutation\n    def inversion_mutation(individual):\n        start, end = np.sort(np.random.choice(range(N_P), 2, replace=False))\n        individual[start:end+1] = individual[start:end+1][::-1]\n        return individual\n\n    # Fitness Proportional Selection\n    def fitness_proportional_selection():\n        total_fitness = np.sum(1 / (1 + pops['rankings']))\n        probabilities = (1 / (1 + pops['rankings'])) / total_fitness\n        selected_idx = np.random.choice(range(POP_SIZE), p=probabilities)\n        return pops['individuals'][selected_idx]\n\n    # Main function body\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        parent1 = fitness_proportional_selection()\n        parent2 = fitness_proportional_selection()\n        child = edge_recombination(parent1, parent2)\n        child = inversion_mutation(child)\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.8197,
          "other_inf": null
     },
     {
          "algorithm": "Use Edge Recombination Crossover (ERX) to preserve edge adjacency information and apply inversion mutation for diversity, with a fitness-proportionate selection mechanism.}\n\n    def edge_recombination_crossover(parent1, parent2):\n        # Create the adjacency list for both parents\n        def create_adjacency_list(p):\n            adjacency_list = {i: set() for i in range(N_P)}\n            for i in range(N_P):\n                left = p[i - 1]\n                right = p[(i + 1) % N_P]\n                adjacency_list[p[i]].update([left, right])\n            return adjacency_list\n        \n        adjacency_list1 = create_adjacency_list(parent1)\n        adjacency_list2 = create_adjacency_list(parent2)\n        \n        # Merge the two adjacency lists\n        merged_adjacency_list = {i: adjacency_list1[i] | adjacency_list2[i] for i in range(N_P)",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n    \n    # Backbone idea: Generate new populations using crossover and mutation operations guided by selection mechanisms.\n    # New algorithm description: {Use Edge Recombination Crossover (ERX) to preserve edge adjacency information and apply inversion mutation for diversity, with a fitness-proportionate selection mechanism.}\n\n    def edge_recombination_crossover(parent1, parent2):\n        # Create the adjacency list for both parents\n        def create_adjacency_list(p):\n            adjacency_list = {i: set() for i in range(N_P)}\n            for i in range(N_P):\n                left = p[i - 1]\n                right = p[(i + 1) % N_P]\n                adjacency_list[p[i]].update([left, right])\n            return adjacency_list\n        \n        adjacency_list1 = create_adjacency_list(parent1)\n        adjacency_list2 = create_adjacency_list(parent2)\n        \n        # Merge the two adjacency lists\n        merged_adjacency_list = {i: adjacency_list1[i] | adjacency_list2[i] for i in range(N_P)}\n\n        # Start with a random city\n        current_city = np.random.choice(N_P)\n        child = [current_city]\n\n        # Build the child path\n        while len(child) < N_P:\n            # Remove the current city from all adjacency lists\n            for adj in merged_adjacency_list.values():\n                adj.discard(current_city)\n            # Choose the next city with the fewest neighbors\n            if merged_adjacency_list[current_city]:\n                next_city = min(merged_adjacency_list[current_city], key=lambda x: len(merged_adjacency_list[x]))\n            else:\n                remaining_cities = set(range(N_P)) - set(child)\n                next_city = np.random.choice(list(remaining_cities))\n            child.append(next_city)\n            current_city = next_city\n\n        return child\n\n    def inversion_mutation(individual):\n        start, end = np.sort(np.random.choice(range(N_P), 2, replace=False))\n        individual[start:end] = individual[start:end][::-1]\n        return individual\n\n    def fitness_proportionate_selection():\n        total_fitness = np.sum(pops['rankings'])\n        probabilities = (1 - (pops['rankings'] / total_fitness))\n        probabilities /= probabilities.sum()\n        selected_index = np.random.choice(range(POP_SIZE), p=probabilities)\n        return pops['individuals'][selected_index]\n\n    # Main function body\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        parent1 = fitness_proportionate_selection()\n        parent2 = fitness_proportionate_selection()\n        child = edge_recombination_crossover(parent1, parent2)\n        child = inversion_mutation(child)\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.81921,
          "other_inf": null
     },
     {
          "algorithm": "i: set() for i in range(N_P)}\n        for i in range(N_P):\n            adjacency_list[parent1[i]].update({parent1[(i-1) % N_P], parent1[(i+1) % N_P]})\n            adjacency_list[parent2[i]].update({parent2[(i-1) % N_P], parent2[(i+1) % N_P]",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    \"\"\"\n    Novel reproduction function using edge recombination crossover and inversion mutation to create a new population.\n    \"\"\"\n    import numpy as np\n\n    def edge_recombination_crossover(parent1, parent2):\n        # Create an adjacency list for each city\n        adjacency_list = {i: set() for i in range(N_P)}\n        for i in range(N_P):\n            adjacency_list[parent1[i]].update({parent1[(i-1) % N_P], parent1[(i+1) % N_P]})\n            adjacency_list[parent2[i]].update({parent2[(i-1) % N_P], parent2[(i+1) % N_P]})\n        \n        # Start with a random city\n        current_city = np.random.choice(range(N_P))\n        child = [current_city]\n        \n        # Build the child path\n        while len(child) < N_P:\n            # Remove the current city from other cities' adjacency lists\n            for city in adjacency_list:\n                adjacency_list[city].discard(current_city)\n            \n            # If current city has neighbors, select the one with the fewest neighbors, otherwise randomly\n            if adjacency_list[current_city]:\n                next_city = min(adjacency_list[current_city], key=lambda x: len(adjacency_list[x]))\n            else:\n                remaining_cities = list(set(range(N_P)) - set(child))\n                next_city = np.random.choice(remaining_cities)\n            \n            child.append(next_city)\n            current_city = next_city\n        \n        return child\n\n    def inversion_mutation(individual):\n        idx1, idx2 = np.random.choice(range(N_P), 2, replace=False)\n        if idx1 > idx2:\n            idx1, idx2 = idx2, idx1\n        individual[idx1:idx2+1] = individual[idx1:idx2+1][::-1]\n        return individual\n\n    def select_parents(fitness):\n        indices = np.random.choice(range(POP_SIZE), size=2, p=fitness, replace=False)\n        return pops['individuals'][indices[0]], pops['individuals'][indices[1]]\n\n    def compute_fitness(ranked_population):\n        # Invert rankings to compute fitness\n        fitness = 1 / (1 + ranked_population)\n        total_fitness = np.sum(fitness)\n        return fitness / total_fitness\n\n    # Calculate fitness and select parents\n    fitness = compute_fitness(pops['rankings'])\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n\n    # Generate new population\n    for i in range(POP_SIZE):\n        parent1, parent2 = select_parents(fitness)\n        child = edge_recombination_crossover(parent1, parent2)\n        child = inversion_mutation(child)\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.81766,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n\n    # Novel reproduction function: Ordered Crossover and Shift Mutation\n    def ordered_crossover(parent1, parent2):\n        # Generate two random crossover points\n        start, end = np.sort(np.random.choice(range(N_P), 2, replace=False))\n        # Initialize the child with placeholder values\n        child = [None]*N_P\n        # Copy the segment from the first parent to the child\n        child[start:end+1] = parent1[start:end+1]\n        # Fill the rest of the child with the cities from the second parent\n        p2_index = 0\n        for i in range(N_P):\n            if child[i] is None:\n                while parent2[p2_index] in child:\n                    p2_index += 1\n                child[i] = parent2[p2_index]\n        return np.array(child, dtype=np.int32)\n\n    def shift_mutation(individual):\n        # Randomly choose the number of positions to shift\n        num_positions = np.random.randint(1, N_P)\n        return np.roll(individual, num_positions)\n\n    def tournament_selection(k=3):\n        # Select k individuals from the population and choose the best\n        selected_indices = np.random.choice(range(POP_SIZE), k, replace=False)\n        selected_fitness = pops['rankings'][selected_indices]\n        best_index = selected_indices[np.argmin(selected_fitness)]\n        return pops['individuals'][best_index]\n\n    # Main function body\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        parent1 = tournament_selection()\n        parent2 = tournament_selection()\n        child = ordered_crossover(parent1, parent2)\n        child = shift_mutation(child)\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.80772,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n\n    def select_parents(fitness_probs):\n        return np.random.choice(range(POP_SIZE), size=2, replace=False, p=fitness_probs)\n\n    def order_crossover(parent1, parent2):\n        child = np.empty(N_P, dtype=np.int32)\n        child.fill(-1)\n        start, end = sorted(np.random.choice(range(N_P), 2, replace=False))\n        child[start:end+1] = parent1[start:end+1]\n        pos = (end + 1) % N_P\n        for gene in parent2:\n            if gene not in child:\n                child[pos] = gene\n                pos = (pos + 1) % N_P\n        return child\n\n    def swap_mutation(individual):\n        idx1, idx2 = np.random.choice(range(N_P), 2, replace=False)\n        individual[idx1], individual[idx2] = individual[idx2], individual[idx1]\n        return individual\n\n    def calculate_fitness(individual):\n        fitness = 0\n        for D in D_lst:\n            for i in range(N_P - 1):\n                fitness += D[individual[i], individual[i+1]]\n            fitness += D[individual[-1], individual[0]]\n        return fitness\n\n    individuals = pops['individuals']\n    fitness_values = np.array([calculate_fitness(ind) for ind in individuals])\n    fitness_probs = 1 / (fitness_values + 1)\n    fitness_probs /= fitness_probs.sum()\n\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        parent1_idx, parent2_idx = select_parents(fitness_probs)\n        parent1, parent2 = individuals[parent1_idx], individuals[parent2_idx]\n        child = order_crossover(parent1, parent2)\n        if np.random.rand() < 0.1:  # mutation probability\n            child = swap_mutation(child)\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.80201,
          "other_inf": null
     },
     {
          "algorithm": "Use a combination of edge recombination for crossover and inversion mutation to generate offspring.}\n    \n    def edge_recombination_crossover(parent1, parent2):\n        # Create the edge map for both parents\n        edge_map = {i: set() for i in range(N_P)}\n        for p in [parent1, parent2]:\n            for i in range(N_P):\n                next_city = p[(i + 1) % N_P]\n                prev_city = p[i - 1]\n                edge_map[p[i]].update({prev_city, next_city",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n\n    # The common backbone idea: Generate new populations by selecting parents based on fitness and applying crossover and mutation operations.\n    # The new algorithm: {Use a combination of edge recombination for crossover and inversion mutation to generate offspring.}\n    \n    def edge_recombination_crossover(parent1, parent2):\n        # Create the edge map for both parents\n        edge_map = {i: set() for i in range(N_P)}\n        for p in [parent1, parent2]:\n            for i in range(N_P):\n                next_city = p[(i + 1) % N_P]\n                prev_city = p[i - 1]\n                edge_map[p[i]].update({prev_city, next_city})\n        \n        # Start from the first city of parent1 and build the child\n        current_city = parent1[0]\n        child = [current_city]\n        while len(child) < N_P:\n            # Remove current city from edge map\n            for edges in edge_map.values():\n                edges.discard(current_city)\n            # Pick the next city with the fewest edges\n            if edge_map[current_city]:\n                next_city = min(edge_map[current_city], key=lambda x: len(edge_map[x]))\n            else:\n                next_city = np.random.choice([city for city in range(N_P) if city not in child])\n            child.append(next_city)\n            current_city = next_city\n        return child\n\n    def inversion_mutation(individual):\n        start, end = sorted(np.random.choice(range(N_P), 2, replace=False))\n        individual[start:end] = individual[start:end][::-1]\n        return individual\n    \n    def calculate_fitness(individual):\n        fitness = 0\n        for D in D_lst:\n            for i in range(N_P - 1):\n                fitness += D[individual[i], individual[i+1]]\n            fitness += D[individual[-1], individual[0]]\n        return fitness\n\n    def roulette_wheel_selection(fitness_values):\n        total_fitness = np.sum(fitness_values)\n        probabilities = fitness_values / total_fitness\n        selected_index = np.random.choice(range(POP_SIZE), p=probabilities)\n        return selected_index\n\n    individuals = pops['individuals']\n    fitness_values = np.array([calculate_fitness(ind) for ind in individuals])\n    # Invert fitness values for minimization problem\n    fitness_values = 1 / (fitness_values + 1e-9)\n\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        # Select parents using roulette wheel selection\n        parent1_idx = roulette_wheel_selection(fitness_values)\n        parent2_idx = roulette_wheel_selection(fitness_values)\n        parent1, parent2 = individuals[parent1_idx], individuals[parent2_idx]\n\n        # Apply edge recombination crossover\n        child = edge_recombination_crossover(parent1, parent2)\n        \n        # Apply inversion mutation with a certain probability\n        if np.random.rand() < 0.1:  # mutation probability\n            child = inversion_mutation(child)\n        \n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.79811,
          "other_inf": null
     },
     {
          "algorithm": "'rankings': ranked_population['rankings']",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n\n    def crossover(parent1, parent2):\n        child = []\n        childP1 = []\n        childP2 = []\n        \n        geneA = int(np.random.random() * len(parent1))\n        geneB = int(np.random.random() * len(parent1))\n        \n        startGene = min(geneA, geneB)\n        endGene = max(geneA, geneB)\n\n        for i in range(startGene, endGene):\n            childP1.append(parent1[i])\n            \n        childP2 = [item for item in parent2 if item not in childP1]\n\n        child = childP1 + childP2\n        return child\n\n    def mutate(individual, mutation_rate=0.01):\n        for swapped in range(len(individual)):\n            if(np.random.random() < mutation_rate):\n                swapWith = int(np.random.random() * len(individual))\n                \n                city1 = individual[swapped]\n                city2 = individual[swapWith]\n                \n                individual[swapped] = city2\n                individual[swapWith] = city1\n        return individual\n\n    def rank_selection(ranked_population, elite_size):\n        selection_results = []\n        df = {'rankings': ranked_population['rankings']}\n        df['cum_sum'] = np.cumsum(df['rankings'])\n        df['cum_perc'] = 100*df['cum_sum']/df['rankings'].sum()\n        \n        for i in range(0, elite_size):\n            selection_results.append(ranked_population['individuals'][i])\n        for i in range(0, len(ranked_population['individuals']) - elite_size):\n            pick = 100*np.random.random()\n            for i in range(0, len(ranked_population['individuals'])):\n                if pick <= df['cum_perc'][i]:\n                    selection_results.append(ranked_population['individuals'][i])\n                    break\n        return selection_results\n\n    def breed_population(matingpool, elite_size):\n        children = []\n        length = len(matingpool) - elite_size\n        pool = np.random.permutation(matingpool)\n\n        for i in range(0,elite_size):\n            children.append(matingpool[i])\n        \n        for i in range(0, length):\n            child = crossover(pool[i], pool[len(matingpool)-i-1])\n            children.append(child)\n        return children\n\n    def mutate_population(population, mutation_rate):\n        mutated_pop = []\n        \n        for ind in range(0, len(population)):\n            mutated_ind = mutate(population[ind], mutation_rate)\n            mutated_pop.append(mutated_ind)\n        return mutated_pop\n\n    elite_size = POP_SIZE // 10 if POP_SIZE >= 10 else 1\n    mutation_rate = 0.01\n\n    matingpool = rank_selection(pops, elite_size)\n    children = breed_population(matingpool, elite_size)\n    new_pops = np.array(mutate_population(children, mutation_rate), dtype=np.int32)\n\n    return new_pops",
          "objective": 0.79373,
          "other_inf": null
     },
     {
          "algorithm": "next_city, prev_city",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    \"\"\"\n    New algorithm: Edge Recombination Crossover (ERX) with Swap Mutation and Fitness Proportionate Selection\n    \"\"\"\n    import numpy as np\n    \n    def edge_recombination_crossover(parent1, parent2):\n        # Create edge map\n        edge_map = [set() for _ in range(N_P)]\n        for p in [parent1, parent2]:\n            for i in range(N_P):\n                next_city = p[(i + 1) % N_P]\n                prev_city = p[i - 1]\n                edge_map[p[i]].update({next_city, prev_city})\n        \n        # Start with the first city of parent1\n        child = [-1] * N_P\n        current_city = parent1[0]\n        child[0] = current_city\n        \n        # Construct the child\n        for i in range(1, N_P):\n            # Remove the current city from the edge map\n            for edges in edge_map:\n                edges.discard(current_city)\n            # Choose the next city with the fewest edges\n            if edge_map[current_city]:\n                next_city = min(edge_map[current_city], key=lambda x: len(edge_map[x]))\n            else:\n                # Choose a random city if no edges are left\n                remaining_cities = [city for city in range(N_P) if city not in child]\n                next_city = np.random.choice(remaining_cities)\n            child[i] = next_city\n            current_city = next_city\n        \n        return child\n\n    def swap_mutation(individual):\n        # Randomly select two different indices\n        idx1, idx2 = np.random.choice(range(N_P), 2, replace=False)\n        # Swap the cities at these indices\n        individual[idx1], individual[idx2] = individual[idx2], individual[idx1]\n        return individual\n\n    def fitness_proportionate_selection(ranked_individuals, rankings):\n        # Calculate selection probabilities\n        max_rank = np.max(rankings)\n        inverse_rankings = max_rank - rankings + 1\n        selection_probabilities = inverse_rankings / inverse_rankings.sum()\n        # Select an individual based on their fitness proportionate probability\n        selected_index = np.random.choice(range(POP_SIZE), p=selection_probabilities)\n        return ranked_individuals[selected_index]\n\n    # Get ranked individuals\n    rankings = pops['rankings']\n    individuals = pops['individuals']\n    ranked_individuals = individuals[np.argsort(rankings)]\n\n    # Create new population\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        parent1 = fitness_proportionate_selection(ranked_individuals, rankings)\n        parent2 = fitness_proportionate_selection(ranked_individuals, rankings)\n        child = edge_recombination_crossover(parent1, parent2)\n        if np.random.rand() < 0.1:  # mutation probability\n            child = swap_mutation(child)\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.77581,
          "other_inf": null
     }
]