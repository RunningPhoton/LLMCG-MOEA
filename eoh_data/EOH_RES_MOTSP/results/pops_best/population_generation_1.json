{
     "algorithm": "```",
     "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n\n    # Sub-function to calculate the combined costs from D_lst for a given path\n    def calculate_path_cost(path):\n        total_cost = 0\n        for o in range(D_lst.shape[0]):\n            for i in range(N_P - 1):\n                total_cost += D_lst[o, path[i], path[i+1]]\n            total_cost += D_lst[o, path[-1], path[0]]  # last to first city\n        return total_cost\n\n    # Sub-function for pairwise tournament selection\n    def tournament_selection():\n        idx1, idx2 = np.random.choice(range(POP_SIZE), 2, replace=False)\n        if pops['rankings'][idx1] <= pops['rankings'][idx2]:\n            return pops['individuals'][idx1].copy()\n        else:\n            return pops['individuals'][idx2].copy()\n\n    # Sub-function for order 1 crossover\n    def order_crossover(parent1, parent2):\n        child = -np.ones(N_P, dtype=np.int32)\n        start, end = sorted(np.random.choice(range(N_P), 2, replace=False))\n        child[start:end+1] = parent1[start:end+1]\n        filled = set(parent1[start:end+1])\n        fill_pos = (end + 1) % N_P\n        for city in parent2:\n            if city not in filled:\n                child[fill_pos] = city\n                filled.add(city)\n                fill_pos = (fill_pos + 1) % N_P\n        return child\n\n    # Sub-function for swap mutation\n    def swap_mutation(individual, mutation_rate=0.1):\n        if np.random.rand() < mutation_rate:\n            swap_indices = np.random.choice(range(N_P), 2, replace=False)\n            individual[swap_indices[0]], individual[swap_indices[1]] = individual[swap_indices[1]], individual[swap_indices[0]]\n        return individual\n\n    # Generating new population\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        # Select parents\n        parent1 = tournament_selection()\n        parent2 = tournament_selection()\n        # Generate a child\n        child = order_crossover(parent1, parent2)\n        # Mutate the child\n        child = swap_mutation(child)\n        # Store the child\n        new_pops[i] = child\n\n    return new_pops",
     "objective": 0.79869,
     "other_inf": null
}