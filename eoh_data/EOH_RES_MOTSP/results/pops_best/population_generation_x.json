{
     "algorithm": "i: set() for i in range(N_P)}\n        for i in range(N_P):\n            next1 = (i + 1) % N_P\n            prev1 = (i - 1 + N_P) % N_P\n            index_in_2 = np.where(parent2 == parent1[i])[0][0]\n            next2 = (index_in_2 + 1) % N_P\n            prev2 = (index_in_2 - 1 + N_P) % N_P\n            edges[parent1[i]].update([parent1[next1], parent1[prev1], parent2[next2], parent2[prev2]])\n        \n        # Create child\n        child = [None] * N_P\n        current_node = np.random.choice(parent1)\n        child[0] = current_node\n        used_nodes = {current_node",
     "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n    \n    individuals = pops['individuals']\n    rankings = pops['rankings']\n    \n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    \n    # Rank-based roulette wheel selection\n    def rank_based_selection():\n        probabilities = 1 / (rankings + 1)\n        probabilities /= probabilities.sum()\n        selected_index = np.random.choice(POP_SIZE, size=POP_SIZE, p=probabilities)\n        return individuals[selected_index]\n    \n    # Edge Recombination Crossover\n    def edge_recombination(parent1, parent2):\n        # Create edge map from parents\n        edges = {i: set() for i in range(N_P)}\n        for i in range(N_P):\n            next1 = (i + 1) % N_P\n            prev1 = (i - 1 + N_P) % N_P\n            index_in_2 = np.where(parent2 == parent1[i])[0][0]\n            next2 = (index_in_2 + 1) % N_P\n            prev2 = (index_in_2 - 1 + N_P) % N_P\n            edges[parent1[i]].update([parent1[next1], parent1[prev1], parent2[next2], parent2[prev2]])\n        \n        # Create child\n        child = [None] * N_P\n        current_node = np.random.choice(parent1)\n        child[0] = current_node\n        used_nodes = {current_node}\n        \n        for i in range(1, N_P):\n            for node in edges[current_node]:\n                edges[node].discard(current_node)\n            if edges[current_node]:\n                next_node = min(edges[current_node], key=lambda x: len(edges[x]))\n            else:\n                possible_nodes = [n for n in range(N_P) if n not in used_nodes]\n                next_node = np.random.choice(possible_nodes)\n            child[i] = next_node\n            current_node = next_node\n            used_nodes.add(current_node)\n        \n        return np.array(child, dtype=np.int32)\n\n    # Cycle crossover (CX2)\n    def cycle_crossover(parent1, parent2):\n        child = np.full(N_P, -1, dtype=np.int32)\n        start = 0\n        next_value = parent1[start]\n        child[start] = next_value\n        while True:\n            next_value = parent2[np.where(parent1 == next_value)[0][0]]\n            if next_value == child[start]:\n                break\n            child[np.where(parent1 == next_value)[0][0]] = next_value\n        child[child == -1] = parent2[child == -1]\n        return child\n\n    # Mutation: Reversing segments of the chromosome\n    def mutate(ind):\n        if np.random.rand() < 0.1:  # Mutation probability\n            start, end = np.sort(np.random.choice(N_P, 2, replace=False))\n            ind[start:end+1] = ind[start:end+1][::-1]\n        return ind\n    \n    selected_individuals = rank_based_selection()\n    \n    # Generate the new population using crossovers and mutations\n    for i in range(0, POP_SIZE, 2):\n        parent1, parent2 = selected_individuals[i], selected_individuals[(i + 1) % POP_SIZE]\n        # 50% chance to use either crossover\n        if np.random.rand() < 0.5:\n            new_pops[i] = edge_recombination(parent1, parent2)\n            if (i + 1) < POP_SIZE:\n                new_pops[i + 1] = edge_recombination(parent2, parent1)\n        else:\n            new_pops[i] = cycle_crossover(parent1, parent2)\n            if (i + 1) < POP_SIZE:\n                new_pops[i + 1] = cycle_crossover(parent2, parent1)\n        \n        # Applying mutation\n        new_pops[i] = mutate(new_pops[i])\n        if (i + 1) < POP_SIZE:\n            new_pops[i + 1] = mutate(new_pops[i + 1])\n    \n    return new_pops",
     "objective": 0.82889,
     "other_inf": null
}