{
     "algorithm": "```",
     "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n    \n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    \n    individuals = pops['individuals']\n    rankings = pops['rankings']\n        \n    # Internal Function: Ranking-Scaled Fitness Proportionate Selection\n    def fitness_proportionate_selection():\n        max_rank = np.max(rankings)\n        adjusted_fitness = max_rank + 1 - rankings\n        probabilities = adjusted_fitness / np.sum(adjusted_fitness)\n        selected_indices = np.random.choice(POP_SIZE, size=POP_SIZE, p=probabilities)\n        return individuals[selected_indices]\n    \n    # Internal Function: Edge Recombination Crossover (ERX)\n    def edge_recombination_crossover(parent1, parent2):\n        from collections import defaultdict\n        adjacency = defaultdict(set)\n        \n        def add_edges(parent):\n            for i in range(N_P):\n                left = parent[i - 1]\n                right = parent[(i + 1) % N_P]\n                adjacency[parent[i]].update([left, right])\n        \n        add_edges(parent1)\n        add_edges(parent2)\n        \n        current = np.random.choice(parent1)\n        child = [current]\n        for _ in range(1, N_P):\n            if current in adjacency:\n                neighbors = list(adjacency[current])\n            else:\n                neighbors = []\n            for neighbor in neighbors:\n                adjacency[neighbor].remove(current)\n            current = neighbors[np.argmin([len(adjacency[n]) for n in neighbors])] if neighbors else np.random.choice(list(set(range(N_P)) - set(child)))\n            child.append(current)\n        \n        return np.array(child, dtype=np.int32)\n    \n    # Population selection through fitness proportionate selection\n    selected_individuals = fitness_proportionate_selection()\n    \n    # Generating new population\n    for i in range(POP_SIZE):\n        if np.random.rand() < 0.75:  # 75% crossover rate\n            idx1, idx2 = np.random.choice(POP_SIZE, 2, replace=False)\n            new_pops[i] = edge_recombination_crossover(selected_individuals[idx1], selected_individuals[idx2])\n        else:  # 25% clone with mutation\n            new_pops[i] = selected_individuals[i]\n            if np.random.rand() < 0.2:  # 20% mutation rate\n                a, b = np.random.choice(N_P, 2, replace=False)\n                new_pops[i][a], new_pops[i][b] = new_pops[i][b], new_pops[i][a]\n    \n    return new_pops",
     "objective": 0.82567,
     "other_inf": null
}