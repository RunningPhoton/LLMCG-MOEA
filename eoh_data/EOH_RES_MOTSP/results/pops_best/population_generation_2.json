{
     "algorithm": "i: set() for i in range(N_P)",
     "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n    \n    # Extract data from input population structure\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n    \n    # Initialize new population array\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    \n    # Edge Recombination crossover is used to preserve edge relationships\n    def edge_recombination_crossover(parent1, parent2):\n        # Build the edge map from both parents\n        edge_map = {i: set() for i in range(N_P)}\n        for p in [parent1, parent2]:\n            for i in range(N_P):\n                left = p[i - 1]\n                right = p[(i + 1) % N_P]\n                edge_map[p[i]].update([left, right])\n        \n        # Start the crossover process\n        current = np.random.choice(N_P)\n        child = [current]\n        used = set(child)\n        \n        for _ in range(1, N_P):\n            if current in edge_map:\n                # Remove the used node from other nodes' edge list\n                for node_set in edge_map.values():\n                    node_set.discard(current)\n                options = list(edge_map[current])\n                # Choose the next node with the fewest edges\n                if options:\n                    next_node = min(options, key=lambda x: len(edge_map[x]))\n                else:\n                    next_node = np.random.choice(list(set(range(N_P)) - used))\n            current = next_node\n            child.append(current)\n            used.add(current)\n        \n        return child\n\n    # Mutation: Swap two cities at random positions\n    def swap_mutation(ind):\n        idx1, idx2 = np.random.choice(N_P, 2, replace=False)\n        ind[idx1], ind[idx2] = ind[idx2], ind[idx1]\n        return ind\n    \n    # Selection by rank-based probability\n    def rank_based_selection():\n        probabilities = 1 / (rankings + 1)\n        probabilities /= np.sum(probabilities)\n        return individuals[np.random.choice(POP_SIZE, p=probabilities)]\n    \n    # Assemble new population\n    for i in range(POP_SIZE):\n        # Select parents\n        parent1 = rank_based_selection()\n        parent2 = rank_based_selection()\n        \n        # Crossover\n        child = edge_recombination_crossover(parent1, parent2)\n        \n        # Mutation \n        if np.random.rand() < 0.05:\n            child = swap_mutation(child)\n        \n        # Place child in new population\n        new_pops[i] = child\n    \n    return new_pops",
     "objective": 0.82343,
     "other_inf": null
}