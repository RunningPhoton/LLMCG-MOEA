[
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n    \n    def tournament_selection(ranking, k=3):\n        \"\"\" Selects an index using k-way tournament selection \"\"\"\n        selected_index = np.random.choice(len(ranking), k, replace=False)\n        return selected_index[np.argmin(ranking[selected_index])]\n    \n    def recombine(parent1, parent2):\n        \"\"\" Perform Ordered Crossover (OX) for recombination \"\"\"\n        start, end = sorted(np.random.choice(N_P, 2, replace=False))\n        child = np.full(N_P, -1, dtype=np.int32)\n        # Copy the slice from the first parent\n        child[start:end+1] = parent1[start:end+1]\n        # Fill the rest from the second parent\n        fill_pos = (end + 1) % N_P\n        for city in parent2:\n            if city not in child:\n                child[fill_pos] = city\n                fill_pos = (fill_pos + 1) % N_P\n        return child\n\n    def mutate(path):\n        \"\"\" Randomly swaps two cities in the path \"\"\"\n        a, b = np.random.choice(N_P, 2, replace=False)\n        path[a], path[b] = path[b], path[a]\n        return path\n    \n    # Current population individuals and their rankings\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n    \n    new_pops = np.full((POP_SIZE, N_P), -1, dtype=np.int32)\n    \n    # Generate new population\n    for i in range(POP_SIZE):\n        # Select parents via tournament selection\n        parent1 = individuals[tournament_selection(rankings)]\n        parent2 = individuals[tournament_selection(rankings)]\n        while np.array_equal(parent1, parent2):\n            parent2 = individuals[tournament_selection(rankings)]\n        \n        # Recombine parents to create a new individual\n        child = recombine(parent1, parent2)\n        \n        # Mutate the child with a certain probability\n        if np.random.rand() < 0.15:  # Example mutation probability\n            child = mutate(child)\n        \n        new_pops[i] = child\n    \n    return new_pops",
          "objective": 0.7962,
          "other_inf": null
     },
     {
          "algorithm": "A genetic-based algorithm that uses tournament selection, crossover, mutation and elitism to generate the next generation of the population for a multi-objective traveling salesman problem.",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    \"\"\"\n    {A genetic-based algorithm that uses tournament selection, crossover, mutation and elitism to generate the next generation of the population for a multi-objective traveling salesman problem.}\n    \n    :param pops: The current population structured as a dictionary with 'individuals' and 'rankings'.\n    :param D_lst: An array of cost matrices across multiple objectives.\n    :param POP_SIZE: The number of individuals in each population.\n    :param N_P: The number of cities to be visited.\n    :return: new_pops, a numpy.ndarray with shape (POP_SIZE, N_P).\n    \"\"\"\n    \n    import numpy as np\n\n    # Extract elements of the population dictionary\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n    \n    # Tournament Selection Helper Function\n    def tournament_selection(k=2):\n        \"\"\"Randomly select `k` individuals and return the best one based on rankings.\"\"\"\n        selected_indices = np.random.choice(POP_SIZE, k, replace=False)\n        best_index = selected_indices[np.argmin(rankings[selected_indices])]\n        return individuals[best_index]\n    \n    # Crossover Helper Function\n    def crossover(parent1, parent2):\n        \"\"\"Perform Order Crossover (OX) between two parent permutations.\"\"\"\n        start, end = sorted(np.random.choice(N_P, 2, replace=False))\n        child = [None]*N_P\n        child[start:end+1] = parent1[start:end+1]\n        p2_items = [item for item in parent2 if item not in child]\n        fill_positions = [i for i in range(N_P) if child[i] is None]\n        for i, pos in enumerate(fill_positions):\n            child[pos] = p2_items[i]\n        return child\n\n    # Mutation Helper Function\n    def mutate(individual, mutation_rate=0.2):\n        \"\"\"Perform a swap mutation on individual permutation with given mutation rate.\"\"\"\n        if np.random.rand() < mutation_rate:\n            swap_idx1, swap_idx2 = np.random.choice(N_P, 2, replace=False)\n            individual[swap_idx1], individual[swap_idx2] = individual[swap_idx2], individual[swap_idx1]\n        return individual\n\n    # Generate new population\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    \n    # Elitism: Keep the best individual\n    elite_idx = np.argmin(rankings)\n    new_pops[0] = individuals[elite_idx]\n    \n    for i in range(1, POP_SIZE):\n        parent1 = tournament_selection()\n        parent2 = tournament_selection()\n        child = crossover(parent1, parent2)\n        child = mutate(child)\n        new_pops[i] = child\n    \n    return new_pops",
          "objective": 0.76645,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n\n    def calculate_total_cost(individual, costs):\n        total_cost = 0\n        N_O, _, _ = costs.shape\n        for o in range(N_O):\n            for i in range(len(individual) - 1):\n                total_cost += costs[o, individual[i], individual[i+1]]\n            total_cost += costs[o, individual[-1], individual[0]]  # Complete the cycle\n        return total_cost\n\n    def tournament_select(pops, k=3):\n        selected_indices = np.random.choice(range(len(pops['rankings'])), k, replace=False)\n        selected_fitness = pops['rankings'][selected_indices]\n        winner_index = selected_indices[np.argmin(selected_fitness)]\n        return pops['individuals'][winner_index]\n\n    def crossover(parent1, parent2):\n        start, end = sorted(np.random.choice(range(N_P), 2, replace=False))\n        child = np.full(N_P, -1, dtype=np.int32)\n        child[start:end+1] = parent1[start:end+1]\n\n        available_positions = list(np.where(child == -1)[0])\n        for idx in available_positions:\n            value = parent2[np.where(np.isin(parent2, child, invert=True))[0][0]]\n            child[idx] = value\n        return child\n\n    def mutate(individual, mutation_rate=0.2):\n        if np.random.random() < mutation_rate:\n            i, j = np.random.choice(range(N_P), 2, replace=False)\n            individual[i], individual[j] = individual[j], individual[i]\n        return individual\n    \n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n\n    for i in range(POP_SIZE):\n        parent1 = tournament_select(pops)\n        parent2 = tournament_select(pops)\n        child = crossover(parent1, parent2)\n        child = mutate(child)\n        new_pops[i] = child\n        \n    return new_pops",
          "objective": 0.76189,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n\n    def crossover(parent1, parent2):\n        child = np.full(N_P, -1, dtype=np.int32)\n        start_idx, end_idx = sorted(np.random.choice(N_P, 2, replace=False))\n        child[start_idx:end_idx+1] = parent1[start_idx:end_idx+1]\n        fill_positions = np.where(child == -1)[0]\n        to_fill = [c for c in parent2 if c not in child[start_idx:end_idx+1]]\n        child[fill_positions] = to_fill\n        return child\n\n    def mutate(individual, mutation_rate=0.15):\n        if np.random.rand() < mutation_rate:\n            idx1, idx2 = np.random.choice(N_P, 2, replace=False)\n            individual[idx1], individual[idx2] = individual[idx2], individual[idx1]\n        return individual\n\n    # Extract current population and rankings\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n\n    # Tournament selection based on rankings\n    def tournament_select():\n        participants = np.random.choice(POP_SIZE, 4, replace=False)\n        selected = np.argmin(rankings[participants])\n        return individuals[participants[selected]]\n\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n\n    for i in range(POP_SIZE):\n        parent1 = tournament_select()\n        parent2 = tournament_select()\n        child = crossover(parent1, parent2)\n        child = mutate(child)\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.74982,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n\n    def tournament_selection():\n        contenders = np.random.randint(0, POP_SIZE, size=4)\n        winner = contenders[np.argmin(pops['rankings'][contenders])]\n        return pops['individuals'][winner].copy()\n\n    def crossover(parent1, parent2):\n        cross_point1, cross_point2 = np.sort(np.random.choice(N_P, size=2, replace=False))\n        child = np.empty(N_P, dtype=np.int32)\n        middle = parent1[cross_point1:cross_point2]\n        child[cross_point1:cross_point2] = middle\n        filled_positions = set(middle)\n        fill_index = 0\n        for city in parent2:\n            if city not in filled_positions:\n                if fill_index == cross_point1:\n                    fill_index = cross_point2\n                child[fill_index] = city\n                fill_index += 1\n        return child\n\n    def mutate(individual):\n        swap1, swap2 = np.random.choice(N_P, size=2, replace=False)\n        individual[swap1], individual[swap2] = individual[swap2], individual[swap1]\n        return individual\n\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    \n    for i in range(POP_SIZE):\n        if np.random.rand() < 0.9:  # Crossover probability\n            parent1 = tournament_selection()\n            parent2 = tournament_selection()\n            child = crossover(parent1, parent2)\n            if np.random.rand() < 0.1:  # Mutation probability\n                child = mutate(child)\n        else:\n            child = tournament_selection()\n            if np.random.rand() < 0.1:\n                child = mutate(child)\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.74757,
          "other_inf": null
     },
     {
          "algorithm": "This novel reproduction function leverages a blend of guided mutation inspired \n    by rankings and selective crossover to manage diversification and intensification.",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    \"\"\"\n    {This novel reproduction function leverages a blend of guided mutation inspired \n    by rankings and selective crossover to manage diversification and intensification.}\n\n    :param pops: Current population as a dictionary with 'individuals' and 'rankings'\n    :param D_lst: 3D numpy.ndarray of different travel cost matrices\n    :param POP_SIZE: Integer number of individuals in the population\n    :param N_P: Integer number of cities to visit\n    :returns new_pops: numpy.ndarray with shape (POP_SIZE, N_P) of new individuals\n    \"\"\"\n    import numpy as np\n\n    # Extract individuals and rankings\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n    \n    # New population holder\n    new_pops = np.empty_like(individuals)\n    \n    # Selection function for choosing parents based on rankings (tournament style)\n    def select_parents():\n        tournament_size = 4\n        selected_indices = np.random.choice(POP_SIZE, size=tournament_size, replace=False)\n        selected_rankings = rankings[selected_indices]\n        winner_index = selected_indices[np.argmin(selected_rankings)]\n        return individuals[winner_index]\n    \n    # Crossover function (order based)\n    def crossover(parent1, parent2):\n        start, end = sorted(np.random.choice(N_P, size=2, replace=False))\n        child = np.empty(N_P, dtype=np.int32)\n        child[start:end+1] = parent1[start:end+1]\n        filled_positions = set(parent1[start:end+1])\n        fill_idx = 0\n        for city in parent2:\n            if city not in filled_positions:\n                if fill_idx == start:\n                    fill_idx = end + 1\n                child[fill_idx] = city\n                fill_idx += 1\n        return child\n    \n    # Mutation function (swap mutation)\n    def mutate(individual):\n        idx1, idx2 = np.random.choice(N_P, size=2, replace=False)\n        individual[idx1], individual[idx2] = individual[idx2], individual[idx1]\n        return individual\n    \n    # Generate new population\n    for i in range(POP_SIZE):\n        if i < POP_SIZE // 2:\n            # Directly inherit some of the best individuals\n            new_pops[i] = individuals[i].copy()\n        else:\n            # Perform crossover and mutation on selected parents\n            parent1 = select_parents()\n            parent2 = select_parents()\n            child = crossover(parent1, parent2)\n            if np.random.rand() < 0.2:  # Mutation probability\n                child = mutate(child)\n            new_pops[i] = child\n            \n    return new_pops",
          "objective": 0.72198,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    \"\"\"\n    A novel evolutionary reproduction function for multi-objective TSP that mixes crossover,\n    mutation and relates offspring fitness to multiple objectives by selectively breeding and\n    recombining paths from ranked individuals, using iterated local search for mutations.\n    \n    :param pops: Current population and rankings.\n    :param D_lst: Costs matrices between cities for multiple objectives.\n    :param POP_SIZE: Size of the population.\n    :param N_P: Number of cities.\n    :return: New population of paths.\n    \"\"\"\n\n    import numpy as np\n    \n    individuals = pops['individuals']\n    rankings = pops['rankings']\n    \n    # Function to perform crossover\n    def ordered_crossover(parent1, parent2):\n        start, end = sorted(np.random.choice(range(N_P), 2, replace=False))\n        child = -np.ones(N_P, dtype=np.int32)\n        child[start:end+1] = parent1[start:end+1]\n        fill_values = [x for x in parent2 if x not in child[start:end+1]]\n        fill_pos = [i for i in range(N_P) if child[i] == -1]\n        for fp, value in zip(fill_pos, fill_values):\n            child[fp] = value\n        return child\n\n    # Function to perform mutation\n    def swap_mutation(individual):\n        idx1, idx2 = np.random.choice(range(N_P), 2, replace=False)\n        individual[idx1], individual[idx2] = individual[idx2], individual[idx1]\n        return individual\n\n    # Creating new population\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    \n    # Tournament Selection - Top 50% are used for breeding\n    breeding_size = POP_SIZE // 2\n    best_individuals = individuals[np.argsort(rankings)[:breeding_size]]\n    \n    # Reproduce by crossover and mutation\n    for i in range(POP_SIZE):\n        # Select parents\n        parents = best_individuals[np.random.choice(range(breeding_size), 2, replace=False)]\n        # Crossover\n        child = ordered_crossover(parents[0], parents[1])\n        # Mutation\n        if np.random.rand() < 0.2:  # mutation rate\n            child = swap_mutation(child)\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.71996,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n\n    def tournament_selection(rankings, k=3):\n        selected_indices = np.random.choice(len(rankings), k, replace=False)\n        best_index = selected_indices[np.argmin(rankings[selected_indices])]\n        return best_index\n    \n    def crossover(parent1, parent2):\n        cut = np.random.randint(1, N_P-1)\n        child = np.zeros(N_P, dtype=np.int32)\n        child[:cut] = parent1[:cut]\n        p2_filtered = [x for x in parent2 if x not in child[:cut]]\n        child[cut:] = p2_filtered\n        return child\n    \n    def mutate(path, mutation_rate=0.2):\n        if np.random.rand() < mutation_rate:\n            swap_idx1, swap_idx2 = np.random.choice(N_P, 2, replace=False)\n            path[swap_idx1], path[swap_idx2] = path[swap_idx2], path[swap_idx1]\n        return path\n\n    new_pops = np.zeros_like(pops['individuals'])\n    for i in range(POP_SIZE):\n        idx1 = tournament_selection(pops['rankings'])\n        idx2 = tournament_selection(pops['rankings'])\n        parent1 = pops['individuals'][idx1]\n        parent2 = pops['individuals'][idx2]\n        child = crossover(parent1, parent2)\n        child = mutate(child)\n        new_pops[i] = child\n    \n    return new_pops",
          "objective": 0.7068,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n    \n    # Extract individuals and their rankings\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n    \n    # Create new empty population array\n    new_pops = np.zeros_like(individuals)\n    \n    # Step 1: Tournament selection based on ranking\n    def tournament_selection():\n        # Tournament pool size, generally between 2 and 5\n        tournament_size = 3\n        selected_indices = []\n        for _ in range(POP_SIZE):\n            participants = np.random.choice(POP_SIZE, tournament_size, replace=False)\n            winner_idx = participants[np.argmin(rankings[participants])]\n            selected_indices.append(winner_idx)\n        return individuals[selected_indices]\n\n    # Step 2: Partially Mapped Crossover (PMX) reproduction\n    def pmx(parent1, parent2):\n        start, end = sorted(np.random.randint(0, N_P, 2))\n        offspring = np.full(N_P, -1, dtype=np.int32)\n        offspring[start:end+1] = parent1[start:end+1]\n        \n        for idx in range(start, end+1):\n            if parent2[idx] not in offspring:\n                pos = idx\n                while start <= pos <= end:\n                    pos = np.where(parent2 == parent1[pos])[0][0]\n                offspring[pos] = parent2[idx]\n        \n        for i in range(N_P):\n            if offspring[i] == -1:\n                offspring[i] = parent2[i]\n        \n        return offspring\n    \n    # Step 3: Generate new population using selection and crossover\n    selected_individuals = tournament_selection()\n    np.random.shuffle(selected_individuals)  # shuffling to avoid bias in pairing\n    \n    for i in range(0, POP_SIZE, 2):\n        # Ensure that a mate exists for current parent; if odd number, copy the last one\n        if i + 1 < POP_SIZE:\n            parent1, parent2 = selected_individuals[i], selected_individuals[i+1]\n            new_pops[i] = pmx(parent1, parent2)\n            new_pops[i+1] = pmx(parent2, parent1)\n        else:\n            new_pops[i] = selected_individuals[i]\n    \n    # Check and ensure each row contains all cities exactly once; recourse to reshuffling if not\n    for i in range(POP_SIZE):\n        if len(set(new_pops[i])) != N_P:\n            new_pops[i] = np.random.permutation(N_P)\n    \n    return new_pops",
          "objective": 0.59655,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n    \n    # Access current individuals and their rankings\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n    \n    # New population container\n    new_pops = np.empty_like(individuals)\n    \n    # Tournament selection: Select two random individuals, choose the one with better ranking\n    def tournament_selection():\n        competitor_1, competitor_2 = np.random.choice(POP_SIZE, 2, replace=False)\n        if rankings[competitor_1] < rankings[competitor_2]:\n            return individuals[competitor_1].copy()\n        else:\n            return individuals[competitor_2].copy()\n    \n    # Heuristic crossover: Combining parts from two parents considering minimal additional cost\n    def heuristic_crossover(parent1, parent2):\n        child = np.full(N_P, -1, dtype=np.int32)\n        start_city = np.random.randint(N_P)\n        child[0] = start_city\n        used_cities = set([start_city])\n\n        # Build child by choosing the next city with minimal added cost not present in child\n        for i in range(1, N_P):\n            last_city = child[i-1]\n            min_cost = np.inf\n            next_city = -1\n            for j in range(N_P):\n                if j not in used_cities and D_lst[0, last_city, j] < min_cost:  # Using the first matrix for simplicity\n                    min_cost = D_lst[0, last_city, j]\n                    next_city = j\n            child[i] = next_city\n            used_cities.add(next_city)\n        \n        return child\n    \n    # Mutation: Swap two cities\n    def mutation(path):\n        idx1, idx2 = np.random.choice(N_P, 2, replace=False)\n        path[idx1], path[idx2] = path[idx2], path[idx1]\n        return path\n    \n    # Form new population\n    for i in range(POP_SIZE):\n        parent1 = tournament_selection()\n        parent2 = tournament_selection()\n\n        # Crossover (here apply heuristic crossover)\n        child = heuristic_crossover(parent1, parent2)\n        \n        # Mutation (apply with a probability)\n        if np.random.rand() < 0.15:\n            child = mutation(child)\n        \n        new_pops[i] = child\n    \n    return new_pops",
          "objective": 0.49156,
          "other_inf": null
     }
]