[
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n    \n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    \n    individuals = pops['individuals']\n    rankings = pops['rankings']\n        \n    # Internal Function: Ranking-Scaled Fitness Proportionate Selection\n    def fitness_proportionate_selection():\n        max_rank = np.max(rankings)\n        adjusted_fitness = max_rank + 1 - rankings\n        probabilities = adjusted_fitness / np.sum(adjusted_fitness)\n        selected_indices = np.random.choice(POP_SIZE, size=POP_SIZE, p=probabilities)\n        return individuals[selected_indices]\n    \n    # Internal Function: Edge Recombination Crossover (ERX)\n    def edge_recombination_crossover(parent1, parent2):\n        from collections import defaultdict\n        adjacency = defaultdict(set)\n        \n        def add_edges(parent):\n            for i in range(N_P):\n                left = parent[i - 1]\n                right = parent[(i + 1) % N_P]\n                adjacency[parent[i]].update([left, right])\n        \n        add_edges(parent1)\n        add_edges(parent2)\n        \n        current = np.random.choice(parent1)\n        child = [current]\n        for _ in range(1, N_P):\n            if current in adjacency:\n                neighbors = list(adjacency[current])\n            else:\n                neighbors = []\n            for neighbor in neighbors:\n                adjacency[neighbor].remove(current)\n            current = neighbors[np.argmin([len(adjacency[n]) for n in neighbors])] if neighbors else np.random.choice(list(set(range(N_P)) - set(child)))\n            child.append(current)\n        \n        return np.array(child, dtype=np.int32)\n    \n    # Population selection through fitness proportionate selection\n    selected_individuals = fitness_proportionate_selection()\n    \n    # Generating new population\n    for i in range(POP_SIZE):\n        if np.random.rand() < 0.75:  # 75% crossover rate\n            idx1, idx2 = np.random.choice(POP_SIZE, 2, replace=False)\n            new_pops[i] = edge_recombination_crossover(selected_individuals[idx1], selected_individuals[idx2])\n        else:  # 25% clone with mutation\n            new_pops[i] = selected_individuals[i]\n            if np.random.rand() < 0.2:  # 20% mutation rate\n                a, b = np.random.choice(N_P, 2, replace=False)\n                new_pops[i][a], new_pops[i][b] = new_pops[i][b], new_pops[i][a]\n    \n    return new_pops",
          "objective": 0.82567,
          "other_inf": null
     },
     {
          "algorithm": "i: set() for i in range(N_P)",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n    \n    # Extract data from input population structure\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n    \n    # Initialize new population array\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    \n    # Edge Recombination crossover is used to preserve edge relationships\n    def edge_recombination_crossover(parent1, parent2):\n        # Build the edge map from both parents\n        edge_map = {i: set() for i in range(N_P)}\n        for p in [parent1, parent2]:\n            for i in range(N_P):\n                left = p[i - 1]\n                right = p[(i + 1) % N_P]\n                edge_map[p[i]].update([left, right])\n        \n        # Start the crossover process\n        current = np.random.choice(N_P)\n        child = [current]\n        used = set(child)\n        \n        for _ in range(1, N_P):\n            if current in edge_map:\n                # Remove the used node from other nodes' edge list\n                for node_set in edge_map.values():\n                    node_set.discard(current)\n                options = list(edge_map[current])\n                # Choose the next node with the fewest edges\n                if options:\n                    next_node = min(options, key=lambda x: len(edge_map[x]))\n                else:\n                    next_node = np.random.choice(list(set(range(N_P)) - used))\n            current = next_node\n            child.append(current)\n            used.add(current)\n        \n        return child\n\n    # Mutation: Swap two cities at random positions\n    def swap_mutation(ind):\n        idx1, idx2 = np.random.choice(N_P, 2, replace=False)\n        ind[idx1], ind[idx2] = ind[idx2], ind[idx1]\n        return ind\n    \n    # Selection by rank-based probability\n    def rank_based_selection():\n        probabilities = 1 / (rankings + 1)\n        probabilities /= np.sum(probabilities)\n        return individuals[np.random.choice(POP_SIZE, p=probabilities)]\n    \n    # Assemble new population\n    for i in range(POP_SIZE):\n        # Select parents\n        parent1 = rank_based_selection()\n        parent2 = rank_based_selection()\n        \n        # Crossover\n        child = edge_recombination_crossover(parent1, parent2)\n        \n        # Mutation \n        if np.random.rand() < 0.05:\n            child = swap_mutation(child)\n        \n        # Place child in new population\n        new_pops[i] = child\n    \n    return new_pops",
          "objective": 0.82343,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n    \n    # Initiate new generation population array with paths of cities\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    \n    # Get the individuals and corresponding rankings from the provided population dictionary\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n    \n    # Function internal to reverse sections of the array as mutation\n    def reverse_subsection(path):\n        path_copy = path.copy()\n        if N_P > 2:\n            left, right = sorted(np.random.choice(N_P, 2, replace=False))\n            path_copy[left:right+1] = path_copy[left:right+1][::-1]\n        return path_copy\n    \n    # Function internal to directly clone the best performing individuals with a chance of mutation\n    def elitist_preservation():\n        sorted_indices = np.argsort(rankings)\n        elite_count = POP_SIZE // 5  # Take top 20% as elite\n        for i in range(elite_count):\n            if np.random.rand() < 0.1:  # 10% mutation probability for elites\n                new_pops[i] = reverse_subsection(individuals[sorted_indices[i]])\n            else:\n                new_pops[i] = individuals[sorted_indices[i]]\n    \n    # Function internal to perform crossover using Partially Mapped Crossover (PMX)\n    def pmx(parent1, parent2):\n        child = np.empty(N_P, dtype=np.int32)\n        child.fill(-1)\n        start, end = sorted(np.random.choice(N_P, 2, replace=False))\n        child[start:end+1] = parent1[start:end+1]\n        for i in range(start, end + 1):\n            if parent2[i] not in child:\n                current_pos = i\n                while start <= current_pos and current_pos <= end:\n                    current_pos = np.where(parent2 == parent1[current_pos])[0][0]\n                child[current_pos] = parent2[i]\n        for i in range(N_P):\n            if child[i] == -1:\n                child[i] = parent2[i]\n        return child\n    \n    # Fill the rest of new generation with children produced through crossover and mutation\n    elitist_preservation()\n    for i in range(POP_SIZE // 5, POP_SIZE):\n        parent1_idx = np.random.choice(POP_SIZE)\n        parent2_idx = np.random.choice(POP_SIZE)\n        if np.random.rand() < 0.8:  # 80% crossover chance\n            new_pops[i] = pmx(individuals[parent1_idx], individuals[parent2_idx])\n        else:  # direct copying with mutation\n            new_pops[i] = reverse_subsection(individuals[parent1_idx])\n        # Mutation\n        if np.random.rand() < 0.15:\n            new_pops[i] = reverse_subsection(new_pops[i])\n        \n    return new_pops",
          "objective": 0.80467,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n\n    # Sub-function to calculate the combined costs from D_lst for a given path\n    def calculate_path_cost(path):\n        total_cost = 0\n        for o in range(D_lst.shape[0]):\n            for i in range(N_P - 1):\n                total_cost += D_lst[o, path[i], path[i+1]]\n            total_cost += D_lst[o, path[-1], path[0]]  # last to first city\n        return total_cost\n\n    # Sub-function for pairwise tournament selection\n    def tournament_selection():\n        idx1, idx2 = np.random.choice(range(POP_SIZE), 2, replace=False)\n        if pops['rankings'][idx1] <= pops['rankings'][idx2]:\n            return pops['individuals'][idx1].copy()\n        else:\n            return pops['individuals'][idx2].copy()\n\n    # Sub-function for order 1 crossover\n    def order_crossover(parent1, parent2):\n        child = -np.ones(N_P, dtype=np.int32)\n        start, end = sorted(np.random.choice(range(N_P), 2, replace=False))\n        child[start:end+1] = parent1[start:end+1]\n        filled = set(parent1[start:end+1])\n        fill_pos = (end + 1) % N_P\n        for city in parent2:\n            if city not in filled:\n                child[fill_pos] = city\n                filled.add(city)\n                fill_pos = (fill_pos + 1) % N_P\n        return child\n\n    # Sub-function for swap mutation\n    def swap_mutation(individual, mutation_rate=0.1):\n        if np.random.rand() < mutation_rate:\n            swap_indices = np.random.choice(range(N_P), 2, replace=False)\n            individual[swap_indices[0]], individual[swap_indices[1]] = individual[swap_indices[1]], individual[swap_indices[0]]\n        return individual\n\n    # Generating new population\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        # Select parents\n        parent1 = tournament_selection()\n        parent2 = tournament_selection()\n        # Generate a child\n        child = order_crossover(parent1, parent2)\n        # Mutate the child\n        child = swap_mutation(child)\n        # Store the child\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.79869,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n    \n    def tournament_selection(ranking, k=3):\n        \"\"\" Selects an index using k-way tournament selection \"\"\"\n        selected_index = np.random.choice(len(ranking), k, replace=False)\n        return selected_index[np.argmin(ranking[selected_index])]\n    \n    def recombine(parent1, parent2):\n        \"\"\" Perform Ordered Crossover (OX) for recombination \"\"\"\n        start, end = sorted(np.random.choice(N_P, 2, replace=False))\n        child = np.full(N_P, -1, dtype=np.int32)\n        # Copy the slice from the first parent\n        child[start:end+1] = parent1[start:end+1]\n        # Fill the rest from the second parent\n        fill_pos = (end + 1) % N_P\n        for city in parent2:\n            if city not in child:\n                child[fill_pos] = city\n                fill_pos = (fill_pos + 1) % N_P\n        return child\n\n    def mutate(path):\n        \"\"\" Randomly swaps two cities in the path \"\"\"\n        a, b = np.random.choice(N_P, 2, replace=False)\n        path[a], path[b] = path[b], path[a]\n        return path\n    \n    # Current population individuals and their rankings\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n    \n    new_pops = np.full((POP_SIZE, N_P), -1, dtype=np.int32)\n    \n    # Generate new population\n    for i in range(POP_SIZE):\n        # Select parents via tournament selection\n        parent1 = individuals[tournament_selection(rankings)]\n        parent2 = individuals[tournament_selection(rankings)]\n        while np.array_equal(parent1, parent2):\n            parent2 = individuals[tournament_selection(rankings)]\n        \n        # Recombine parents to create a new individual\n        child = recombine(parent1, parent2)\n        \n        # Mutate the child with a certain probability\n        if np.random.rand() < 0.15:  # Example mutation probability\n            child = mutate(child)\n        \n        new_pops[i] = child\n    \n    return new_pops",
          "objective": 0.7962,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n    \n    # Accessing individuals and their rankings from the population dictionary\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n    \n    # Initialize new population array\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n\n    # Compute cumulative rankings for selection pressure: higher ranked individuals are more likely to reproduce\n    cumulative_rankings = np.cumsum(1 / (rankings + 1))\n    total_cumulative_rankings = cumulative_rankings[-1]\n    \n    # Function to select a parent based on cumulative rankings\n    def select_parent():\n        pick = np.random.rand() * total_cumulative_rankings\n        return np.searchsorted(cumulative_rankings, pick)\n\n    # Ordered Crossover (OX) function\n    def ordered_crossover(parent1, parent2):\n        child = np.full(N_P, -1, dtype=int)  # -1 indicates unfilled gene\n        start, end = sorted(np.random.choice(N_P, 2, replace=False))\n        child[start:end + 1] = parent1[start:end + 1]\n        \n        # Fill the remaining positions with genes from parent2 that do not already appear in child\n        fill_position = (end + 1) % N_P\n        for gene in parent2:\n            if gene not in child:\n                child[fill_position] = gene\n                fill_position = (fill_position + 1) % N_P\n                if fill_position == start:\n                    break\n        return child\n    \n    # Permutation mutation: swap two cities\n    def swap_mutation(individual):\n        a, b = np.random.choice(N_P, 2, replace=False)\n        individual[a], individual[b] = individual[b], individual[a]\n        return individual\n    \n    # Creating new generation\n    for i in range(POP_SIZE):\n        # Parent selection\n        parent1_idx = select_parent()\n        parent2_idx = select_parent()\n        while parent1_idx == parent2_idx:\n            parent2_idx = select_parent()\n        \n        parent1 = individuals[parent1_idx]\n        parent2 = individuals[parent2_idx]\n        \n        # Crossover to produce a child\n        if np.random.rand() < 0.85:  # Crossover probability\n            child = ordered_crossover(parent1, parent2)\n        else:\n            child = np.copy(parent1)\n        \n        # Mutation to introduce variability\n        if np.random.rand() < 0.15:  # Mutation probability\n            child = swap_mutation(child)\n        \n        new_pops[i] = child\n    \n    return new_pops",
          "objective": 0.79111,
          "other_inf": null
     },
     {
          "algorithm": "parent1[i]: parent2[i] for i in range(start, end+1)}\n        reverse_mapping = {v: k for k, v in mapping.items()",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n\n    # Extract individuals and rankings from the population dictionary\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n    \n    # Function to perform roulette wheel selection based on rankings\n    def roulette_selection():\n        max_rank = np.max(rankings)\n        selection_probabilities = (max_rank - rankings + 1) / np.sum(max_rank - rankings + 1)\n        return np.random.choice(POP_SIZE, p=selection_probabilities)\n\n    # Function for partially-mapped crossover (PMX)\n    def pmx(parent1, parent2):\n        start, end = sorted(np.random.choice(N_P, 2, replace=False))\n        child = np.full(N_P, -1, dtype=int)\n        child[start:end+1] = parent1[start:end+1]\n        mapping = {parent1[i]: parent2[i] for i in range(start, end+1)}\n        reverse_mapping = {v: k for k, v in mapping.items()}\n        \n        for i in range(N_P):\n            if child[i] == -1:\n                city = parent2[i]\n                while city in mapping:\n                    city = mapping[city]\n                child[i] = city\n        \n        return child\n\n    # Simple inversion mutation\n    def inversion_mutation(individual):\n        start, end = sorted(np.random.choice(N_P, 2, replace=False))\n        individual[start:end+1] = individual[start:end+1][::-1]\n        return individual\n\n    # Array to hold the new population\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    \n    # Generate new population\n    for i in range(POP_SIZE):\n        # Select parents via roulette selection\n        parent1_index = roulette_selection()\n        parent2_index = roulette_selection()\n        while parent1_index == parent2_index:\n            parent2_index = roulette_selection()\n        \n        parent1 = individuals[parent1_index]\n        parent2 = individuals[parent2_index]\n        \n        # Perform crossover\n        child = pmx(parent1, parent2)\n        \n        # Possibly mutate the child\n        if np.random.rand() < 0.2:  # Mutation probability\n            child = inversion_mutation(child)\n        \n        new_pops[i] = child\n    \n    return new_pops",
          "objective": 0.78249,
          "other_inf": null
     },
     {
          "algorithm": "Edge recombination to create adjacency representation followed by absorbing mutation based on adjacent costs}\n    \n    individuals = pops['individuals']\n    rankings = pops['rankings']\n    \n    def edge_recombination(parent1, parent2):\n        # Build edge map from both parents\n        edge_map = {i: set() for i in range(N_P)",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n    \n    # {Edge recombination to create adjacency representation followed by absorbing mutation based on adjacent costs}\n    \n    individuals = pops['individuals']\n    rankings = pops['rankings']\n    \n    def edge_recombination(parent1, parent2):\n        # Build edge map from both parents\n        edge_map = {i: set() for i in range(N_P)}\n        for p in [parent1, parent2]:\n            for i in range(N_P):\n                left = p[(i - 1) % N_P]\n                right = p[(i + 1) % N_P]\n                edge_map[p[i]].update([left, right])\n        \n        # Start with the city with the fewest connections in the edge_map\n        start_city = min(edge_map, key=lambda k: len(edge_map[k]))\n        current_city = start_city\n        path = [current_city]\n        \n        while len(path) < N_P:\n            if edge_map[current_city]:\n                next_city = min(edge_map[current_city], key=lambda k: len(edge_map[k]))\n                edge_map[current_city].remove(next_city)\n            else:\n                remaining_cities = set(range(N_P)) - set(path)\n                next_city = remaining_cities.pop()\n                \n            for k in edge_map:\n                if current_city in edge_map[k]:\n                    edge_map[k].remove(current_city)\n            \n            path.append(next_city)\n            current_city = next_city\n        \n        return np.array(path, dtype=int)\n    \n    def absorb_mutation(individual):\n        # Mutation by absorbing a random city and injecting it to a new position\n        city_idx = np.random.choice(N_P)\n        city = individual[city_idx]\n        individual = np.delete(individual, city_idx)\n        new_pos = np.random.choice(N_P - 1)\n        individual = np.insert(individual, new_pos, city)\n        return individual\n    \n    def tournament_selection():\n        # Tournament selection based on rankings\n        k = 2\n        selected = np.random.choice(POP_SIZE, k, replace=False)\n        best_index = selected[np.argmin(rankings[selected])]\n        return individuals[best_index]\n    \n    # Create new population\n    new_pops = np.empty((POP_SIZE, N_P), dtype=int)\n    \n    for i in range(POP_SIZE):\n        # Select parents\n        parent1 = tournament_selection()\n        parent2 = tournament_selection()\n        \n        # Crossover\n        child = edge_recombination(parent1, parent2)\n        \n        # Mutation\n        if np.random.rand() < 0.1:  # Lower mutation rate\n            child = absorb_mutation(child)\n        \n        new_pops[i] = child\n        \n    return new_pops",
          "objective": 0.77327,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n\n    def edge_recombination(parent1, parent2):\n        from collections import defaultdict\n\n        # Create adjacency list from both parents\n        adjacency = defaultdict(set)\n        for i in range(N_P):\n            current, prev, next = parent1[i], parent1[i-1], parent1[(i+1) % N_P]\n            adjacency[current].update([prev, next])\n            current, prev, next = parent2[i], parent2[i-1], parent2[(i+1) % N_P]\n            adjacency[current].update([prev, next])\n\n        # Start with the first gene of one of the parents\n        child = [parent1[0]]\n        current = child[0]\n        \n        while len(child) < N_P:\n            if adjacency[current]:\n                next_node = min(adjacency[current], key=lambda x: len(adjacency[x]))  # select the node with fewest edges\n                adjacency[current].remove(next_node)\n                for key in adjacency:\n                    adjacency[key].discard(current)\n                current = next_node\n                child.append(current)\n            else:\n                remaining = set(range(N_P)) - set(child)\n                child.append(remaining.pop())   # fallback scenario\n\n        return np.array(child, dtype=np.int32)\n\n    def inversion_mutation(individual):\n        start, end = sorted(np.random.choice(range(N_P), 2, replace=False))\n        individual[start:end+1] = individual[start:end+1][::-1]\n        return individual\n\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n\n    # Tournament Selection\n    selected_indices = np.argsort(rankings)[:POP_SIZE // 2]\n    parents_pool = individuals[selected_indices]\n\n    for i in range(POP_SIZE):\n        # Selecting two random parents from the pool\n        parents = parents_pool[np.random.choice(len(parents_pool), 2, replace=False)]\n        child = edge_recombination(parents[0], parents[1])\n        \n        # Applying mutation with a probability of 20%\n        if np.random.rand() < 0.2:\n            child = inversion_mutation(child)\n        \n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.77319,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n\n    # Extracts tours and their associated rankings\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n\n    # Initialize the new population\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n\n    # Function to perform partially mapped crossover (PMX)\n    def pmx(parent1, parent2):\n        start, end = sorted(np.random.choice(N_P, 2, replace=False))\n        child = np.zeros(N_P, dtype=np.int32) - 1\n        child[start:end+1] = parent1[start:end+1]\n        for i in range(start, end + 1):\n            if parent2[i] not in child:\n                pointer = i\n                while start <= pointer and pointer <= end:\n                    pointer = np.where(parent2 == parent1[pointer])[0][0]\n                child[pointer] = parent2[i]\n        remaining = [x for x in parent2 if x not in child]\n        child[child == -1] = remaining\n        return child\n\n    # Function to perform an inversion mutation\n    def inversion_mutation(individual):\n        if np.random.rand() < 0.1:  # mutation probability\n            start, end = sorted(np.random.choice(N_P, 2, replace=False))\n            individual[start:end+1] = individual[start:end+1][::-1]\n        return individual\n\n    # Function to select parent based on wheel roulette selection method\n    def roulette_selection():\n        max_rank = np.max(rankings)\n        selection_probs = (max_rank + 1 - rankings) / np.sum(max_rank + 1 - rankings)\n        selected_index = np.random.choice(POP_SIZE, p=selection_probs)\n        return individuals[selected_index]\n\n    # Generate a new generation\n    for i in range(POP_SIZE):\n        # Select parents\n        parent1 = roulette_selection()\n        parent2 = roulette_selection()\n        # Generate new child\n        child = pmx(parent1, parent2)\n        # Mutate the child\n        child = inversion_mutation(child)\n        # Add to the new population\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.76988,
          "other_inf": null
     }
]