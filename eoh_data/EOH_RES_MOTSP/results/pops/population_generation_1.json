[
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n\n    # Sub-function to calculate the combined costs from D_lst for a given path\n    def calculate_path_cost(path):\n        total_cost = 0\n        for o in range(D_lst.shape[0]):\n            for i in range(N_P - 1):\n                total_cost += D_lst[o, path[i], path[i+1]]\n            total_cost += D_lst[o, path[-1], path[0]]  # last to first city\n        return total_cost\n\n    # Sub-function for pairwise tournament selection\n    def tournament_selection():\n        idx1, idx2 = np.random.choice(range(POP_SIZE), 2, replace=False)\n        if pops['rankings'][idx1] <= pops['rankings'][idx2]:\n            return pops['individuals'][idx1].copy()\n        else:\n            return pops['individuals'][idx2].copy()\n\n    # Sub-function for order 1 crossover\n    def order_crossover(parent1, parent2):\n        child = -np.ones(N_P, dtype=np.int32)\n        start, end = sorted(np.random.choice(range(N_P), 2, replace=False))\n        child[start:end+1] = parent1[start:end+1]\n        filled = set(parent1[start:end+1])\n        fill_pos = (end + 1) % N_P\n        for city in parent2:\n            if city not in filled:\n                child[fill_pos] = city\n                filled.add(city)\n                fill_pos = (fill_pos + 1) % N_P\n        return child\n\n    # Sub-function for swap mutation\n    def swap_mutation(individual, mutation_rate=0.1):\n        if np.random.rand() < mutation_rate:\n            swap_indices = np.random.choice(range(N_P), 2, replace=False)\n            individual[swap_indices[0]], individual[swap_indices[1]] = individual[swap_indices[1]], individual[swap_indices[0]]\n        return individual\n\n    # Generating new population\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        # Select parents\n        parent1 = tournament_selection()\n        parent2 = tournament_selection()\n        # Generate a child\n        child = order_crossover(parent1, parent2)\n        # Mutate the child\n        child = swap_mutation(child)\n        # Store the child\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.79869,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n    \n    def tournament_selection(ranking, k=3):\n        \"\"\" Selects an index using k-way tournament selection \"\"\"\n        selected_index = np.random.choice(len(ranking), k, replace=False)\n        return selected_index[np.argmin(ranking[selected_index])]\n    \n    def recombine(parent1, parent2):\n        \"\"\" Perform Ordered Crossover (OX) for recombination \"\"\"\n        start, end = sorted(np.random.choice(N_P, 2, replace=False))\n        child = np.full(N_P, -1, dtype=np.int32)\n        # Copy the slice from the first parent\n        child[start:end+1] = parent1[start:end+1]\n        # Fill the rest from the second parent\n        fill_pos = (end + 1) % N_P\n        for city in parent2:\n            if city not in child:\n                child[fill_pos] = city\n                fill_pos = (fill_pos + 1) % N_P\n        return child\n\n    def mutate(path):\n        \"\"\" Randomly swaps two cities in the path \"\"\"\n        a, b = np.random.choice(N_P, 2, replace=False)\n        path[a], path[b] = path[b], path[a]\n        return path\n    \n    # Current population individuals and their rankings\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n    \n    new_pops = np.full((POP_SIZE, N_P), -1, dtype=np.int32)\n    \n    # Generate new population\n    for i in range(POP_SIZE):\n        # Select parents via tournament selection\n        parent1 = individuals[tournament_selection(rankings)]\n        parent2 = individuals[tournament_selection(rankings)]\n        while np.array_equal(parent1, parent2):\n            parent2 = individuals[tournament_selection(rankings)]\n        \n        # Recombine parents to create a new individual\n        child = recombine(parent1, parent2)\n        \n        # Mutate the child with a certain probability\n        if np.random.rand() < 0.15:  # Example mutation probability\n            child = mutate(child)\n        \n        new_pops[i] = child\n    \n    return new_pops",
          "objective": 0.7962,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n\n    def edge_recombination(parent1, parent2):\n        from collections import defaultdict\n\n        # Create adjacency list from both parents\n        adjacency = defaultdict(set)\n        for i in range(N_P):\n            current, prev, next = parent1[i], parent1[i-1], parent1[(i+1) % N_P]\n            adjacency[current].update([prev, next])\n            current, prev, next = parent2[i], parent2[i-1], parent2[(i+1) % N_P]\n            adjacency[current].update([prev, next])\n\n        # Start with the first gene of one of the parents\n        child = [parent1[0]]\n        current = child[0]\n        \n        while len(child) < N_P:\n            if adjacency[current]:\n                next_node = min(adjacency[current], key=lambda x: len(adjacency[x]))  # select the node with fewest edges\n                adjacency[current].remove(next_node)\n                for key in adjacency:\n                    adjacency[key].discard(current)\n                current = next_node\n                child.append(current)\n            else:\n                remaining = set(range(N_P)) - set(child)\n                child.append(remaining.pop())   # fallback scenario\n\n        return np.array(child, dtype=np.int32)\n\n    def inversion_mutation(individual):\n        start, end = sorted(np.random.choice(range(N_P), 2, replace=False))\n        individual[start:end+1] = individual[start:end+1][::-1]\n        return individual\n\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n\n    # Tournament Selection\n    selected_indices = np.argsort(rankings)[:POP_SIZE // 2]\n    parents_pool = individuals[selected_indices]\n\n    for i in range(POP_SIZE):\n        # Selecting two random parents from the pool\n        parents = parents_pool[np.random.choice(len(parents_pool), 2, replace=False)]\n        child = edge_recombination(parents[0], parents[1])\n        \n        # Applying mutation with a probability of 20%\n        if np.random.rand() < 0.2:\n            child = inversion_mutation(child)\n        \n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.77319,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n\n    # Extracts tours and their associated rankings\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n\n    # Initialize the new population\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n\n    # Function to perform partially mapped crossover (PMX)\n    def pmx(parent1, parent2):\n        start, end = sorted(np.random.choice(N_P, 2, replace=False))\n        child = np.zeros(N_P, dtype=np.int32) - 1\n        child[start:end+1] = parent1[start:end+1]\n        for i in range(start, end + 1):\n            if parent2[i] not in child:\n                pointer = i\n                while start <= pointer and pointer <= end:\n                    pointer = np.where(parent2 == parent1[pointer])[0][0]\n                child[pointer] = parent2[i]\n        remaining = [x for x in parent2 if x not in child]\n        child[child == -1] = remaining\n        return child\n\n    # Function to perform an inversion mutation\n    def inversion_mutation(individual):\n        if np.random.rand() < 0.1:  # mutation probability\n            start, end = sorted(np.random.choice(N_P, 2, replace=False))\n            individual[start:end+1] = individual[start:end+1][::-1]\n        return individual\n\n    # Function to select parent based on wheel roulette selection method\n    def roulette_selection():\n        max_rank = np.max(rankings)\n        selection_probs = (max_rank + 1 - rankings) / np.sum(max_rank + 1 - rankings)\n        selected_index = np.random.choice(POP_SIZE, p=selection_probs)\n        return individuals[selected_index]\n\n    # Generate a new generation\n    for i in range(POP_SIZE):\n        # Select parents\n        parent1 = roulette_selection()\n        parent2 = roulette_selection()\n        # Generate new child\n        child = pmx(parent1, parent2)\n        # Mutate the child\n        child = inversion_mutation(child)\n        # Add to the new population\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.76988,
          "other_inf": null
     },
     {
          "algorithm": "A genetic-based algorithm that uses tournament selection, crossover, mutation and elitism to generate the next generation of the population for a multi-objective traveling salesman problem.",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    \"\"\"\n    {A genetic-based algorithm that uses tournament selection, crossover, mutation and elitism to generate the next generation of the population for a multi-objective traveling salesman problem.}\n    \n    :param pops: The current population structured as a dictionary with 'individuals' and 'rankings'.\n    :param D_lst: An array of cost matrices across multiple objectives.\n    :param POP_SIZE: The number of individuals in each population.\n    :param N_P: The number of cities to be visited.\n    :return: new_pops, a numpy.ndarray with shape (POP_SIZE, N_P).\n    \"\"\"\n    \n    import numpy as np\n\n    # Extract elements of the population dictionary\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n    \n    # Tournament Selection Helper Function\n    def tournament_selection(k=2):\n        \"\"\"Randomly select `k` individuals and return the best one based on rankings.\"\"\"\n        selected_indices = np.random.choice(POP_SIZE, k, replace=False)\n        best_index = selected_indices[np.argmin(rankings[selected_indices])]\n        return individuals[best_index]\n    \n    # Crossover Helper Function\n    def crossover(parent1, parent2):\n        \"\"\"Perform Order Crossover (OX) between two parent permutations.\"\"\"\n        start, end = sorted(np.random.choice(N_P, 2, replace=False))\n        child = [None]*N_P\n        child[start:end+1] = parent1[start:end+1]\n        p2_items = [item for item in parent2 if item not in child]\n        fill_positions = [i for i in range(N_P) if child[i] is None]\n        for i, pos in enumerate(fill_positions):\n            child[pos] = p2_items[i]\n        return child\n\n    # Mutation Helper Function\n    def mutate(individual, mutation_rate=0.2):\n        \"\"\"Perform a swap mutation on individual permutation with given mutation rate.\"\"\"\n        if np.random.rand() < mutation_rate:\n            swap_idx1, swap_idx2 = np.random.choice(N_P, 2, replace=False)\n            individual[swap_idx1], individual[swap_idx2] = individual[swap_idx2], individual[swap_idx1]\n        return individual\n\n    # Generate new population\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    \n    # Elitism: Keep the best individual\n    elite_idx = np.argmin(rankings)\n    new_pops[0] = individuals[elite_idx]\n    \n    for i in range(1, POP_SIZE):\n        parent1 = tournament_selection()\n        parent2 = tournament_selection()\n        child = crossover(parent1, parent2)\n        child = mutate(child)\n        new_pops[i] = child\n    \n    return new_pops",
          "objective": 0.76645,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n\n    def calculate_total_cost(individual, costs):\n        total_cost = 0\n        N_O, _, _ = costs.shape\n        for o in range(N_O):\n            for i in range(len(individual) - 1):\n                total_cost += costs[o, individual[i], individual[i+1]]\n            total_cost += costs[o, individual[-1], individual[0]]  # Complete the cycle\n        return total_cost\n\n    def tournament_select(pops, k=3):\n        selected_indices = np.random.choice(range(len(pops['rankings'])), k, replace=False)\n        selected_fitness = pops['rankings'][selected_indices]\n        winner_index = selected_indices[np.argmin(selected_fitness)]\n        return pops['individuals'][winner_index]\n\n    def crossover(parent1, parent2):\n        start, end = sorted(np.random.choice(range(N_P), 2, replace=False))\n        child = np.full(N_P, -1, dtype=np.int32)\n        child[start:end+1] = parent1[start:end+1]\n\n        available_positions = list(np.where(child == -1)[0])\n        for idx in available_positions:\n            value = parent2[np.where(np.isin(parent2, child, invert=True))[0][0]]\n            child[idx] = value\n        return child\n\n    def mutate(individual, mutation_rate=0.2):\n        if np.random.random() < mutation_rate:\n            i, j = np.random.choice(range(N_P), 2, replace=False)\n            individual[i], individual[j] = individual[j], individual[i]\n        return individual\n    \n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n\n    for i in range(POP_SIZE):\n        parent1 = tournament_select(pops)\n        parent2 = tournament_select(pops)\n        child = crossover(parent1, parent2)\n        child = mutate(child)\n        new_pops[i] = child\n        \n    return new_pops",
          "objective": 0.76189,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n    \n    # Extracts the individual and their rankings from the population dictionary\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n    \n    # Initialize array for storing the next generation.\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    \n    # Selecting individuals based on their inverse rankings probabilities\n    def select_parent():\n        probabilities = 1 / (1 + rankings - np.min(rankings))\n        probabilities /= np.sum(probabilities)\n        idx = np.random.choice(POP_SIZE, p=probabilities)\n        return individuals[idx].copy()\n    \n    # Shuffling elements in the selected path\n    def shuffle_mutation(path):\n        swap_times = np.random.randint(1, 5)  # Number of swaps to perform\n        for _ in range(swap_times):\n            swap_idx1, swap_idx2 = np.random.choice(N_P, 2, replace=False)\n            path[swap_idx1], path[swap_idx2] = path[swap_idx2], path[swap_idx1]\n        return path\n\n    # Greedily rebuild the path by adding cities based on least increase in selected objective\n    def greedy_crossover(parent1, parent2):\n        obj_idx = np.random.randint(len(D_lst))  # Select random objective\n        starting_city = np.random.choice(parent1)\n        remaining_cities = set(parent1)\n        remaining_cities.remove(starting_city)\n        path = [starting_city]\n        \n        # Build path greedily based on selected objective's costs\n        while remaining_cities:\n            last_city = path[-1]\n            next_city = min(remaining_cities, key=lambda x: D_lst[obj_idx][last_city][x])\n            path.append(next_city)\n            remaining_cities.remove(next_city)\n        \n        return np.array(path, dtype=np.int32)\n\n    # Generating the new generation\n    for i in range(POP_SIZE):\n        if np.random.rand() < 0.8:  # 80% chance to perform crossover and mutation\n            parent1 = select_parent()\n            parent2 = select_parent()\n            child = greedy_crossover(parent1, parent2)\n            if np.random.rand() < 0.15:  # 15% chance of mutation\n                child = shuffle_mutation(child)\n        else:  # 20% chance to forward parent directly maybe with mutation\n            child = select_parent()\n            if np.random.rand() < 0.15:\n                child = shuffle_mutation(child)\n        new_pops[i] = child\n    \n    return new_pops",
          "objective": 0.75327,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n\n    def crossover(parent1, parent2):\n        child = np.full(N_P, -1, dtype=np.int32)\n        start_idx, end_idx = sorted(np.random.choice(N_P, 2, replace=False))\n        child[start_idx:end_idx+1] = parent1[start_idx:end_idx+1]\n        fill_positions = np.where(child == -1)[0]\n        to_fill = [c for c in parent2 if c not in child[start_idx:end_idx+1]]\n        child[fill_positions] = to_fill\n        return child\n\n    def mutate(individual, mutation_rate=0.15):\n        if np.random.rand() < mutation_rate:\n            idx1, idx2 = np.random.choice(N_P, 2, replace=False)\n            individual[idx1], individual[idx2] = individual[idx2], individual[idx1]\n        return individual\n\n    # Extract current population and rankings\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n\n    # Tournament selection based on rankings\n    def tournament_select():\n        participants = np.random.choice(POP_SIZE, 4, replace=False)\n        selected = np.argmin(rankings[participants])\n        return individuals[participants[selected]]\n\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n\n    for i in range(POP_SIZE):\n        parent1 = tournament_select()\n        parent2 = tournament_select()\n        child = crossover(parent1, parent2)\n        child = mutate(child)\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.74982,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n\n    def tournament_selection():\n        contenders = np.random.randint(0, POP_SIZE, size=4)\n        winner = contenders[np.argmin(pops['rankings'][contenders])]\n        return pops['individuals'][winner].copy()\n\n    def crossover(parent1, parent2):\n        cross_point1, cross_point2 = np.sort(np.random.choice(N_P, size=2, replace=False))\n        child = np.empty(N_P, dtype=np.int32)\n        middle = parent1[cross_point1:cross_point2]\n        child[cross_point1:cross_point2] = middle\n        filled_positions = set(middle)\n        fill_index = 0\n        for city in parent2:\n            if city not in filled_positions:\n                if fill_index == cross_point1:\n                    fill_index = cross_point2\n                child[fill_index] = city\n                fill_index += 1\n        return child\n\n    def mutate(individual):\n        swap1, swap2 = np.random.choice(N_P, size=2, replace=False)\n        individual[swap1], individual[swap2] = individual[swap2], individual[swap1]\n        return individual\n\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    \n    for i in range(POP_SIZE):\n        if np.random.rand() < 0.9:  # Crossover probability\n            parent1 = tournament_selection()\n            parent2 = tournament_selection()\n            child = crossover(parent1, parent2)\n            if np.random.rand() < 0.1:  # Mutation probability\n                child = mutate(child)\n        else:\n            child = tournament_selection()\n            if np.random.rand() < 0.1:\n                child = mutate(child)\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.74757,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n    \n    # Path inversion mutation - inverts a segment of a tour\n    def path_inversion_mutation(ind):\n        idx1, idx2 = sorted(np.random.choice(N_P, 2, replace=False))\n        ind[idx1:idx2+1] = ind[idx1:idx2+1][::-1]\n        return ind\n\n    # Greedy Sub-tour Crossover - constructs a new tour by greedily choosing edges\n    def greedy_subtour_crossover(parent1, parent2):\n        child = [-1]*N_P\n        start = np.random.randint(N_P)\n        child[0] = start\n        used = set(child)\n        \n        for i in range(1, N_P):\n            last_city = child[i-1]\n            next_city = None\n            min_cost = float('inf')\n            \n            # Check next city from parent1\n            for j, city in enumerate(parent1):\n                if (city == last_city):\n                    next_index = (j + 1) % N_P\n                    if parent1[next_index] not in used and D_lst[0, last_city, parent1[next_index]] < min_cost:\n                        min_cost = D_lst[0, last_city, parent1[next_index]]\n                        next_city = parent1[next_index]\n                    break\n\n            # Check next city from parent2\n            for j, city in enumerate(parent2):\n                if (city == last_city):\n                    next_index = (j + 1) % N_P\n                    if parent2[next_index] not in used and D_lst[0, last_city, parent2[next_index]] < min_cost:\n                        min_cost = D_lst[0, last_city, parent2[next_index]]\n                        next_city = parent2[next_index]\n                    break\n            \n            if next_city is None:  # If still None, pick random\n                possible = list(set(range(N_P)) - used)\n                next_city = np.random.choice(possible)\n\n            child[i] = next_city\n            used.add(next_city)\n\n        return child\n    \n    new_pops = np.empty_like(individuals)\n   \n    # Elite selection: top performers directly go to next generation\n    elite_size = POP_SIZE // 5\n    elite_indices = np.argsort(rankings)[:elite_size]\n    new_pops[:elite_size] = individuals[elite_indices]\n\n    # Generate new population\n    for i in range(elite_size, POP_SIZE):\n        # Tournament selection\n        tournament_size = 4\n        tournament_indices = np.random.choice(POP_SIZE, tournament_size, replace=False)\n        best_index = tournament_indices[np.argmin(rankings[tournament_indices])]\n        \n        # Select second parent differently, ensuring diversity by random choice\n        second_parent_index = np.random.choice(POP_SIZE)\n        while second_parent_index == best_index:\n            second_parent_index = np.random.choice(POP_SIZE)\n\n        parent1 = individuals[best_index]\n        parent2 = individuals[second_parent_index]\n        \n        # Perform crossover\n        child = greedy_subtour_crossover(parent1, parent2)\n        \n        # Perform mutation with a certain probability\n        if np.random.rand() < 0.1:\n            child = path_inversion_mutation(child)\n        \n        new_pops[i] = child\n    \n    return new_pops",
          "objective": 0.73567,
          "other_inf": null
     }
]