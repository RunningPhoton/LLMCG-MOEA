[
     {
          "algorithm": "i: set() for i in range(N_P)}\n        for i in range(N_P):\n            next1 = (i + 1) % N_P\n            prev1 = (i - 1 + N_P) % N_P\n            index_in_2 = np.where(parent2 == parent1[i])[0][0]\n            next2 = (index_in_2 + 1) % N_P\n            prev2 = (index_in_2 - 1 + N_P) % N_P\n            edges[parent1[i]].update([parent1[next1], parent1[prev1], parent2[next2], parent2[prev2]])\n        \n        # Create child\n        child = [None] * N_P\n        current_node = np.random.choice(parent1)\n        child[0] = current_node\n        used_nodes = {current_node",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n    \n    individuals = pops['individuals']\n    rankings = pops['rankings']\n    \n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    \n    # Rank-based roulette wheel selection\n    def rank_based_selection():\n        probabilities = 1 / (rankings + 1)\n        probabilities /= probabilities.sum()\n        selected_index = np.random.choice(POP_SIZE, size=POP_SIZE, p=probabilities)\n        return individuals[selected_index]\n    \n    # Edge Recombination Crossover\n    def edge_recombination(parent1, parent2):\n        # Create edge map from parents\n        edges = {i: set() for i in range(N_P)}\n        for i in range(N_P):\n            next1 = (i + 1) % N_P\n            prev1 = (i - 1 + N_P) % N_P\n            index_in_2 = np.where(parent2 == parent1[i])[0][0]\n            next2 = (index_in_2 + 1) % N_P\n            prev2 = (index_in_2 - 1 + N_P) % N_P\n            edges[parent1[i]].update([parent1[next1], parent1[prev1], parent2[next2], parent2[prev2]])\n        \n        # Create child\n        child = [None] * N_P\n        current_node = np.random.choice(parent1)\n        child[0] = current_node\n        used_nodes = {current_node}\n        \n        for i in range(1, N_P):\n            for node in edges[current_node]:\n                edges[node].discard(current_node)\n            if edges[current_node]:\n                next_node = min(edges[current_node], key=lambda x: len(edges[x]))\n            else:\n                possible_nodes = [n for n in range(N_P) if n not in used_nodes]\n                next_node = np.random.choice(possible_nodes)\n            child[i] = next_node\n            current_node = next_node\n            used_nodes.add(current_node)\n        \n        return np.array(child, dtype=np.int32)\n\n    # Cycle crossover (CX2)\n    def cycle_crossover(parent1, parent2):\n        child = np.full(N_P, -1, dtype=np.int32)\n        start = 0\n        next_value = parent1[start]\n        child[start] = next_value\n        while True:\n            next_value = parent2[np.where(parent1 == next_value)[0][0]]\n            if next_value == child[start]:\n                break\n            child[np.where(parent1 == next_value)[0][0]] = next_value\n        child[child == -1] = parent2[child == -1]\n        return child\n\n    # Mutation: Reversing segments of the chromosome\n    def mutate(ind):\n        if np.random.rand() < 0.1:  # Mutation probability\n            start, end = np.sort(np.random.choice(N_P, 2, replace=False))\n            ind[start:end+1] = ind[start:end+1][::-1]\n        return ind\n    \n    selected_individuals = rank_based_selection()\n    \n    # Generate the new population using crossovers and mutations\n    for i in range(0, POP_SIZE, 2):\n        parent1, parent2 = selected_individuals[i], selected_individuals[(i + 1) % POP_SIZE]\n        # 50% chance to use either crossover\n        if np.random.rand() < 0.5:\n            new_pops[i] = edge_recombination(parent1, parent2)\n            if (i + 1) < POP_SIZE:\n                new_pops[i + 1] = edge_recombination(parent2, parent1)\n        else:\n            new_pops[i] = cycle_crossover(parent1, parent2)\n            if (i + 1) < POP_SIZE:\n                new_pops[i + 1] = cycle_crossover(parent2, parent1)\n        \n        # Applying mutation\n        new_pops[i] = mutate(new_pops[i])\n        if (i + 1) < POP_SIZE:\n            new_pops[i + 1] = mutate(new_pops[i + 1])\n    \n    return new_pops",
          "objective": 0.82889,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n    \n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    \n    individuals = pops['individuals']\n    rankings = pops['rankings']\n        \n    # Internal Function: Ranking-Scaled Fitness Proportionate Selection\n    def fitness_proportionate_selection():\n        max_rank = np.max(rankings)\n        adjusted_fitness = max_rank + 1 - rankings\n        probabilities = adjusted_fitness / np.sum(adjusted_fitness)\n        selected_indices = np.random.choice(POP_SIZE, size=POP_SIZE, p=probabilities)\n        return individuals[selected_indices]\n    \n    # Internal Function: Edge Recombination Crossover (ERX)\n    def edge_recombination_crossover(parent1, parent2):\n        from collections import defaultdict\n        adjacency = defaultdict(set)\n        \n        def add_edges(parent):\n            for i in range(N_P):\n                left = parent[i - 1]\n                right = parent[(i + 1) % N_P]\n                adjacency[parent[i]].update([left, right])\n        \n        add_edges(parent1)\n        add_edges(parent2)\n        \n        current = np.random.choice(parent1)\n        child = [current]\n        for _ in range(1, N_P):\n            if current in adjacency:\n                neighbors = list(adjacency[current])\n            else:\n                neighbors = []\n            for neighbor in neighbors:\n                adjacency[neighbor].remove(current)\n            current = neighbors[np.argmin([len(adjacency[n]) for n in neighbors])] if neighbors else np.random.choice(list(set(range(N_P)) - set(child)))\n            child.append(current)\n        \n        return np.array(child, dtype=np.int32)\n    \n    # Population selection through fitness proportionate selection\n    selected_individuals = fitness_proportionate_selection()\n    \n    # Generating new population\n    for i in range(POP_SIZE):\n        if np.random.rand() < 0.75:  # 75% crossover rate\n            idx1, idx2 = np.random.choice(POP_SIZE, 2, replace=False)\n            new_pops[i] = edge_recombination_crossover(selected_individuals[idx1], selected_individuals[idx2])\n        else:  # 25% clone with mutation\n            new_pops[i] = selected_individuals[i]\n            if np.random.rand() < 0.2:  # 20% mutation rate\n                a, b = np.random.choice(N_P, 2, replace=False)\n                new_pops[i][a], new_pops[i][b] = new_pops[i][b], new_pops[i][a]\n    \n    return new_pops",
          "objective": 0.82567,
          "other_inf": null
     },
     {
          "algorithm": "i: set() for i in range(N_P)",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n    \n    # Extract data from input population structure\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n    \n    # Initialize new population array\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    \n    # Edge Recombination crossover is used to preserve edge relationships\n    def edge_recombination_crossover(parent1, parent2):\n        # Build the edge map from both parents\n        edge_map = {i: set() for i in range(N_P)}\n        for p in [parent1, parent2]:\n            for i in range(N_P):\n                left = p[i - 1]\n                right = p[(i + 1) % N_P]\n                edge_map[p[i]].update([left, right])\n        \n        # Start the crossover process\n        current = np.random.choice(N_P)\n        child = [current]\n        used = set(child)\n        \n        for _ in range(1, N_P):\n            if current in edge_map:\n                # Remove the used node from other nodes' edge list\n                for node_set in edge_map.values():\n                    node_set.discard(current)\n                options = list(edge_map[current])\n                # Choose the next node with the fewest edges\n                if options:\n                    next_node = min(options, key=lambda x: len(edge_map[x]))\n                else:\n                    next_node = np.random.choice(list(set(range(N_P)) - used))\n            current = next_node\n            child.append(current)\n            used.add(current)\n        \n        return child\n\n    # Mutation: Swap two cities at random positions\n    def swap_mutation(ind):\n        idx1, idx2 = np.random.choice(N_P, 2, replace=False)\n        ind[idx1], ind[idx2] = ind[idx2], ind[idx1]\n        return ind\n    \n    # Selection by rank-based probability\n    def rank_based_selection():\n        probabilities = 1 / (rankings + 1)\n        probabilities /= np.sum(probabilities)\n        return individuals[np.random.choice(POP_SIZE, p=probabilities)]\n    \n    # Assemble new population\n    for i in range(POP_SIZE):\n        # Select parents\n        parent1 = rank_based_selection()\n        parent2 = rank_based_selection()\n        \n        # Crossover\n        child = edge_recombination_crossover(parent1, parent2)\n        \n        # Mutation \n        if np.random.rand() < 0.05:\n            child = swap_mutation(child)\n        \n        # Place child in new population\n        new_pops[i] = child\n    \n    return new_pops",
          "objective": 0.82343,
          "other_inf": null
     },
     {
          "algorithm": "",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n\n    # Edge Recombination Crossover (ERX) optimized for path representation\n    def edge_recombination(parent1, parent2):\n        edge_map = {}\n        for parent in (parent1, parent2):\n            for i, node in enumerate(parent):\n                neighbors = set([parent[(i - 1) % N_P], parent[(i + 1) % N_P]])\n                if node in edge_map:\n                    edge_map[node].update(neighbors)\n                else:\n                    edge_map[node] = neighbors\n        \n        current = np.random.choice(parent1)  # Start with a random node from parent1\n        child = [current]\n        for _ in range(1, N_P):\n            # Remove current node from edge_map\n            for edges in edge_map.values():\n                edges.discard(current)\n\n            if edge_map[current]:\n                # Choose next node with fewest edges\n                next_node = min(edge_map[current], key=lambda x: len(edge_map[x]))\n            else:\n                # Random choice from unvisited nodes\n                unvisited = [node for node in range(N_P) if node not in child]\n                next_node = np.random.choice(unvisited)\n            \n            child.append(next_node)\n            current = next_node    # Update current node to next node\n\n        return np.array(child, dtype=np.int32)\n\n    # Minimal disturbance mutation\n    def mutate(path):\n        path = np.copy(path)\n        for _ in range(2):  # Perform two swaps\n            i, j = np.random.choice(N_P, 2, replace=False)\n            path[i], path[j] = path[j], path[i]\n        return path\n\n    def tournament_selection(ranking, k=3):\n        selected_index = np.random.choice(len(ranking), k, replace=False)\n        return selected_index[np.argmin(ranking[selected_index])]\n\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n\n    new_pops = np.full((POP_SIZE, N_P), -1, dtype=np.int32)\n    \n    for i in range(POP_SIZE):\n        parent1 = individuals[tournament_selection(rankings)]\n        parent2 = individuals[tournament_selection(rankings)]\n        while np.array_equal(parent1, parent2):\n            parent2 = individuals[tournament_selection(rankings)]\n        \n        child = edge_recombination(parent1, parent2)\n        \n        if np.random.rand() < 0.1:  # Mutation probability\n            child = mutate(child)\n        \n        new_pops[i] = child\n    \n    return new_pops",
          "objective": 0.81199,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n    \n    # Initiate new generation population array with paths of cities\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    \n    # Get the individuals and corresponding rankings from the provided population dictionary\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n    \n    # Function internal to reverse sections of the array as mutation\n    def reverse_subsection(path):\n        path_copy = path.copy()\n        if N_P > 2:\n            left, right = sorted(np.random.choice(N_P, 2, replace=False))\n            path_copy[left:right+1] = path_copy[left:right+1][::-1]\n        return path_copy\n    \n    # Function internal to directly clone the best performing individuals with a chance of mutation\n    def elitist_preservation():\n        sorted_indices = np.argsort(rankings)\n        elite_count = POP_SIZE // 5  # Take top 20% as elite\n        for i in range(elite_count):\n            if np.random.rand() < 0.1:  # 10% mutation probability for elites\n                new_pops[i] = reverse_subsection(individuals[sorted_indices[i]])\n            else:\n                new_pops[i] = individuals[sorted_indices[i]]\n    \n    # Function internal to perform crossover using Partially Mapped Crossover (PMX)\n    def pmx(parent1, parent2):\n        child = np.empty(N_P, dtype=np.int32)\n        child.fill(-1)\n        start, end = sorted(np.random.choice(N_P, 2, replace=False))\n        child[start:end+1] = parent1[start:end+1]\n        for i in range(start, end + 1):\n            if parent2[i] not in child:\n                current_pos = i\n                while start <= current_pos and current_pos <= end:\n                    current_pos = np.where(parent2 == parent1[current_pos])[0][0]\n                child[current_pos] = parent2[i]\n        for i in range(N_P):\n            if child[i] == -1:\n                child[i] = parent2[i]\n        return child\n    \n    # Fill the rest of new generation with children produced through crossover and mutation\n    elitist_preservation()\n    for i in range(POP_SIZE // 5, POP_SIZE):\n        parent1_idx = np.random.choice(POP_SIZE)\n        parent2_idx = np.random.choice(POP_SIZE)\n        if np.random.rand() < 0.8:  # 80% crossover chance\n            new_pops[i] = pmx(individuals[parent1_idx], individuals[parent2_idx])\n        else:  # direct copying with mutation\n            new_pops[i] = reverse_subsection(individuals[parent1_idx])\n        # Mutation\n        if np.random.rand() < 0.15:\n            new_pops[i] = reverse_subsection(new_pops[i])\n        \n    return new_pops",
          "objective": 0.80467,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n\n    # Retrieve current population details\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n\n    # Prepare new population array\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    \n    # Sub-function to calculate route cost as fitness value\n    def route_cost(cost_matrices, route):\n        total_costs = np.zeros(cost_matrices.shape[0])\n        for i in range(len(route) - 1):\n            total_costs += cost_matrices[:, route[i], route[i + 1]]\n        # Adding cost from last city back to the first to complete the loop\n        total_costs += cost_matrices[:, route[-1], route[0]]\n        return np.mean(total_costs)\n    \n    # Modified crossover function: Ordered Crossover (OX)\n    def ordered_crossover(parent1, parent2):\n        start, end = sorted(np.random.choice(N_P, 2, replace=False))\n        child = [None] * N_P\n        middle_part = parent1[start:end + 1]\n        child[start:end + 1] = middle_part\n        filled_indices = set(middle_part)\n        current_index = (end + 1) % N_P\n        \n        for city in parent2:\n            if city not in filled_indices:\n                child[current_index] = city\n                filled_indices.add(city)\n                current_index = (current_index + 1) % N_P\n                \n        return child\n    \n    # Mutation function: Inversion Mutation\n    def inversion_mutation(route):\n        idx1, idx2 = sorted(np.random.choice(N_P, 2, replace=False))\n        route[idx1:idx2 + 1] = reversed(route[idx1:idx2 + 1])\n        return route\n    \n    # Proportional Selection based on rank\n    def rank_based_selection():\n        rank_inverse = 1 / (rankings + 1)\n        rank_proba = rank_inverse / np.sum(rank_inverse)\n        index = np.random.choice(POP_SIZE, p=rank_proba)\n        return individuals[index]\n    \n    # Create new generations/populations\n    for i in range(POP_SIZE):\n        # Selecting two parents randomly with rank-based selection\n        parent1, parent2 = rank_based_selection(), rank_based_selection()\n        \n        # Applying crossover and mutation\n        child = ordered_crossover(parent1, parent2)\n        if np.random.rand() < 0.1:  # Mutation probability\n            child = inversion_mutation(child)\n        \n        # Re-assuring all cities are present in the child\n        assert len(set(child)) == N_P, \"Child does not contain all cities exactly once.\"\n        \n        # Assigning generated offspring to new population\n        new_pops[i] = child\n    \n    return new_pops",
          "objective": 0.80402,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n    \n    # Rank-Based Selection: Select parents based on ranking directly, lower rank has higher probability\n    def rank_based_selection():\n        ranks_inv = 1 / (rankings + 1)\n        norm_ranks = ranks_inv / np.sum(ranks_inv)\n        return np.random.choice(POP_SIZE, p=norm_ranks)\n\n    # Ordered Crossover (OX): A crossover that creates a child by choosing a subset from one parent and preserving the order of cities from the other parent\n    def ordered_crossover(parent1, parent2):\n        start, end = sorted(np.random.choice(N_P, 2, replace=False))\n        middle_cities = parent1[start:end+1]\n        child = [-1] * N_P\n        child[start:end+1] = middle_cities\n        pos = (end + 1) % N_P\n        for city in parent2:\n            if city not in middle_cities:\n                child[pos] = city\n                pos = (pos + 1) % N_P\n        return child\n\n    # Swap Mutation: Swap two cities in the route\n    def swap_mutation(individual):\n        idx1, idx2 = np.random.choice(N_P, 2, replace=False)\n        individual[idx1], individual[idx2] = individual[idx2], individual[idx1]\n        return individual\n\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    \n    for i in range(POP_SIZE):\n        # Select parents\n        parent1_index = rank_based_selection()\n        parent2_index = rank_based_selection()\n        while parent1_index == parent2_index:\n            parent2_index = rank_based_selection()\n        \n        parent1 = individuals[parent1_index]\n        parent2 = individuals[parent2_index]\n        \n        # Crossover\n        child = ordered_crossover(parent1, parent2)\n        \n        # Mutation\n        if np.random.rand() < 0.15:\n            child = swap_mutation(child)\n        \n        new_pops[i] = child\n    \n    return new_pops",
          "objective": 0.79903,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n\n    # Sub-function to calculate the combined costs from D_lst for a given path\n    def calculate_path_cost(path):\n        total_cost = 0\n        for o in range(D_lst.shape[0]):\n            for i in range(N_P - 1):\n                total_cost += D_lst[o, path[i], path[i+1]]\n            total_cost += D_lst[o, path[-1], path[0]]  # last to first city\n        return total_cost\n\n    # Sub-function for pairwise tournament selection\n    def tournament_selection():\n        idx1, idx2 = np.random.choice(range(POP_SIZE), 2, replace=False)\n        if pops['rankings'][idx1] <= pops['rankings'][idx2]:\n            return pops['individuals'][idx1].copy()\n        else:\n            return pops['individuals'][idx2].copy()\n\n    # Sub-function for order 1 crossover\n    def order_crossover(parent1, parent2):\n        child = -np.ones(N_P, dtype=np.int32)\n        start, end = sorted(np.random.choice(range(N_P), 2, replace=False))\n        child[start:end+1] = parent1[start:end+1]\n        filled = set(parent1[start:end+1])\n        fill_pos = (end + 1) % N_P\n        for city in parent2:\n            if city not in filled:\n                child[fill_pos] = city\n                filled.add(city)\n                fill_pos = (fill_pos + 1) % N_P\n        return child\n\n    # Sub-function for swap mutation\n    def swap_mutation(individual, mutation_rate=0.1):\n        if np.random.rand() < mutation_rate:\n            swap_indices = np.random.choice(range(N_P), 2, replace=False)\n            individual[swap_indices[0]], individual[swap_indices[1]] = individual[swap_indices[1]], individual[swap_indices[0]]\n        return individual\n\n    # Generating new population\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        # Select parents\n        parent1 = tournament_selection()\n        parent2 = tournament_selection()\n        # Generate a child\n        child = order_crossover(parent1, parent2)\n        # Mutate the child\n        child = swap_mutation(child)\n        # Store the child\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.79869,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n    \n    def tournament_selection(ranking, k=3):\n        \"\"\" Selects an index using k-way tournament selection \"\"\"\n        selected_index = np.random.choice(len(ranking), k, replace=False)\n        return selected_index[np.argmin(ranking[selected_index])]\n    \n    def recombine(parent1, parent2):\n        \"\"\" Perform Ordered Crossover (OX) for recombination \"\"\"\n        start, end = sorted(np.random.choice(N_P, 2, replace=False))\n        child = np.full(N_P, -1, dtype=np.int32)\n        # Copy the slice from the first parent\n        child[start:end+1] = parent1[start:end+1]\n        # Fill the rest from the second parent\n        fill_pos = (end + 1) % N_P\n        for city in parent2:\n            if city not in child:\n                child[fill_pos] = city\n                fill_pos = (fill_pos + 1) % N_P\n        return child\n\n    def mutate(path):\n        \"\"\" Randomly swaps two cities in the path \"\"\"\n        a, b = np.random.choice(N_P, 2, replace=False)\n        path[a], path[b] = path[b], path[a]\n        return path\n    \n    # Current population individuals and their rankings\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n    \n    new_pops = np.full((POP_SIZE, N_P), -1, dtype=np.int32)\n    \n    # Generate new population\n    for i in range(POP_SIZE):\n        # Select parents via tournament selection\n        parent1 = individuals[tournament_selection(rankings)]\n        parent2 = individuals[tournament_selection(rankings)]\n        while np.array_equal(parent1, parent2):\n            parent2 = individuals[tournament_selection(rankings)]\n        \n        # Recombine parents to create a new individual\n        child = recombine(parent1, parent2)\n        \n        # Mutate the child with a certain probability\n        if np.random.rand() < 0.15:  # Example mutation probability\n            child = mutate(child)\n        \n        new_pops[i] = child\n    \n    return new_pops",
          "objective": 0.7962,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n\n    # Retrieve the current population and their rankings\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n    \n    # Initialize the new population array\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n\n    # Tournament Selection to pick candidates for crossover\n    def tournament_selection(k=3):\n        selected = []\n        for _ in range(POP_SIZE):\n            participants = np.random.choice(POP_SIZE, k, replace=False)\n            best_participant = min(participants, key=lambda idx: rankings[idx])\n            selected.append(best_participant)\n        return individuals[selected]\n\n    # Ordered Crossover (OX) to generate new offspring\n    def ordered_crossover(parent1, parent2):\n        start, end = sorted(np.random.choice(N_P, 2, replace=False))\n        child = [None]*N_P\n        middle = parent1[start:end+1]\n        child[start:end+1] = middle\n        filled_positions = set(middle)\n        \n        position = (end + 1) % N_P\n        for city in parent2:\n            if city not in filled_positions:\n                child[position] = city\n                filled_positions.add(city)\n                position = (position + 1) % N_P\n        \n        return np.array(child, dtype=np.int32)\n\n    # Simple Inversion Mutation (SIM)\n    def simple_inversion_mutation(ind):\n        start, end = sorted(np.random.choice(N_P, 2, replace=False))\n        ind[start:end+1] = ind[start:end+1][::-1]\n        return ind\n\n    # Select parents for the generation\n    selected_individuals = tournament_selection(k=5)\n\n    # Generate the new population\n    for i in range(0, POP_SIZE, 2):  # Process by pairs\n        if np.random.rand() < 0.8:  # 80% crossover rate\n            parent1, parent2 = selected_individuals[i], selected_individuals[(i + 1) % POP_SIZE]\n            new_pops[i] = ordered_crossover(parent1, parent2)\n            if (i + 1) < POP_SIZE:\n                new_pops[i + 1] = ordered_crossover(parent2, parent1)\n        else:\n            new_pops[i] = selected_individuals[i]\n            if (i + 1) < POP_SIZE:\n                new_pops[i + 1] = selected_individuals[i + 1]\n        \n        # Apply mutation\n        if np.random.rand() < 0.1:  # 10% mutation rate per individual\n            new_pops[i] = simple_inversion_mutation(new_pops[i])\n        if (i + 1) < POP_SIZE and np.random.rand() < 0.1:\n            new_pops[i + 1] = simple_inversion_mutation(new_pops[i + 1])\n\n    return new_pops",
          "objective": 0.79478,
          "other_inf": null
     }
]