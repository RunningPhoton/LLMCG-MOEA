[
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n    \n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    \n    individuals = pops['individuals']\n    rankings = pops['rankings']\n        \n    # Internal Function: Ranking-Scaled Fitness Proportionate Selection\n    def fitness_proportionate_selection():\n        max_rank = np.max(rankings)\n        adjusted_fitness = max_rank + 1 - rankings\n        probabilities = adjusted_fitness / np.sum(adjusted_fitness)\n        selected_indices = np.random.choice(POP_SIZE, size=POP_SIZE, p=probabilities)\n        return individuals[selected_indices]\n    \n    # Internal Function: Edge Recombination Crossover (ERX)\n    def edge_recombination_crossover(parent1, parent2):\n        from collections import defaultdict\n        adjacency = defaultdict(set)\n        \n        def add_edges(parent):\n            for i in range(N_P):\n                left = parent[i - 1]\n                right = parent[(i + 1) % N_P]\n                adjacency[parent[i]].update([left, right])\n        \n        add_edges(parent1)\n        add_edges(parent2)\n        \n        current = np.random.choice(parent1)\n        child = [current]\n        for _ in range(1, N_P):\n            if current in adjacency:\n                neighbors = list(adjacency[current])\n            else:\n                neighbors = []\n            for neighbor in neighbors:\n                adjacency[neighbor].remove(current)\n            current = neighbors[np.argmin([len(adjacency[n]) for n in neighbors])] if neighbors else np.random.choice(list(set(range(N_P)) - set(child)))\n            child.append(current)\n        \n        return np.array(child, dtype=np.int32)\n    \n    # Population selection through fitness proportionate selection\n    selected_individuals = fitness_proportionate_selection()\n    \n    # Generating new population\n    for i in range(POP_SIZE):\n        if np.random.rand() < 0.75:  # 75% crossover rate\n            idx1, idx2 = np.random.choice(POP_SIZE, 2, replace=False)\n            new_pops[i] = edge_recombination_crossover(selected_individuals[idx1], selected_individuals[idx2])\n        else:  # 25% clone with mutation\n            new_pops[i] = selected_individuals[i]\n            if np.random.rand() < 0.2:  # 20% mutation rate\n                a, b = np.random.choice(N_P, 2, replace=False)\n                new_pops[i][a], new_pops[i][b] = new_pops[i][b], new_pops[i][a]\n    \n    return new_pops",
          "objective": 0.82567,
          "other_inf": null
     },
     {
          "algorithm": "i: set() for i in range(N_P)",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n    \n    # Extract data from input population structure\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n    \n    # Initialize new population array\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    \n    # Edge Recombination crossover is used to preserve edge relationships\n    def edge_recombination_crossover(parent1, parent2):\n        # Build the edge map from both parents\n        edge_map = {i: set() for i in range(N_P)}\n        for p in [parent1, parent2]:\n            for i in range(N_P):\n                left = p[i - 1]\n                right = p[(i + 1) % N_P]\n                edge_map[p[i]].update([left, right])\n        \n        # Start the crossover process\n        current = np.random.choice(N_P)\n        child = [current]\n        used = set(child)\n        \n        for _ in range(1, N_P):\n            if current in edge_map:\n                # Remove the used node from other nodes' edge list\n                for node_set in edge_map.values():\n                    node_set.discard(current)\n                options = list(edge_map[current])\n                # Choose the next node with the fewest edges\n                if options:\n                    next_node = min(options, key=lambda x: len(edge_map[x]))\n                else:\n                    next_node = np.random.choice(list(set(range(N_P)) - used))\n            current = next_node\n            child.append(current)\n            used.add(current)\n        \n        return child\n\n    # Mutation: Swap two cities at random positions\n    def swap_mutation(ind):\n        idx1, idx2 = np.random.choice(N_P, 2, replace=False)\n        ind[idx1], ind[idx2] = ind[idx2], ind[idx1]\n        return ind\n    \n    # Selection by rank-based probability\n    def rank_based_selection():\n        probabilities = 1 / (rankings + 1)\n        probabilities /= np.sum(probabilities)\n        return individuals[np.random.choice(POP_SIZE, p=probabilities)]\n    \n    # Assemble new population\n    for i in range(POP_SIZE):\n        # Select parents\n        parent1 = rank_based_selection()\n        parent2 = rank_based_selection()\n        \n        # Crossover\n        child = edge_recombination_crossover(parent1, parent2)\n        \n        # Mutation \n        if np.random.rand() < 0.05:\n            child = swap_mutation(child)\n        \n        # Place child in new population\n        new_pops[i] = child\n    \n    return new_pops",
          "objective": 0.82343,
          "other_inf": null
     },
     {
          "algorithm": "",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n\n    # Edge Recombination Crossover (ERX) optimized for path representation\n    def edge_recombination(parent1, parent2):\n        edge_map = {}\n        for parent in (parent1, parent2):\n            for i, node in enumerate(parent):\n                neighbors = set([parent[(i - 1) % N_P], parent[(i + 1) % N_P]])\n                if node in edge_map:\n                    edge_map[node].update(neighbors)\n                else:\n                    edge_map[node] = neighbors\n        \n        current = np.random.choice(parent1)  # Start with a random node from parent1\n        child = [current]\n        for _ in range(1, N_P):\n            # Remove current node from edge_map\n            for edges in edge_map.values():\n                edges.discard(current)\n\n            if edge_map[current]:\n                # Choose next node with fewest edges\n                next_node = min(edge_map[current], key=lambda x: len(edge_map[x]))\n            else:\n                # Random choice from unvisited nodes\n                unvisited = [node for node in range(N_P) if node not in child]\n                next_node = np.random.choice(unvisited)\n            \n            child.append(next_node)\n            current = next_node    # Update current node to next node\n\n        return np.array(child, dtype=np.int32)\n\n    # Minimal disturbance mutation\n    def mutate(path):\n        path = np.copy(path)\n        for _ in range(2):  # Perform two swaps\n            i, j = np.random.choice(N_P, 2, replace=False)\n            path[i], path[j] = path[j], path[i]\n        return path\n\n    def tournament_selection(ranking, k=3):\n        selected_index = np.random.choice(len(ranking), k, replace=False)\n        return selected_index[np.argmin(ranking[selected_index])]\n\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n\n    new_pops = np.full((POP_SIZE, N_P), -1, dtype=np.int32)\n    \n    for i in range(POP_SIZE):\n        parent1 = individuals[tournament_selection(rankings)]\n        parent2 = individuals[tournament_selection(rankings)]\n        while np.array_equal(parent1, parent2):\n            parent2 = individuals[tournament_selection(rankings)]\n        \n        child = edge_recombination(parent1, parent2)\n        \n        if np.random.rand() < 0.1:  # Mutation probability\n            child = mutate(child)\n        \n        new_pops[i] = child\n    \n    return new_pops",
          "objective": 0.81199,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n    \n    # Initiate new generation population array with paths of cities\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n    \n    # Get the individuals and corresponding rankings from the provided population dictionary\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n    \n    # Function internal to reverse sections of the array as mutation\n    def reverse_subsection(path):\n        path_copy = path.copy()\n        if N_P > 2:\n            left, right = sorted(np.random.choice(N_P, 2, replace=False))\n            path_copy[left:right+1] = path_copy[left:right+1][::-1]\n        return path_copy\n    \n    # Function internal to directly clone the best performing individuals with a chance of mutation\n    def elitist_preservation():\n        sorted_indices = np.argsort(rankings)\n        elite_count = POP_SIZE // 5  # Take top 20% as elite\n        for i in range(elite_count):\n            if np.random.rand() < 0.1:  # 10% mutation probability for elites\n                new_pops[i] = reverse_subsection(individuals[sorted_indices[i]])\n            else:\n                new_pops[i] = individuals[sorted_indices[i]]\n    \n    # Function internal to perform crossover using Partially Mapped Crossover (PMX)\n    def pmx(parent1, parent2):\n        child = np.empty(N_P, dtype=np.int32)\n        child.fill(-1)\n        start, end = sorted(np.random.choice(N_P, 2, replace=False))\n        child[start:end+1] = parent1[start:end+1]\n        for i in range(start, end + 1):\n            if parent2[i] not in child:\n                current_pos = i\n                while start <= current_pos and current_pos <= end:\n                    current_pos = np.where(parent2 == parent1[current_pos])[0][0]\n                child[current_pos] = parent2[i]\n        for i in range(N_P):\n            if child[i] == -1:\n                child[i] = parent2[i]\n        return child\n    \n    # Fill the rest of new generation with children produced through crossover and mutation\n    elitist_preservation()\n    for i in range(POP_SIZE // 5, POP_SIZE):\n        parent1_idx = np.random.choice(POP_SIZE)\n        parent2_idx = np.random.choice(POP_SIZE)\n        if np.random.rand() < 0.8:  # 80% crossover chance\n            new_pops[i] = pmx(individuals[parent1_idx], individuals[parent2_idx])\n        else:  # direct copying with mutation\n            new_pops[i] = reverse_subsection(individuals[parent1_idx])\n        # Mutation\n        if np.random.rand() < 0.15:\n            new_pops[i] = reverse_subsection(new_pops[i])\n        \n    return new_pops",
          "objective": 0.80467,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n    \n    # Rank-Based Selection: Select parents based on ranking directly, lower rank has higher probability\n    def rank_based_selection():\n        ranks_inv = 1 / (rankings + 1)\n        norm_ranks = ranks_inv / np.sum(ranks_inv)\n        return np.random.choice(POP_SIZE, p=norm_ranks)\n\n    # Ordered Crossover (OX): A crossover that creates a child by choosing a subset from one parent and preserving the order of cities from the other parent\n    def ordered_crossover(parent1, parent2):\n        start, end = sorted(np.random.choice(N_P, 2, replace=False))\n        middle_cities = parent1[start:end+1]\n        child = [-1] * N_P\n        child[start:end+1] = middle_cities\n        pos = (end + 1) % N_P\n        for city in parent2:\n            if city not in middle_cities:\n                child[pos] = city\n                pos = (pos + 1) % N_P\n        return child\n\n    # Swap Mutation: Swap two cities in the route\n    def swap_mutation(individual):\n        idx1, idx2 = np.random.choice(N_P, 2, replace=False)\n        individual[idx1], individual[idx2] = individual[idx2], individual[idx1]\n        return individual\n\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    \n    for i in range(POP_SIZE):\n        # Select parents\n        parent1_index = rank_based_selection()\n        parent2_index = rank_based_selection()\n        while parent1_index == parent2_index:\n            parent2_index = rank_based_selection()\n        \n        parent1 = individuals[parent1_index]\n        parent2 = individuals[parent2_index]\n        \n        # Crossover\n        child = ordered_crossover(parent1, parent2)\n        \n        # Mutation\n        if np.random.rand() < 0.15:\n            child = swap_mutation(child)\n        \n        new_pops[i] = child\n    \n    return new_pops",
          "objective": 0.79903,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n\n    # Sub-function to calculate the combined costs from D_lst for a given path\n    def calculate_path_cost(path):\n        total_cost = 0\n        for o in range(D_lst.shape[0]):\n            for i in range(N_P - 1):\n                total_cost += D_lst[o, path[i], path[i+1]]\n            total_cost += D_lst[o, path[-1], path[0]]  # last to first city\n        return total_cost\n\n    # Sub-function for pairwise tournament selection\n    def tournament_selection():\n        idx1, idx2 = np.random.choice(range(POP_SIZE), 2, replace=False)\n        if pops['rankings'][idx1] <= pops['rankings'][idx2]:\n            return pops['individuals'][idx1].copy()\n        else:\n            return pops['individuals'][idx2].copy()\n\n    # Sub-function for order 1 crossover\n    def order_crossover(parent1, parent2):\n        child = -np.ones(N_P, dtype=np.int32)\n        start, end = sorted(np.random.choice(range(N_P), 2, replace=False))\n        child[start:end+1] = parent1[start:end+1]\n        filled = set(parent1[start:end+1])\n        fill_pos = (end + 1) % N_P\n        for city in parent2:\n            if city not in filled:\n                child[fill_pos] = city\n                filled.add(city)\n                fill_pos = (fill_pos + 1) % N_P\n        return child\n\n    # Sub-function for swap mutation\n    def swap_mutation(individual, mutation_rate=0.1):\n        if np.random.rand() < mutation_rate:\n            swap_indices = np.random.choice(range(N_P), 2, replace=False)\n            individual[swap_indices[0]], individual[swap_indices[1]] = individual[swap_indices[1]], individual[swap_indices[0]]\n        return individual\n\n    # Generating new population\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n    for i in range(POP_SIZE):\n        # Select parents\n        parent1 = tournament_selection()\n        parent2 = tournament_selection()\n        # Generate a child\n        child = order_crossover(parent1, parent2)\n        # Mutate the child\n        child = swap_mutation(child)\n        # Store the child\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.79869,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n    \n    def tournament_selection(ranking, k=3):\n        \"\"\" Selects an index using k-way tournament selection \"\"\"\n        selected_index = np.random.choice(len(ranking), k, replace=False)\n        return selected_index[np.argmin(ranking[selected_index])]\n    \n    def recombine(parent1, parent2):\n        \"\"\" Perform Ordered Crossover (OX) for recombination \"\"\"\n        start, end = sorted(np.random.choice(N_P, 2, replace=False))\n        child = np.full(N_P, -1, dtype=np.int32)\n        # Copy the slice from the first parent\n        child[start:end+1] = parent1[start:end+1]\n        # Fill the rest from the second parent\n        fill_pos = (end + 1) % N_P\n        for city in parent2:\n            if city not in child:\n                child[fill_pos] = city\n                fill_pos = (fill_pos + 1) % N_P\n        return child\n\n    def mutate(path):\n        \"\"\" Randomly swaps two cities in the path \"\"\"\n        a, b = np.random.choice(N_P, 2, replace=False)\n        path[a], path[b] = path[b], path[a]\n        return path\n    \n    # Current population individuals and their rankings\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n    \n    new_pops = np.full((POP_SIZE, N_P), -1, dtype=np.int32)\n    \n    # Generate new population\n    for i in range(POP_SIZE):\n        # Select parents via tournament selection\n        parent1 = individuals[tournament_selection(rankings)]\n        parent2 = individuals[tournament_selection(rankings)]\n        while np.array_equal(parent1, parent2):\n            parent2 = individuals[tournament_selection(rankings)]\n        \n        # Recombine parents to create a new individual\n        child = recombine(parent1, parent2)\n        \n        # Mutate the child with a certain probability\n        if np.random.rand() < 0.15:  # Example mutation probability\n            child = mutate(child)\n        \n        new_pops[i] = child\n    \n    return new_pops",
          "objective": 0.7962,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n\n    # Retrieve the current population and their rankings\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n    \n    # Initialize the new population array\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n\n    # Tournament Selection to pick candidates for crossover\n    def tournament_selection(k=3):\n        selected = []\n        for _ in range(POP_SIZE):\n            participants = np.random.choice(POP_SIZE, k, replace=False)\n            best_participant = min(participants, key=lambda idx: rankings[idx])\n            selected.append(best_participant)\n        return individuals[selected]\n\n    # Ordered Crossover (OX) to generate new offspring\n    def ordered_crossover(parent1, parent2):\n        start, end = sorted(np.random.choice(N_P, 2, replace=False))\n        child = [None]*N_P\n        middle = parent1[start:end+1]\n        child[start:end+1] = middle\n        filled_positions = set(middle)\n        \n        position = (end + 1) % N_P\n        for city in parent2:\n            if city not in filled_positions:\n                child[position] = city\n                filled_positions.add(city)\n                position = (position + 1) % N_P\n        \n        return np.array(child, dtype=np.int32)\n\n    # Simple Inversion Mutation (SIM)\n    def simple_inversion_mutation(ind):\n        start, end = sorted(np.random.choice(N_P, 2, replace=False))\n        ind[start:end+1] = ind[start:end+1][::-1]\n        return ind\n\n    # Select parents for the generation\n    selected_individuals = tournament_selection(k=5)\n\n    # Generate the new population\n    for i in range(0, POP_SIZE, 2):  # Process by pairs\n        if np.random.rand() < 0.8:  # 80% crossover rate\n            parent1, parent2 = selected_individuals[i], selected_individuals[(i + 1) % POP_SIZE]\n            new_pops[i] = ordered_crossover(parent1, parent2)\n            if (i + 1) < POP_SIZE:\n                new_pops[i + 1] = ordered_crossover(parent2, parent1)\n        else:\n            new_pops[i] = selected_individuals[i]\n            if (i + 1) < POP_SIZE:\n                new_pops[i + 1] = selected_individuals[i + 1]\n        \n        # Apply mutation\n        if np.random.rand() < 0.1:  # 10% mutation rate per individual\n            new_pops[i] = simple_inversion_mutation(new_pops[i])\n        if (i + 1) < POP_SIZE and np.random.rand() < 0.1:\n            new_pops[i + 1] = simple_inversion_mutation(new_pops[i + 1])\n\n    return new_pops",
          "objective": 0.79478,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n\n    # Retrieve current population and their rankings\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n\n    # Initialize the new population array\n    new_pops = np.zeros((POP_SIZE, N_P), dtype=np.int32)\n\n    # Define a function for Generating random paths\n    def generate_random_path():\n        path = np.arange(N_P)\n        np.random.shuffle(path)\n        return path\n\n    # Define a crossover function: Ordered Crossover (OX)\n    def ordered_crossover(parent1, parent2):\n        child = np.full(N_P, -1, dtype=np.int32)\n        start, end = sorted(np.random.choice(N_P, size=2, replace=False))\n        child[start:end+1] = parent1[start:end+1]\n        filled = set(child[start:end+1])\n        pos = (end + 1) % N_P\n        for city in parent2:\n            if city not in filled:\n                child[pos] = city\n                pos = (pos + 1) % N_P\n                if pos == start:\n                    break\n        return child\n\n    # Define mutation function: Scramble Mutation\n    def scramble_mutation(path):\n        path_copy = path.copy()\n        start, end = sorted(np.random.choice(N_P, size=2, replace=False))\n        np.random.shuffle(path_copy[start:end+1])\n        return path_copy\n\n    # Tournament selection to choose better individuals for reproduction\n    def tournament_selection(k=3):\n        selected_indices = np.random.choice(POP_SIZE, size=k, replace=False)\n        selected = sorted(selected_indices, key=lambda indx: rankings[indx])[0]  # Select the best one from the group\n        return individuals[selected]\n\n    # Construct the new population\n    elite_size = max(1, POP_SIZE // 20)  # Reserve 5% of population slots for elitism\n    elite_indices = np.argsort(rankings)[:elite_size]\n    for i in range(elite_size):\n        new_pops[i] = individuals[elite_indices[i]]  # Copy elite members directly\n\n    # Rest population filled by crossover and mutation\n    for i in range(elite_size, POP_SIZE):\n        parent1 = tournament_selection()\n        parent2 = tournament_selection()\n        if np.random.rand() < 0.9:  # High probability of crossover\n            child = ordered_crossover(parent1, parent2)\n        else:\n            child = generate_random_path()  # Generate new random path occasionally\n        if np.random.rand() < 0.2:\n            child = scramble_mutation(child)\n        new_pops[i] = child\n    \n    return new_pops",
          "objective": 0.79116,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, D_lst, POP_SIZE, N_P):\n    import numpy as np\n    \n    # Accessing individuals and their rankings from the population dictionary\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n    \n    # Initialize new population array\n    new_pops = np.empty((POP_SIZE, N_P), dtype=np.int32)\n\n    # Compute cumulative rankings for selection pressure: higher ranked individuals are more likely to reproduce\n    cumulative_rankings = np.cumsum(1 / (rankings + 1))\n    total_cumulative_rankings = cumulative_rankings[-1]\n    \n    # Function to select a parent based on cumulative rankings\n    def select_parent():\n        pick = np.random.rand() * total_cumulative_rankings\n        return np.searchsorted(cumulative_rankings, pick)\n\n    # Ordered Crossover (OX) function\n    def ordered_crossover(parent1, parent2):\n        child = np.full(N_P, -1, dtype=int)  # -1 indicates unfilled gene\n        start, end = sorted(np.random.choice(N_P, 2, replace=False))\n        child[start:end + 1] = parent1[start:end + 1]\n        \n        # Fill the remaining positions with genes from parent2 that do not already appear in child\n        fill_position = (end + 1) % N_P\n        for gene in parent2:\n            if gene not in child:\n                child[fill_position] = gene\n                fill_position = (fill_position + 1) % N_P\n                if fill_position == start:\n                    break\n        return child\n    \n    # Permutation mutation: swap two cities\n    def swap_mutation(individual):\n        a, b = np.random.choice(N_P, 2, replace=False)\n        individual[a], individual[b] = individual[b], individual[a]\n        return individual\n    \n    # Creating new generation\n    for i in range(POP_SIZE):\n        # Parent selection\n        parent1_idx = select_parent()\n        parent2_idx = select_parent()\n        while parent1_idx == parent2_idx:\n            parent2_idx = select_parent()\n        \n        parent1 = individuals[parent1_idx]\n        parent2 = individuals[parent2_idx]\n        \n        # Crossover to produce a child\n        if np.random.rand() < 0.85:  # Crossover probability\n            child = ordered_crossover(parent1, parent2)\n        else:\n            child = np.copy(parent1)\n        \n        # Mutation to introduce variability\n        if np.random.rand() < 0.15:  # Mutation probability\n            child = swap_mutation(child)\n        \n        new_pops[i] = child\n    \n    return new_pops",
          "objective": 0.79111,
          "other_inf": null
     }
]