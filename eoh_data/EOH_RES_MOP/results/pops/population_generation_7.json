[
     {
          "algorithm": "```",
          "code": "def next_generation(pops, search_trajectory, xlb, xub, POP_SIZE, N_P, current_gen, max_gen):\n    import numpy as np\n\n    def sine_wave_mutation(individual, lb, ub, base_rate, gen_progress):\n        \"\"\"Mutation based on sine wave modulation for dynamic mutation strength.\"\"\"\n        mutation_strength = base_rate * (0.5 * np.sin(2 * np.pi * gen_progress) + 0.5)\n        mutant = np.copy(individual)\n        for i in range(len(mutant)):\n            if np.random.random() < mutation_strength:\n                mutation = np.random.uniform(-1, 1) * (ub[i] - lb[i]) * 0.1\n                mutant[i] = np.clip(mutant[i] + mutation, lb[i], ub[i])\n        return mutant\n\n    def tournament_selection(population, rankings):\n        \"\"\"Select two parents using binary tournament selection.\"\"\"\n        candidates_idx = np.random.choice(len(population), size=4, replace=False)\n        candidates_rankings = rankings[candidates_idx]\n        winners_idx = candidates_idx[np.argsort(candidates_rankings)[:2]]\n        return population[winners_idx[0]], population[winners_idx[1]]\n\n    def single_point_crossover(parent1, parent2):\n        \"\"\"Performs a single-point crossover.\"\"\"\n        crossover_point = np.random.randint(1, len(parent1) - 1)\n        child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        return child\n\n    base_mutation_rate = 0.3\n    generation_progress = current_gen / max_gen\n\n    new_pops = np.zeros_like(pops['individuals'])\n\n    for i in range(POP_SIZE):\n        parent1, parent2 = tournament_selection(pops['individuals'], pops['rankings'])\n        child = single_point_crossover(parent1, parent2)\n        child = sine_wave_mutation(child, xlb, xub, base_mutation_rate, generation_progress)\n        new_pops[i] = child\n\n    return new_pops",
          "objective": 0.20138,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, search_trajectory, xlb, xub, POP_SIZE, N_P, current_gen, max_gen):\n    import numpy as np\n    \n    def adaptive_cross_mutate(individuals, rankings, lb, ub):\n        # Configure parameters for cross mutation\n        k = current_gen / max_gen   # Normalized generation count\n        P_cross = 0.2 + 0.7 * k     # Probability of crossover increases over generations\n        P_mutate = 0.7 - 0.6 * k    # Probability of mutation decreases over generations\n        sigma = 0.1 * (1 - k)       # Mutation step size diminishes\n\n        # Declare a new population container\n        new_population = np.zeros_like(individuals)\n\n        elite_idx = np.argmin(rankings)  # Assume best individual has minimum ranking\n        elite_individual = individuals[elite_idx]  # Best performant individual\n\n        for i, ind in enumerate(individuals):\n            # Select parent for crossover, minimize the chance of choosing itself\n            while True:\n                candidate_idx = np.random.randint(0, POP_SIZE)\n                if candidate_idx != i:\n                    break\n            parent = individuals[candidate_idx]\n\n            # Crossover operation\n            mask = np.random.rand(N_P) < P_cross\n            offspring = np.where(mask, ind, parent)\n\n            # Mutation operation\n            mutate = np.random.rand(N_P) < P_mutate\n            mutations = np.random.normal(0, sigma, N_P)\n            offspring = np.where(mutate, offspring + mutations, offspring)\n\n            # Ensure the offspring remains within bounds\n            new_population[i] = np.clip(offspring, lb, ub)\n\n        return new_population\n\n    new_pops = adaptive_cross_mutate(pops['individuals'], pops['rankings'], xlb, xub)\n    return new_pops",
          "objective": -0.46197,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, search_trajectory, xlb, xub, POP_SIZE, N_P, current_gen, max_gen):\n    import numpy as np\n\n    # Use differential evolution-based crossover combined with a self-adaptive mutation strategy\n    \n    def differential_mutation(individuals, f=0.8):\n        \"\"\" Mutation operation in Differential Evolution. \"\"\"\n        mutated = np.zeros_like(individuals)\n        num_individuals = len(individuals)\n        for i in range(num_individuals):\n            idxs = np.random.choice(num_individuals, 3, replace=False)\n            a, b, c = individuals[idxs[0]], individuals[idxs[1]], individuals[idxs[2]]\n            mutated[i] = a + f * (b - c)\n        return mutated\n\n    def self_adaptive_mutation(individuals, tau=1.0):\n        \"\"\" Apply mutation influenced by the current generation. \"\"\"\n        mutation_strength = np.exp(-tau * current_gen / max_gen)\n        for i in range(len(individuals)):\n            for j in range(N_P):\n                if np.random.rand() < 0.1:  # mutation probability\n                    individuals[i, j] += mutation_strength * np.random.randn()\n                    individuals[i, j] = np.clip(individuals[i, j], xlb[j], xub[j])\n        return individuals\n    \n    def elite_preservation(strongest, elite_size):\n        \"\"\" Preserve the best solutions \"\"\"\n        return strongest[:elite_size]\n\n    # Parameters\n    elite_size = POP_SIZE // 5  # 20% of the population size\n    \n    # Preserve elites directly to the new population\n    elites = elite_preservation(pops['individuals'], elite_size)\n\n    # Apply differential mutation to generate donors\n    donors = differential_mutation(pops['individuals'])\n\n    # Recombine (crossover) with existing population\n    recombined = np.where(np.random.rand(POP_SIZE, N_P) < 0.5, pops['individuals'], donors)\n\n    # Mutation for diversity\n    new_individuals = self_adaptive_mutation(recombined)\n\n    # Elitism: Combine elite individuals with mutants\n    new_pops = np.vstack([elites, new_individuals[elite_size:]])\n\n    # Ensure population size remains constant\n    np.random.shuffle(new_pops)  # Shuffle to mix elites with new individuals\n\n    return new_pops",
          "objective": -0.59999,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, search_trajectory, xlb, xub, POP_SIZE, N_P, current_gen, max_gen):\n    import numpy as np\n\n    def simulated_binary_crossover(parent1, parent2, eta=10):\n        child1, child2 = np.copy(parent1), np.copy(parent2)\n        for i in range(N_P):\n            if np.random.rand() <= 0.9:  # Crossover probability\n                # Simulate binary crossover\n                y1, y2 = sorted([parent1[i], parent2[i]])\n                rand = np.random.rand()\n                beta = (2. * rand) ** (1. / (eta + 1.)) if rand <= 0.5 else (1. / (2. * (1. - rand))) ** (1. / (eta + 1.))\n                child1[i] = 0.5 * ((1 + beta) * y1 + (1 - beta) * y2)\n                child2[i] = 0.5 * ((1 - beta) * y1 + (1 + beta) * y2)\n                # Ensure bounds\n                child1[i] = np.clip(child1[i], xlb[i], xub[i])\n                child2[i] = np.clip(child2[i], xlb[i], xub[i])\n        return child1, child2\n\n    def diversity_mutation(individual, rate=0.1):\n        mutant = np.copy(individual)\n        for i in range(N_P):\n            if np.random.rand() < rate:\n                # Apply mutation\n                mutant[i] += np.random.randn() * (xub[i] - xlb[i]) * 0.1\n                mutant[i] = np.clip(mutant[i], xlb[i], xub[i])\n        return mutant\n\n    new_pops = np.zeros_like(pops['individuals'])\n    num_crossover = int(POP_SIZE * 0.9)  # 90% of population via crossover\n\n    # Crossover to generate new offspring\n    for i in range(0, num_crossover, 2):\n        p1, p2 = np.random.choice(POP_SIZE, 2, replace=False)\n        parent1, parent2 = pops['individuals'][p1], pops['individuals'][p2]\n        child1, child2 = simulated_binary_crossover(parent1, parent2)\n        new_pops[i] = child1\n        if i + 1 < num_crossover:\n            new_pops[i + 1] = child2\n    \n    # Remaining population from mutation\n    for i in range(num_crossover, POP_SIZE):\n        p = np.random.randint(0, POP_SIZE)\n        parent = pops['individuals'][p]\n        new_pops[i] = diversity_mutation(parent)\n\n    return new_pops",
          "objective": -2.16228,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, search_trajectory, xlb, xub, POP_SIZE, N_P, current_gen, max_gen):\n    import numpy as np\n    \n    def tournament_selection(individuals, rankings, selection_size):\n        \"\"\" Select individuals based on a tournament selection process. \"\"\"\n        tournament_results = np.empty((selection_size, N_P))\n        for i in range(selection_size):\n            contenders = np.random.choice(len(individuals), 3, replace=False)\n            winner = contenders[np.argmin(rankings[contenders])]\n            tournament_results[i] = individuals[winner]\n        return tournament_results\n    \n    def gaussian_mutation(individuals, mutation_rate, mutation_scale):\n        \"\"\" Apply Gaussian mutation based on a predefined rate and scale. \"\"\"\n        num_mutations = int(mutation_rate * len(individuals) * N_P)\n        for _ in range(num_mutations):\n            ind = np.random.randint(len(individuals))\n            gene = np.random.randint(N_P)\n            individuals[ind, gene] += np.random.randn() * mutation_scale\n            individuals[ind, gene] = np.clip(individuals[ind, gene], xlb[gene], xub[gene])\n        return individuals\n    \n    def simple_crossover(parents, num_offspring):\n        \"\"\" Perform a simple one-point crossover. \"\"\"\n        offspring = np.empty((num_offspring, N_P))\n        for i in range(num_offspring):\n            p1, p2 = np.random.choice(len(parents), 2, replace=False)\n            point = np.random.randint(1, N_P)\n            offspring[i, :point] = parents[p1, :point]\n            offspring[i, point:] = parents[p2, point:]\n        return offspring\n    \n    elite_count = int(POP_SIZE * 0.2)\n    elites = pops['individuals'][:elite_count]\n    \n    selected_for_crossover = tournament_selection(pops['individuals'], pops['rankings'], POP_SIZE - elite_count)\n    offsprings = simple_crossover(selected_for_crossover, POP_SIZE - elite_count)\n    \n    mutated_offsprings = gaussian_mutation(offsprings, mutation_rate=0.05, mutation_scale=0.1 * (1 - current_gen/max_gen))\n    \n    new_pops = np.vstack([elites, mutated_offsprings])\n    np.random.shuffle(new_pops)\n    \n    return new_pops",
          "objective": -2.35929,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, search_trajectory, xlb, xub, POP_SIZE, N_P, current_gen, max_gen):\n    import numpy as np\n\n    # Novel reproduction function: Quantum-inspired crossover with adaptive mutation\n    def quantum_inspired_crossover(individuals, rankings, lb, ub):\n        CR = 0.1 + 0.9 * (current_gen / max_gen)  # Crossover Probability\n        F = 0.5 + 0.5 * np.cos(np.pi * current_gen / max_gen)  # Differential Weight\n        best_idx = np.argmin(rankings)\n        best_individual = individuals[best_idx]\n\n        mutated_population = np.zeros_like(individuals)\n        for i, individual in enumerate(individuals):\n            indices = np.random.choice(POP_SIZE, 3, replace=False)\n            if i in indices:\n                indices = (indices + 1) % POP_SIZE  # to avoid self-inclusion\n            a, b, c = individuals[indices]\n            quantum_prob = np.random.rand()\n            if quantum_prob < 0.5:\n                mutant = a + F * (b - c)\n            else:\n                mutant = best_individual + F * (b - c)\n            crossover = np.random.rand(N_P) < CR\n            offspring = np.where(crossover, mutant, individual)\n            mutated_population[i] = np.clip(offspring, lb, ub)\n        \n        return mutated_population\n\n    new_pops = quantum_inspired_crossover(pops['individuals'], pops['rankings'], xlb, xub)\n    return new_pops",
          "objective": -2.51367,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, search_trajectory, xlb, xub, POP_SIZE, N_P, current_gen, max_gen):\n    import numpy as np\n    \n    def differential_evolution(parents, F=0.8):\n        \"\"\"Generates a new individual using Differential Evolution strategy.\"\"\"\n        indices = np.random.choice(len(parents), 3, replace=False)\n        x1, x2, x3 = parents[indices]\n        mutant = np.clip(x1 + F * (x2 - x3), xlb, xub)\n        return mutant\n\n    def adaptive_crossover(target, mutant, CR=0.5):\n        \"\"\"Performs adaptive crossover between target and mutant.\"\"\"\n        trial = np.where(np.random.rand(N_P) < CR, mutant, target)\n        return trial\n    \n    # Parameters for adaptation\n    CR = 0.1 + 0.5 * (current_gen / max_gen)\n    F = 0.5 + 0.4 * (current_gen / max_gen)\n\n    # Form new population\n    new_pops = np.zeros_like(pops['individuals'])\n    sorted_indices = np.argsort(pops['rankings'])  # Sort based on ranking\n    sorted_population = pops['individuals'][sorted_indices]\n    \n    for i in range(POP_SIZE):\n        mutant = differential_evolution(sorted_population, F)\n        new_pops[i] = adaptive_crossover(pops['individuals'][i], mutant, CR)\n    \n    return new_pops",
          "objective": -3.7183,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, search_trajectory, xlb, xub, POP_SIZE, N_P, current_gen, max_gen):\n    import numpy as np\n\n    # (Combining differential evolution with dynamic adaptive mutation and historical best-reference crossover)\n    def adaptive_differential_evolution(individuals, rankings, lb, ub):\n        CR = 0.1 + 0.8 * (current_gen / max_gen)  # Crossover Probability\n        F = 0.5 + 0.5 * np.sin(np.pi * current_gen / max_gen)  # Differential Weight\n        best_idx = np.argmin(rankings)\n        best_individual = individuals[best_idx]\n\n        mutated_population = np.zeros_like(individuals)\n        for i, individual in enumerate(individuals):\n            indices = np.random.choice(POP_SIZE, 3, replace=False)\n            if i in indices:\n                indices = (indices + 1) % POP_SIZE  # to avoid self-inclusion\n            a, b, c = individuals[indices]\n            mutant = best_individual + F * (b - c)\n            crossover = np.random.rand(N_P) < CR\n            offspring = np.where(crossover, mutant, individual)\n            mutated_population[i] = np.clip(offspring, lb, ub)\n        \n        return mutated_population\n\n    new_pops = adaptive_differential_evolution(pops['individuals'], pops['rankings'], xlb, xub)\n    return new_pops",
          "objective": -5.16416,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, search_trajectory, xlb, xub, POP_SIZE, N_P, current_gen, max_gen):\n    import numpy as np\n\n    # Adaptive mutation that factors in generational distance\n    def focused_mutate(individual, top_performer, mutation_scale=0.3):\n        # Weight more towards top performers as generations go by\n        beta = np.random.normal(0, 1, size=individual.shape)\n        weight = np.exp(-current_gen / max_gen)\n        mutation_vector = mutation_scale * (top_performer - individual) * weight + beta * (1 - weight)\n        return individual + mutation_vector\n\n    # Biased crossover giving preference to better-ranked individuals\n    def biased_crossover(parent1, parent2, rank1, rank2):\n        # Higher chance to pick characteristics from better-ranked parent\n        p = rank1 / (rank1 + rank2) if rank1 + rank2 != 0 else 0.5\n        crossover_mask = np.random.rand(N_P) < p\n        offspring = np.where(crossover_mask, parent1, parent2)\n        return offspring\n\n    # Initialize new population array\n    new_pops = np.zeros((POP_SIZE, N_P))\n\n    # Ensure there are previous individuals to sample from\n    history_available = search_trajectory['individuals'] is not None and len(search_trajectory['individuals']) > 0\n\n    for i in range(POP_SIZE):\n        idx1, idx2 = np.random.randint(0, POP_SIZE, size=2)\n        parent1 = pops['individuals'][idx1]\n        parent2 = pops['individuals'][idx2]\n        rank1 = pops['rankings'][idx1]\n        rank2 = pops['rankings'][idx2]\n\n        if np.random.rand() < 0.5:\n            # Perform biased crossover\n            new_pops[i] = biased_crossover(parent1, parent2, rank1, rank2)\n        else:\n            # Perform focused mutation based on the best available individual or a historical point\n            if history_available and np.random.rand() < 0.5:\n                history_idx = np.random.choice(len(search_trajectory['individuals']))\n                ref_individual = search_trajectory['individuals'][history_idx]\n            else:\n                ref_individual = pops['individuals'][np.argmin(pops['rankings'])]\n\n            new_pops[i] = focused_mutate(parent1, ref_individual)\n\n        # Clip to stay within bounds\n        new_pops[i] = np.clip(new_pops[i], xlb, xub)\n\n    return new_pops",
          "objective": -5.63161,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, search_trajectory, xlb, xub, POP_SIZE, N_P, current_gen, max_gen):\n    import numpy as np\n    \n    # A new reproduction function using linear combination model with elitist learning and random mutation enhancement\n    def blended_crossover_mutant(individuals, rankings, lb, ub):\n        CR = 0.2 + 0.6 * (current_gen / max_gen)  # Dynamic Crossover probability\n        F = 0.3 + 0.4 * np.cos(np.pi * current_gen / max_gen)  # Dynamic Mutation Factor\n        elite_individual = individuals[np.argmin(rankings)]\n        \n        blend_population = np.zeros_like(individuals)\n        for i in range(POP_SIZE):\n            idx1, idx2, idx3 = np.random.choice(POP_SIZE, 3, replace=False)\n            base, add1, add2 = individuals[[idx1, idx2, idx3]]\n            \n            # Blend the individuals\n            mutant = base + F * (add1 - add2) + 0.05 * (elite_individual - base)  # Mutation with elite direction\n            \n            # Apply Crossover\n            crossover = np.random.rand(N_P) < CR\n            offspring = np.where(crossover, mutant, individuals[i])\n            \n            # Apply mutation again with a small probability\n            mutation_mask = np.random.rand(N_P) < 0.05\n            additive_mutation = np.random.uniform(-0.1, 0.1, size=N_P)\n            offspring = np.where(mutation_mask, offspring + additive_mutation, offspring)\n            \n            # Ensure the offspring are within bounds\n            offspring = np.clip(offspring, lb, ub)\n            \n            blend_population[i] = offspring\n            \n        return blend_population\n    \n    new_pops = blended_crossover_mutant(pops['individuals'], pops['rankings'], xlb, xub)\n    return new_pops",
          "objective": -5.9756,
          "other_inf": null
     }
]