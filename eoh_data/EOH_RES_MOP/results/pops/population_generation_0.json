[
     {
          "algorithm": "```",
          "code": "def next_generation(pops, search_trajectory, xlb, xub, POP_SIZE, N_P, current_gen, max_gen):\n    import numpy as np\n\n    def uniform_mutation(individual, lb, ub, mutation_rate):\n        \"\"\"Mutates individual vector elements using a uniform random distribution.\"\"\"\n        mutant = np.copy(individual)\n        for i in range(len(mutant)):\n            if np.random.random() < mutation_rate:\n                mutant[i] = np.random.uniform(lb[i], ub[i])\n        return mutant\n\n    def crossover(parent1, parent2, crossover_rate):\n        \"\"\"Performs uniform crossover between two parents.\"\"\"\n        child = np.copy(parent1)\n        for i in range(len(child)):\n            if np.random.random() < crossover_rate:\n                child[i] = parent2[i]\n        return child\n\n    def select_parents(population):\n        \"\"\"Select parents for crossover using tournament selection.\"\"\"\n        # Tournament size is fixed to 2 for simplicity\n        idx1, idx2 = np.random.randint(0, len(population), 2)\n        if pops['rankings'][idx1] < pops['rankings'][idx2]:\n            parent1 = population[idx1]\n        else:\n            parent1 = population[idx2]\n\n        idx3, idx4 = np.random.randint(0, len(population), 2)\n        if pops['rankings'][idx3] < pops['rankings'][idx4]:\n            parent2 = population[idx3]\n        else:\n            parent2 = population[idx4]\n        \n        return parent1, parent2\n\n    mutation_rate = 0.1 + 0.9 * (current_gen / max_gen)  # Increase mutation rate over time\n    crossover_rate = 0.9 - 0.7 * (current_gen / max_gen)  # Decrease crossover rate over time\n\n    new_pops = np.zeros_like(pops['individuals'])\n\n    # Generate new population\n    for i in range(POP_SIZE):\n        parent1, parent2 = select_parents(pops['individuals'])\n        child = crossover(parent1, parent2, crossover_rate)\n        child = uniform_mutation(child, xlb, xub, mutation_rate)\n        new_pops[i] = child\n\n    return new_pops",
          "objective": -7.52235,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, search_trajectory, xlb, xub, POP_SIZE, N_P, current_gen, max_gen):\n    import numpy as np\n    \n    def mutate(individual, mutation_rate=0.1):\n        perturbation_scale = (xub - xlb) * mutation_rate * (1 - (current_gen/max_gen)**2)\n        return individual + np.random.uniform(-perturbation_scale, perturbation_scale, size=individual.shape)\n\n    def crossover(parent1, parent2):\n        alpha = np.random.uniform(0, 1, size=parent1.shape)\n        return alpha * parent1 + (1 - alpha) * parent2\n    \n    def select_parents(population):\n        indices = np.arange(len(population))\n        selected_indices = np.random.choice(indices, 2, replace=False)\n        return population[selected_indices[0]], population[selected_indices[1]]\n\n    def generate_new_individual():\n        if np.random.random() < 0.5:\n            parent1, parent2 = select_parents(pops['individuals'])\n            child = crossover(parent1, parent2)\n        else:\n            elite_individual = pops['individuals'][0]  # Elite selection: take the best one\n            child = mutate(elite_individual)\n        return np.clip(child, xlb, xub)\n\n    new_pops = np.array([generate_new_individual() for _ in range(POP_SIZE)])\n    return new_pops",
          "objective": -19.48152,
          "other_inf": null
     },
     {
          "algorithm": "A novel reproduction function that utilizes adaptive mutation based on historical search trajectories and differential evolution strategies to generate the next population.",
          "code": "def next_generation(pops, search_trajectory, xlb, xub, POP_SIZE, N_P, current_gen, max_gen):\n    import numpy as np\n\n    def adaptive_mutation(individual, gen):\n        mutation_rate = 0.1 + (0.9 * gen / max_gen)  # Increase mutation rate over generations\n        mutation_vector = np.random.uniform(-1, 1, size=N_P) * (xub - xlb) * mutation_rate\n        new_individual = individual + mutation_vector\n        new_individual = np.clip(new_individual, xlb, xub)  # Ensure bounds are respected\n        return new_individual\n\n    def differential_evolution(individuals):\n        new_population = np.empty_like(individuals)\n        for i in range(len(individuals)):\n            idxs = [idx for idx in range(len(individuals)) if idx != i]\n            a, b, c = np.random.choice(idxs, 3, replace=False)\n            mutant = individuals[a] + 0.8 * (individuals[b] - individuals[c])\n            mutant = np.clip(mutant, xlb, xub)\n            cross_points = np.random.rand(N_P) < 0.7\n            trial = np.where(cross_points, mutant, individuals[i])\n            new_population[i] = trial\n        return new_population\n\n    if current_gen < max_gen // 2:\n        # Use adaptive mutation in the first half of the generations\n        new_pops = np.array([adaptive_mutation(ind, current_gen) for ind in pops['individuals']])\n    else:\n        # Use differential evolution in the second half of the generations\n        new_pops = differential_evolution(pops['individuals'])\n\n    return new_pops",
          "objective": -26.75627,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, search_trajectory, xlb, xub, POP_SIZE, N_P, current_gen, max_gen):\n    import numpy as np\n\n    def adaptive_mutation(individuals, xlb, xub, factor=0.5):\n        # Adaptive mutation based on current generation\n        scale = factor * (1 - (current_gen / max_gen)) * (xub - xlb)\n        mutation_strength = np.random.normal(0, scale)\n        new_individuals = individuals + mutation_strength\n        return np.clip(new_individuals, xlb, xub)\n\n    def crossover(parent1, parent2):\n        # Uniform crossover between two parents\n        child = np.where(np.random.rand(N_P) < 0.5, parent1, parent2)\n        return child\n\n    def tournament_selection(pops, tournament_size=3):\n        # Select parents via tournament selection\n        indices = np.random.randint(0, POP_SIZE, tournament_size)\n        selected_index = indices[np.argmin(pops['rankings'][indices])]\n        return pops['individuals'][selected_index]\n\n    # Extract current individuals and rankings\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n    \n    # Initialize new population array\n    new_pops = np.empty((POP_SIZE, N_P))\n\n    # Generate new population\n    for i in range(POP_SIZE):\n        # Select parents for crossover\n        parent1 = tournament_selection(pops)\n        parent2 = tournament_selection(pops)\n\n        # Perform crossover\n        child = crossover(parent1, parent2)\n\n        # Adaptive mutation\n        child = adaptive_mutation(child, xlb, xub)\n\n        # Store in new population\n        new_pops[i] = child\n\n    # Return new population\n    return new_pops",
          "objective": -29.0405,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, search_trajectory, xlb, xub, POP_SIZE, N_P, current_gen, max_gen):\n    import numpy as np\n\n    def mutate(individual):\n        mutation_strength = 0.1 * (1 - current_gen / max_gen)\n        mutation_vector = np.random.randn(N_P) * mutation_strength\n        new_individual = individual + mutation_vector\n        new_individual = np.clip(new_individual, xlb, xub)\n        return new_individual\n\n    def generate_new_individuals(old_individuals):\n        N = old_individuals.shape[0]\n        new_individuals = np.empty_like(old_individuals)\n        for i in range(N):\n            partner_index = np.random.randint(0, N)\n            new_individual = (old_individuals[i] + old_individuals[partner_index]) / 2\n            new_individuals[i] = mutate(new_individual)\n        return new_individuals\n\n    new_pops = np.array(pops['individuals'])\n    if current_gen < max_gen // 2:\n        # Exploration phase\n        top_performers = new_pops[:POP_SIZE // 2, :]\n        new_individuals = generate_new_individuals(top_performers)\n        new_pops[POP_SIZE // 2:, :] = new_individuals\n    else:\n        # Exploitation phase\n        if search_trajectory['individuals'] is not None:\n            historical_best = search_trajectory['individuals'][np.argmin(search_trajectory['rankings'])]\n            new_individuals = generate_new_individuals(new_pops)\n            new_pops = new_individuals\n            new_pops[0, :] = historical_best  # ensure best found solution is carried over\n        else:\n            new_individuals = generate_new_individuals(new_pops)\n            new_pops = new_individuals\n\n    return new_pops",
          "objective": -30.34334,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, search_trajectory, xlb, xub, POP_SIZE, N_P, current_gen, max_gen):\n    import numpy as np\n\n    def get_weights(current_gen, max_gen, Sigma_base=0.1):\n        \"\"\" Returns weights decreasing linearly with generations \"\"\"\n        t = current_gen / max_gen\n        # Return a weight to modulate step size\n        return Sigma_base * (1 - t)\n    \n    def directional_perturbation(individuals, rankings, top_k, sigma):\n        \"\"\" Perturb top k individuals in the direction of their own, scaled by rankings \"\"\"\n        new_individuals = np.copy(individuals)\n        order_indices = np.argsort(rankings)\n        top_indices = order_indices[:top_k]\n        for idx in top_indices:\n            direction = np.random.normal(0, 1, N_P)\n            direction /= np.linalg.norm(direction)  # Normalize direction vector\n            new_individuals[idx] += sigma * direction * (1/(rankings[idx]+1))\n            new_individuals[idx] = np.clip(new_individuals[idx], xlb, xub)\n        return new_individuals\n    \n    def blend_crossover(parents, num_offspring):\n        \"\"\" Generate offspring by blending parent pairs \"\"\"\n        offspring = np.empty((num_offspring, N_P))\n        for i in range(num_offspring):\n            p1, p2 = np.random.choice(len(parents), 2, replace=False)\n            alpha = np.random.uniform(0, 1)\n            offspring[i] = alpha * parents[p1] + (1 - alpha) * parents[p2]\n            offspring[i] = np.clip(offspring[i], xlb, xub)\n        return offspring\n    \n    current_individuals = pops['individuals']\n    current_rankings = pops['rankings']\n    sigma = get_weights(current_gen, max_gen)\n    top_k = int(POP_SIZE * 0.2)  # Use top 20% for perturbation\n    \n    # Use directional perturbation and blend crossover\n    perturbed_individuals = directional_perturbation(current_individuals, current_rankings, top_k, sigma)\n    offspring = blend_crossover(current_individuals, POP_SIZE - top_k)\n    \n    # Merge perturbed individuals and new offspring to create new population\n    new_pops = np.vstack([perturbed_individuals[:top_k], offspring])\n    np.random.shuffle(new_pops)  # Shuffle to avoid any bias in selection\n\n    return new_pops",
          "objective": -39.58119,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, search_trajectory, xlb, xub, POP_SIZE, N_P, current_gen, max_gen):\n    import numpy as np\n    \n    def softmax(x):\n        e_x = np.exp(x - np.max(x))\n        return e_x / e_x.sum(axis=0)\n    \n    def generate_offspring(parents, lb, ub):\n        offspring = np.empty(parents.shape)\n        for i in range(parents.shape[0]):\n            alpha = np.random.uniform(-0.5, 1.5, size=parents.shape[1])\n            if i % 2 == 0:\n                p1, p2 = np.random.choice(len(parents), 2, replace=False)\n                offspring[i] = parents[p1] + alpha * (parents[p2] - parents[p1])\n            else:\n                p1 = np.random.randint(len(parents))\n                mutation_factor = np.random.normal(0, 1, size=parents.shape[1])\n                offspring[i] = parents[p1] + mutation_factor\n            \n            offspring[i] = np.clip(offspring[i], lb, ub)\n        return offspring\n    \n    def select_individuals_by_fitness(individuals, fitness, num_select):\n        probs = softmax(-fitness)  # maximizing the problem (smaller values better)\n        selected_idx = np.random.choice(a=len(individuals), size=num_select, replace=False, p=probs)\n        return individuals[selected_idx]\n    \n    # Extracting parameters\n    individuals = pops['individuals']\n    rankings = pops['rankings']\n    \n    # Elite preservation strategy\n    elite_fraction = 0.1\n    num_elites = max(1, int(POP_SIZE * elite_fraction))\n    elite_individuals = individuals[:num_elites]\n    \n    # Generate offspring\n    offspring = generate_offspring(individuals, xlb, xub)\n    \n    # Combine elite and offspring\n    combined_population = np.vstack([elite_individuals, offspring])\n    \n    # Fitness evaluation placeholder: reusing rankings as proxy\n    combined_fitness = np.hstack([rankings[:num_elites], np.full(len(offspring), np.max(rankings))])\n    \n    # Select individuals to form new population\n    new_pops = select_individuals_by_fitness(combined_population, combined_fitness, POP_SIZE)\n    \n    return new_pops",
          "objective": -45.05653,
          "other_inf": null
     },
     {
          "algorithm": "A novel reproduction function that utilizes historical search trajectories and adaptive mutation based on the generation count to generate a new population, aiming to explore and exploit the search space effectively.",
          "code": "def next_generation(pops, search_trajectory, xlb, xub, POP_SIZE, N_P, current_gen, max_gen):\n    import numpy as np\n    \n    def adaptive_mutation(individual, gen, max_gen, xlb, xub):\n        # Adaptive mutation rate based on the progress of generations\n        mutation_rate = 0.1 + (0.5 - 0.1) * (1 - gen / max_gen)\n        mutation_scale = (xub - xlb) * mutation_rate\n        mutation = np.random.normal(0, mutation_scale, size=individual.shape)\n        new_individual = np.clip(individual + mutation, xlb, xub)\n        return new_individual\n\n    def crossover(parent1, parent2):\n        # Uniform crossover\n        mask = np.random.rand(N_P) < 0.5\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    new_pops = np.empty_like(pops['individuals'])\n    \n    # Generate new population\n    for i in range(POP_SIZE):\n        # Select parents\n        if i < POP_SIZE - 1:\n            parent1, parent2 = pops['individuals'][i], pops['individuals'][i + 1]\n        else:\n            parent1, parent2 = pops['individuals'][i], pops['individuals'][0]\n        \n        # Crossover and mutation\n        child = crossover(parent1, parent2)\n        child = adaptive_mutation(child, current_gen, max_gen, xlb, xub)\n        new_pops[i] = child\n    \n    return new_pops",
          "objective": -48.62308,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, search_trajectory, xlb, xub, POP_SIZE, N_P, current_gen, max_gen):\n    import numpy as np\n\n    def adaptive_mutation(individuals, rate):\n        \"\"\" Mutate individuals based on an adaptive rate. \"\"\"\n        mutations = np.random.rand(*individuals.shape) < rate\n        mutation_scale = np.random.rand(*individuals.shape) * (xub - xlb) * 0.1\n        mutated_individuals = individuals + mutations * mutation_scale * (np.random.rand(*individuals.shape) * 2 - 1)\n        return np.clip(mutated_individuals, xlb, xub)\n\n    def crossover(parents):\n        \"\"\" Perform crossover between pairs of parents. \"\"\"\n        num_parents = parents.shape[0]\n        crossover_points = np.random.randint(1, N_P, size=num_parents // 2)\n        children = []\n        for i in range(0, num_parents, 2):\n            cp = crossover_points[i // 2]\n            child1 = np.concatenate([parents[i, :cp], parents[i + 1, cp:]])\n            child2 = np.concatenate([parents[i + 1, :cp], parents[i, cp:]])\n            children.append(child1)\n            children.append(child2)\n        return np.array(children)\n\n    def select_parents(population, num_parents):\n        \"\"\" Tournament selection based on rankings. \"\"\"\n        winners = []\n        for _ in range(num_parents):\n            contenders_idx = np.random.choice(len(population), size=4, replace=False)\n            contenders = population[contenders_idx]\n            winner_idx = np.argmin(pops['rankings'][contenders_idx])\n            winners.append(contenders[winner_idx])\n        return np.array(winners)\n\n    # Main function logic\n    mutation_rate = 0.1 + 0.9 * (current_gen / max_gen)  # Increase mutation rate over generations\n    num_parents = POP_SIZE // 2 * 2  # Ensure even number of parents for crossover\n\n    # Select parents for crossover\n    parent_individuals = select_parents(pops['individuals'], num_parents)\n    # Generate children through crossover\n    children = crossover(parent_individuals)\n    # Mutate the children\n    mutated_children = adaptive_mutation(children, mutation_rate)\n\n    # Combine old population and new children, then select the best\n    combined_population = np.vstack([pops['individuals'], mutated_children])\n    combined_rankings = np.hstack([pops['rankings'], np.full(mutated_children.shape[0], np.max(pops['rankings']) + 1)])\n    sorted_indices = np.argsort(combined_rankings)\n    new_pops = combined_population[sorted_indices[:POP_SIZE]]\n\n    return new_pops",
          "objective": -134.23916,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "def next_generation(pops, search_trajectory, xlb, xub, POP_SIZE, N_P, current_gen, max_gen):\n    import numpy as np\n\n    def adaptive_mutation(individuals, rate):\n        \"\"\" Mutate individuals based on an adaptive rate. \"\"\"\n        mutations = np.random.rand(*individuals.shape) < rate\n        mutation_scale = np.random.uniform(-1, 1, size=individuals.shape)\n        mutated = individuals + mutations * mutation_scale * (xub - xlb) * 0.1\n        return np.clip(mutated, xlb, xub)\n\n    def crossover(parents):\n        \"\"\" Perform crossover between pairs of parents. \"\"\"\n        np.random.shuffle(parents)\n        half = len(parents) // 2\n        children = []\n        for i in range(half):\n            cross_point = np.random.randint(1, N_P)\n            child1 = np.concatenate([parents[i][:cross_point], parents[i + half][cross_point:]])\n            child2 = np.concatenate([parents[i + half][:cross_point], parents[i][cross_point:]])\n            children.append(child1)\n            children.append(child2)\n        return np.array(children)\n\n    def select_parents(ranked_individuals, num_parents):\n        \"\"\" Tournament selection based on rankings. \"\"\"\n        winners = []\n        for _ in range(num_parents):\n            contenders_idx = np.random.choice(len(ranked_individuals), size=4, replace=False)\n            contenders = ranked_individuals[contenders_idx]\n            winner_idx = np.argmin(pops['rankings'][contenders_idx])\n            winners.append(contenders[winner_idx])\n        return np.array(winners)\n\n    # Main algorithm\n    mutation_rate = 0.1 + (0.5 - 0.1) * current_gen / max_gen  # Adaptive mutation rate\n    num_parents = POP_SIZE // 2\n\n    # Selection\n    parent_individuals = select_parents(pops['individuals'], num_parents)\n\n    # Crossover\n    children = crossover(parent_individuals)\n\n    # Mutation\n    mutated_children = adaptive_mutation(children, mutation_rate)\n\n    # Create new population\n    new_pops = np.vstack([pops['individuals'], mutated_children])\n    new_pops = new_pops[np.argsort(pops['rankings'])[:POP_SIZE]]  # Select top POP_SIZE individuals\n\n    return new_pops",
          "objective": -149.36661,
          "other_inf": null
     }
]