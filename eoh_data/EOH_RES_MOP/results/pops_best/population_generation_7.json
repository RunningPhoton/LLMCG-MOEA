{
     "algorithm": "```",
     "code": "def next_generation(pops, search_trajectory, xlb, xub, POP_SIZE, N_P, current_gen, max_gen):\n    import numpy as np\n\n    def sine_wave_mutation(individual, lb, ub, base_rate, gen_progress):\n        \"\"\"Mutation based on sine wave modulation for dynamic mutation strength.\"\"\"\n        mutation_strength = base_rate * (0.5 * np.sin(2 * np.pi * gen_progress) + 0.5)\n        mutant = np.copy(individual)\n        for i in range(len(mutant)):\n            if np.random.random() < mutation_strength:\n                mutation = np.random.uniform(-1, 1) * (ub[i] - lb[i]) * 0.1\n                mutant[i] = np.clip(mutant[i] + mutation, lb[i], ub[i])\n        return mutant\n\n    def tournament_selection(population, rankings):\n        \"\"\"Select two parents using binary tournament selection.\"\"\"\n        candidates_idx = np.random.choice(len(population), size=4, replace=False)\n        candidates_rankings = rankings[candidates_idx]\n        winners_idx = candidates_idx[np.argsort(candidates_rankings)[:2]]\n        return population[winners_idx[0]], population[winners_idx[1]]\n\n    def single_point_crossover(parent1, parent2):\n        \"\"\"Performs a single-point crossover.\"\"\"\n        crossover_point = np.random.randint(1, len(parent1) - 1)\n        child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        return child\n\n    base_mutation_rate = 0.3\n    generation_progress = current_gen / max_gen\n\n    new_pops = np.zeros_like(pops['individuals'])\n\n    for i in range(POP_SIZE):\n        parent1, parent2 = tournament_selection(pops['individuals'], pops['rankings'])\n        child = single_point_crossover(parent1, parent2)\n        child = sine_wave_mutation(child, xlb, xub, base_mutation_rate, generation_progress)\n        new_pops[i] = child\n\n    return new_pops",
     "objective": 0.20138,
     "other_inf": null
}