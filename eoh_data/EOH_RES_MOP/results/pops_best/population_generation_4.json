{
     "algorithm": "```",
     "code": "def next_generation(pops, search_trajectory, xlb, xub, POP_SIZE, N_P, current_gen, max_gen):\n    import numpy as np\n\n    # Use differential evolution-based crossover combined with a self-adaptive mutation strategy\n    \n    def differential_mutation(individuals, f=0.8):\n        \"\"\" Mutation operation in Differential Evolution. \"\"\"\n        mutated = np.zeros_like(individuals)\n        num_individuals = len(individuals)\n        for i in range(num_individuals):\n            idxs = np.random.choice(num_individuals, 3, replace=False)\n            a, b, c = individuals[idxs[0]], individuals[idxs[1]], individuals[idxs[2]]\n            mutated[i] = a + f * (b - c)\n        return mutated\n\n    def self_adaptive_mutation(individuals, tau=1.0):\n        \"\"\" Apply mutation influenced by the current generation. \"\"\"\n        mutation_strength = np.exp(-tau * current_gen / max_gen)\n        for i in range(len(individuals)):\n            for j in range(N_P):\n                if np.random.rand() < 0.1:  # mutation probability\n                    individuals[i, j] += mutation_strength * np.random.randn()\n                    individuals[i, j] = np.clip(individuals[i, j], xlb[j], xub[j])\n        return individuals\n    \n    def elite_preservation(strongest, elite_size):\n        \"\"\" Preserve the best solutions \"\"\"\n        return strongest[:elite_size]\n\n    # Parameters\n    elite_size = POP_SIZE // 5  # 20% of the population size\n    \n    # Preserve elites directly to the new population\n    elites = elite_preservation(pops['individuals'], elite_size)\n\n    # Apply differential mutation to generate donors\n    donors = differential_mutation(pops['individuals'])\n\n    # Recombine (crossover) with existing population\n    recombined = np.where(np.random.rand(POP_SIZE, N_P) < 0.5, pops['individuals'], donors)\n\n    # Mutation for diversity\n    new_individuals = self_adaptive_mutation(recombined)\n\n    # Elitism: Combine elite individuals with mutants\n    new_pops = np.vstack([elites, new_individuals[elite_size:]])\n\n    # Ensure population size remains constant\n    np.random.shuffle(new_pops)  # Shuffle to mix elites with new individuals\n\n    return new_pops",
     "objective": -0.59999,
     "other_inf": null
}