{
     "algorithm": "```",
     "code": "def next_generation(pops, search_trajectory, xlb, xub, POP_SIZE, N_P, current_gen, max_gen):\n    import numpy as np\n\n    def differential_mutation(base, add1, add2, scaling_factor=0.5):\n        # Create a mutated vector by differential evolution strategy\n        return base + scaling_factor * (add1 - add2)\n\n    def uniform_crossover(parent1, parent2):\n        # Perform uniform crossover\n        mask = np.random.rand(N_P) < 0.5\n        return np.where(mask, parent1, parent2)\n\n    # Initialize new population array\n    new_pops = np.zeros((POP_SIZE, N_P))\n\n    for i in range(POP_SIZE):\n        indices = np.random.choice(POP_SIZE, 3, replace=False)\n        base, second, third = pops['individuals'][indices[0]], pops['individuals'][indices[1]], pops['individuals'][indices[2]]\n\n        # Apply differential mutation\n        mutated = differential_mutation(base, second, third)\n\n        # Select a random parent for crossover\n        parent_idx = np.random.randint(0, POP_SIZE)\n        parent = pops['individuals'][parent_idx]\n\n        # Perform uniform crossover between mutated vector and random parent from the population\n        new_pops[i] = uniform_crossover(mutated, parent)\n\n        # Clip to stay within bounds\n        new_pops[i] = np.clip(new_pops[i], xlb, xub)\n\n    return new_pops",
     "objective": 0.64328,
     "other_inf": null
}