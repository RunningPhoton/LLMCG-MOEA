{
     "algorithm": "```",
     "code": "def next_generation(pops, search_trajectory, xlb, xub, POP_SIZE, N_P, current_gen, max_gen):\n    import numpy as np\n\n    # Adaptive mutation that factors in generational distance\n    def focused_mutate(individual, top_performer, mutation_scale=0.3):\n        # Weight more towards top performers as generations go by\n        beta = np.random.normal(0, 1, size=individual.shape)\n        weight = np.exp(-current_gen / max_gen)\n        mutation_vector = mutation_scale * (top_performer - individual) * weight + beta * (1 - weight)\n        return individual + mutation_vector\n\n    # Biased crossover giving preference to better-ranked individuals\n    def biased_crossover(parent1, parent2, rank1, rank2):\n        # Higher chance to pick characteristics from better-ranked parent\n        p = rank1 / (rank1 + rank2) if rank1 + rank2 != 0 else 0.5\n        crossover_mask = np.random.rand(N_P) < p\n        offspring = np.where(crossover_mask, parent1, parent2)\n        return offspring\n\n    # Initialize new population array\n    new_pops = np.zeros((POP_SIZE, N_P))\n\n    # Ensure there are previous individuals to sample from\n    history_available = search_trajectory['individuals'] is not None and len(search_trajectory['individuals']) > 0\n\n    for i in range(POP_SIZE):\n        idx1, idx2 = np.random.randint(0, POP_SIZE, size=2)\n        parent1 = pops['individuals'][idx1]\n        parent2 = pops['individuals'][idx2]\n        rank1 = pops['rankings'][idx1]\n        rank2 = pops['rankings'][idx2]\n\n        if np.random.rand() < 0.5:\n            # Perform biased crossover\n            new_pops[i] = biased_crossover(parent1, parent2, rank1, rank2)\n        else:\n            # Perform focused mutation based on the best available individual or a historical point\n            if history_available and np.random.rand() < 0.5:\n                history_idx = np.random.choice(len(search_trajectory['individuals']))\n                ref_individual = search_trajectory['individuals'][history_idx]\n            else:\n                ref_individual = pops['individuals'][np.argmin(pops['rankings'])]\n\n            new_pops[i] = focused_mutate(parent1, ref_individual)\n\n        # Clip to stay within bounds\n        new_pops[i] = np.clip(new_pops[i], xlb, xub)\n\n    return new_pops",
     "objective": -5.63161,
     "other_inf": null
}