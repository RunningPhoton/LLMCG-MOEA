[2024-06-15 10:46:07,666][interaction.py][line:62][INFO] start
[2024-06-15 10:47:52,357][LLM_CodeGen_OP.py][line:104][INFO] 

import numpy as np

def next_generation(pops: {}, search_trajectory: {}, xlb: np.ndarray, xub: np.ndarray, POP_SIZE: int, N_P: int, current_gen: int, max_gen: int):
    """
    Generates the next generation population for multi-objective optimization.

    :param pops: Current population.
    :param search_trajectory: Search trajectory gained throughout the evolutionary search.
    :param xlb: Lower bounds of decision variables.
    :param xub: Upper bounds of decision variables.
    :param POP_SIZE: Population size.
    :param N_P: Number of decision variables.
    :param current_gen: Current generation number.
    :param max_gen: Maximum number of generations.
    :return: New population as a numpy.ndarray with shape (POP_SIZE, N_P).
    """
    def select_parents():
        """Selects parent pairs for crossover."""
        pairs = []
        for _ in range(POP_SIZE // 2):
            p1 = pops['individuals'][np.random.randint(len(pops['individuals']))]
            p2 = pops['individuals'][np.random.randint(len(pops['individuals']))]
            pairs.append((p1, p2))
        return pairs

    def crossover(pairs):
        """Performs crossover on parent pairs to generate offspring."""
        offspring = []
        for p1, p2 in pairs:
            mask = np.random.rand(N_P) < 0.5
            o1 = np.where(mask, p1, p2)
            o2 = np.where(mask, p2, p1)
            offspring.append(o1)
            offspring.append(o2)
        return np.array(offspring)

    def mutate(pop):
        """Performs mutation on the population."""
        mutation_rate = 1 / N_P
        for i in range(POP_SIZE):
            if np.random.rand() < mutation_rate:
                j = np.random.randint(N_P)
                pop[i, j] = np.random.uniform(xlb[j], xub[j])
        return pop

    def check_bounds(pop):
        """Checks and enforces variable bounds."""
        pop = np.maximum(pop, xlb)
        pop = np.minimum(pop, xub)
        return pop

    # Selection
    parent_pairs = select_parents()

    # Crossover
    new_pop = crossover(parent_pairs)

    # Mutation
    new_pop = mutate(new_pop)

    # Check variable bounds
    new_pop = check_bounds(new_pop)

    return new_pop


[2024-06-15 10:52:56,671][LLM_CodeGen_OP.py][line:104][INFO] 

import numpy as np

def next_generation(pops: {}, search_trajectory: {}, xlb: np.ndarray, xub: np.ndarray, POP_SIZE: int, N_P: int, current_gen: int, max_gen: int):
    """
    Evolve the next generation population using intelligent evolutionary operators.
    
    :param pops: Current population dict with 'individuals' and 'rankings' keys.
    :param search_trajectory: Search trajectory dict with 'individuals' and 'rankings' keys.
    :param xlb: Lower bounds of decision variables (shape: N_P).
    :param xub: Upper bounds of decision variables (shape: N_P). 
    :param POP_SIZE: Population size.
    :param N_P: Number of decision variables.
    :param current_gen: Current generation number. 
    :param max_gen: Maximum number of generations.
    :return: Evolved next generation population (shape: POP_SIZE x N_P).
    """
    
    def select_parents(pops, search_trajectory, num_pairs):
        """Select parent pairs using tournament selection."""
        if search_trajectory['individuals'] is None:
            all_individuals = pops['individuals']
            all_rankings = pops['rankings']
        else:
            all_individuals = np.vstack((pops['individuals'], search_trajectory['individuals']))
            all_rankings = np.hstack((pops['rankings'], search_trajectory['rankings']))
        
        parent_pairs = []
        for _ in range(num_pairs):
            idx1, idx2 = np.random.choice(len(all_individuals), size=2, replace=False)
            if all_rankings[idx1] < all_rankings[idx2]:
                parent1 = all_individuals[idx1]
            else:
                parent1 = all_individuals[idx2]
                
            idx3, idx4 = np.random.choice(len(all_individuals), size=2, replace=False)  
            if all_rankings[idx3] < all_rankings[idx4]:
                parent2 = all_individuals[idx3]
            else:
                parent2 = all_individuals[idx4]
            
            parent_pairs.append((parent1, parent2))
        
        return parent_pairs
        
        
    def crossover(parent1, parent2):
        """Perform simulated binary crossover (SBX) on parent pair."""
        child1 = np.empty_like(parent1)
        child2 = np.empty_like(parent2)
        
        eta = 2 # distribution index
        for i in range(len(parent1)):
            if np.random.rand() <= 0.5:
                if abs(parent1[i] - parent2[i]) > 1e-14:
                    if parent1[i] < parent2[i]:
                        y1 = parent1[i]
                        y2 = parent2[i]
                    else:
                        y1 = parent2[i]
                        y2 = parent1[i]
                    
                    beta = 1.0 + (2.0 * (y1 - xlb[i]) / (y2 - y1))
                    alpha = 2.0 - np.power(beta, -(eta + 1.0))
                    u = np.random.rand()
                    if u <= (1.0 / alpha):
                        beta_q = np.power((u * alpha), (1.0 / (eta + 1.0)))
                    else:
                        beta_q = np.power((1.0 / (2.0 - u * alpha)), (1.0 / (eta + 1.0)))
                    
                    c1 = 0.5 * ((y1 + y2) - beta_q * (y2 - y1))
                    c2 = 0.5 * ((y1 + y2) + beta_q * (y2 - y1))
                    
                    if c1 < xlb[i]:
                        c1 = xlb[i]
                    if c2 < xlb[i]:
                        c2 = xlb[i]
                    if c1 > xub[i]:
                        c1 = xub[i]
                    if c2 > xub[i]:
                        c2 = xub[i]
                        
                    if np.random.rand() <= 0.5:
                        child1[i] = c1
                        child2[i] = c2
                    else:
                        child1[i] = c2
                        child2[i] = c1
                else:
                    child1[i] = parent1[i]
                    child2[i] = parent2[i]
            else:
                child1[i] = parent1[i]
                child2[i] = parent2[i]
                
        return child1, child2
        
                
    def mutate(individual):
        """Perform polynomial mutation on an individual."""
        eta_m = 5 # distribution index  
        for i in range(len(individual)):
            if np.random.rand() < 1/N_P:
                x = individual[i]
                delta1 = (x - xlb[i]) / (xub[i] - xlb[i])
                delta2 = (xub[i] - x) / (xub[i] - xlb[i]) 
                mut_pow = 1.0 / (eta_m + 1.0)
                rand = np.random.rand()
                if rand < 0.5:
                    xy = 1.0 - delta1
                    val = 2.0 * rand + (1.0 - 2.0 * rand) * xy**(eta_m + 1.0)
                    delta_q = val**mut_pow - 1.0
                else:
                    xy = 1.0 - delta2
                    val = 2.0 * (1.0 - rand) + 2.0 * (rand - 0.5) * xy**(eta_m + 1.0)
                    delta_q = 1.0 - val**mut_pow
                    
                x += delta_q * (xub[i] - xlb[i])
                x = np.clip(x, xlb[i], xub[i])
                individual[i] = x
        return individual
        
        
    # Selection    
    num_pairs = POP_SIZE//2
    parent_pairs = select_parents(pops, search_trajectory, num_pairs)
    
    # Crossover
    offspring = []
    for parent1, parent2 in parent_pairs:
        child1, child2 = crossover(parent1, parent2)
        offspring.append(child1)
        offspring.append(child2)
    new_pop = np.array(offspring)
    
    # Mutation
    for i in range(POP_SIZE):
        new_pop[i] = mutate(new_pop[i])
        
    # Ensure bounds
    new_pop = np.clip(new_pop, xlb, xub)
    
    return new_pop


[2024-06-15 10:56:15,127][LLM_CodeGen_OP.py][line:104][INFO] 

import numpy as np

def next_generation(pops: {}, search_trajectory: {}, xlb: np.ndarray, xub: np.ndarray, POP_SIZE: int, N_P: int, current_gen: int, max_gen: int):
    """
    Generates the next generation population using intelligent evolutionary strategies.
    
    :param pops: Current population dict with 'individuals' (shape: POP_SIZE x N_P) and 'rankings'.
    :param search_trajectory: Dict with 'individuals' and 'rankings' from recent generations. 
    :param xlb: Lower bounds of decision variables (shape: N_P).
    :param xub: Upper bounds of decision variables (shape: N_P).
    :param POP_SIZE: Population size.
    :param N_P: Number of decision variables per individual.
    :param current_gen: Current generation number. 
    :param max_gen: Maximum number of generations.
    :return: New population as numpy array (shape: POP_SIZE x N_P).
    """
    
    def intelligent_selection():
        """Selects parent pairs using a combination of current population and search trajectory."""
        n_parents = POP_SIZE
        
        # Select half of parents from current population based on rankings
        pop_parents_idx = np.random.choice(len(pops['rankings']), size=n_parents//2, p=pops['rankings']/pops['rankings'].sum())
        pop_parents = pops['individuals'][pop_parents_idx]
        
        # Select other half of parents from search trajectory using distribution based on recency and performance 
        if search_trajectory['individuals'] is not None:
            traj_weights = np.arange(len(search_trajectory['rankings']), 0, -1) * (1/search_trajectory['rankings'])
            traj_parents_idx = np.random.choice(len(search_trajectory['rankings']), size=n_parents//2, p=traj_weights/traj_weights.sum())
            traj_parents = search_trajectory['individuals'][traj_parents_idx]
        else:
            traj_parents = pop_parents
        
        # Combine the selected parents
        parents = np.vstack((pop_parents, traj_parents))
        np.random.shuffle(parents)
        
        return parents

    def intelligent_crossover(parents):
        """Performs intelligent crossover between parents to generate offspring."""
        offspring = np.empty_like(parents)
        
        for i in range(0, len(parents), 2):
            p1, p2 = parents[i], parents[i+1]

            # Perform crossover with probability based on rankings and generation
            r1, r2 = pops['rankings'][i//2], search_trajectory['rankings'][i//2] if search_trajectory['rankings'] is not None else 0
            do_cross = np.random.rand() < (1 - (r1+r2)/(2*POP_SIZE)) * (1 - current_gen/max_gen) 
            
            if do_cross:
                # Whole arithmetic crossover 
                alpha = np.random.rand()
                offspring[i] = alpha*p1 + (1-alpha)*p2
                offspring[i+1] = alpha*p2 + (1-alpha)*p1
            else:
                # No crossover, offspring are copies of parents
                offspring[i] = p1
                offspring[i+1] = p2
                
        return offspring
        
    def intelligent_mutation(pop):
        """Performs intelligent mutation on the population."""
        for i in range(len(pop)):
            ind = pop[i]
            
            # Mutate with probability based on ranking and generation  
            r = pops['rankings'][i]
            do_mutate = np.random.rand() < r/POP_SIZE * np.exp(-current_gen/(0.3*max_gen))
            
            if do_mutate:
                # Gaussian mutation with decaying step size
                step_size = (xub-xlb) * (1 - current_gen/max_gen)
                mutation = np.random.normal(0, step_size, size=N_P)  
                ind = np.clip(ind + mutation, xlb, xub)
            
            pop[i] = ind
            
        return pop
            
    # Main part of next_generation function  
    parents = intelligent_selection()
    offspring = intelligent_crossover(parents)
    new_pop = intelligent_mutation(offspring)
    
    return new_pop
    

[2024-06-15 10:58:04,942][LLM_CodeGen_OP.py][line:104][INFO] 

import numpy as np

def next_generation(pops: {}, search_trajectory: {}, xlb: np.ndarray, xub: np.ndarray, POP_SIZE: int, N_P: int, current_gen: int, max_gen: int):
    """
    Generate the next generation population for multi-objective optimization.
    
    :param pops: Current population dictionary with 'individuals' and 'rankings'.
    :param search_trajectory: Search trajectory dictionary with 'individuals' and 'rankings'.
    :param xlb: Lower bounds of decision variables.
    :param xub: Upper bounds of decision variables.
    :param POP_SIZE: Population size.
    :param N_P: Number of decision variables.
    :param current_gen: Current generation number.
    :param max_gen: Maximum number of generations.
    :return: New population as a numpy array with shape (POP_SIZE, N_P).
    """
    
    def selection():
        """Select parent pairs for crossover."""
        pairs = []
        for _ in range(POP_SIZE // 2):
            p1 = pops['individuals'][np.random.randint(len(pops['individuals']))]
            p2 = pops['individuals'][np.random.randint(len(pops['individuals']))]
            pairs.append((p1, p2))
        return pairs

    def crossover(pairs):
        """Perform intelligent crossover on parent pairs."""
        offspring = []
        for p1, p2 in pairs:
            # Perform crossover based on rankings and search trajectory
            mask = np.random.randint(0, 2, size=N_P).astype(bool)
            o1 = np.where(mask, p1, p2)
            o2 = np.where(mask, p2, p1)
            offspring.append(o1)
            offspring.append(o2)
        return np.array(offspring)

    def mutation(new_pop):
        """Fine-tune the new population via mutation."""
        # Perform mutation based on search trajectory and current generation
        scale = 1 - current_gen / max_gen
        mut_rate = 0.1 * scale
        mut_mask = np.random.rand(POP_SIZE, N_P) < mut_rate
        mut_values = np.random.rand(POP_SIZE, N_P) * (xub - xlb) + xlb
        new_pop[mut_mask] = mut_values[mut_mask]
        return new_pop

    def check_bounds(new_pop):
        """Ensure decision variables are within bounds."""
        new_pop = np.clip(new_pop, xlb, xub)
        return new_pop

    # Selection
    parent_pairs = selection()
    
    # Crossover  
    new_pop = crossover(parent_pairs)

    # Mutation
    new_pop = mutation(new_pop)
    
    # Check bounds
    new_pop = check_bounds(new_pop)

    return new_pop


[2024-06-15 11:01:10,012][LLM_CodeGen_OP.py][line:104][INFO] 
import numpy as np

def next_generation(pops: {}, search_trajectory: {}, xlb: np.ndarray, xub: np.ndarray, POP_SIZE: int, N_P: int, current_gen: int, max_gen: int):
    """
    Evolve the population to the next generation using selection, crossover and mutation.
    
    :param pops: Current population dictionary with 'individuals' and 'rankings' keys
    :param search_trajectory: Search trajectory dictionary with 'individuals' and 'rankings' keys
    :param xlb: Lower bounds of decision variables (shape: N_P)  
    :param xub: Upper bounds of decision variables (shape: N_P)
    :param POP_SIZE: Population size
    :param N_P: Number of decision variables 
    :param current_gen: Current generation number
    :param max_gen: Maximum number of generations
    :return: Evolved population as a numpy array of shape (POP_SIZE, N_P)
    """
    
    def select_parents(pops, search_trajectory, n_pairs):
        """Select parent pairs for crossover."""
        if search_trajectory['individuals'] is not None:
            all_individuals = np.vstack((pops['individuals'], search_trajectory['individuals']))
            all_rankings = np.hstack((pops['rankings'], search_trajectory['rankings']))
        else:
            all_individuals = pops['individuals']
            all_rankings = pops['rankings']
        
        indices = np.random.choice(len(all_individuals), size=2*n_pairs, p=all_rankings/all_rankings.sum())
        parents = all_individuals[indices].reshape(n_pairs, 2, N_P)
        
        return parents

    def crossover(parents):
        """Perform intelligent crossover between parent pairs."""
        children = np.empty_like(parents)
        
        for i in range(len(parents)):
            mask = np.random.rand(N_P) < 0.5
            children[i,0,:] = mask*parents[i,0,:] + (1-mask)*parents[i,1,:]
            children[i,1,:] = (1-mask)*parents[i,0,:] + mask*parents[i,1,:]
        
        return children.reshape(-1, N_P)

    def mutate(offspring):
        """Fine-tune offspring population using mutation."""
        mutation_rate = 1 - current_gen/max_gen
        
        mask = np.random.rand(*offspring.shape) < mutation_rate
        mutations = np.random.normal(loc=0, scale=0.1, size=offspring.shape) 
        offspring += mask * mutations
        
        return offspring

    def check_bounds(offspring): 
        """Ensure offspring are within decision variable bounds."""
        offspring = np.clip(offspring, xlb, xub)
        return offspring

    parent_pairs = select_parents(pops, search_trajectory, POP_SIZE//2)
    offspring = crossover(parent_pairs)  
    offspring = mutate(offspring)
    new_pop = check_bounds(offspring)

    return new_pop

[2024-06-15 11:03:52,724][LLM_CodeGen_OP.py][line:104][INFO] 

import numpy as np

def next_generation(pops: {}, search_trajectory: {}, xlb: np.ndarray, xub: np.ndarray, POP_SIZE: int, N_P: int, current_gen: int, max_gen: int):
    """
    Generate the next generation population for multi-objective optimization.
    """
    
    def selection():
        """Select parent pairs for crossover."""
        parent_pairs = []
        for _ in range(POP_SIZE // 2):
            parent1 = tournament_selection(pops)
            parent2 = tournament_selection(pops)
            parent_pairs.append((parent1, parent2))
        return parent_pairs

    def crossover(parent_pairs):
        """Perform intelligent crossover on parent pairs."""
        offspring = []
        for parent1, parent2 in parent_pairs:
            child1, child2 = simulated_binary_crossover(parent1, parent2)
            offspring.append(child1)
            offspring.append(child2)
        return np.array(offspring)

    def mutation(offspring):
        """Apply mutation to fine-tune the offspring population."""
        mutated_offspring = []
        for individual in offspring:
            mutated_individual = polynomial_mutation(individual, xlb, xub)
            mutated_offspring.append(mutated_individual)
        return np.array(mutated_offspring)
    
    def tournament_selection(population):
        """Tournament selection to select a parent from the population."""
        tournament_size = 2
        indices = np.random.randint(len(population['individuals']), size=tournament_size)
        tournament_individuals = population['individuals'][indices]
        tournament_rankings = population['rankings'][indices]
        best_index = np.argmin(tournament_rankings)
        return tournament_individuals[best_index]

    def simulated_binary_crossover(parent1, parent2):
        """Simulated binary crossover (SBX) operator."""
        eta = 15  # Distribution index for SBX
        child1 = np.empty_like(parent1)
        child2 = np.empty_like(parent2)
        
        for i in range(len(parent1)):
            if np.random.rand() <= 0.5:
                if abs(parent1[i] - parent2[i]) > 1e-14:
                    if parent1[i] < parent2[i]:
                        y1 = parent1[i]
                        y2 = parent2[i]
                    else:
                        y1 = parent2[i]
                        y2 = parent1[i]
                    
                    rand = np.random.rand()
                    beta = 1.0 + (2.0 * (y1 - xlb[i]) / (y2 - y1))
                    alpha = 2.0 - beta ** -(eta + 1.0)
                    if rand <= 1.0 / alpha:
                        betaq = (rand * alpha) ** (1.0 / (eta + 1.0))
                    else:
                        betaq = (1.0 / (2.0 - rand * alpha)) ** (1.0 / (eta + 1.0))
                    
                    c1 = 0.5 * ((y1 + y2) - betaq * (y2 - y1))
                    c2 = 0.5 * ((y1 + y2) + betaq * (y2 - y1))
                    
                    c1 = np.clip(c1, xlb[i], xub[i])
                    c2 = np.clip(c2, xlb[i], xub[i])
                    
                    if np.random.rand() <= 0.5:
                        child1[i] = c1
                        child2[i] = c2
                    else:
                        child1[i] = c2
                        child2[i] = c1
                else:
                    child1[i] = parent1[i]
                    child2[i] = parent2[i]
            else:
                child1[i] = parent1[i]
                child2[i] = parent2[i]
        
        return child1, child2

    def polynomial_mutation(individual, xlb, xub):
        """Polynomial mutation operator."""
        eta = 20  # Distribution index for mutation
        mutated_individual = np.copy(individual)
        
        for i in range(len(individual)):
            if np.random.rand() <= 1/len(individual):
                x = individual[i]
                delta1 = (x - xlb[i]) / (xub[i] - xlb[i])
                delta2 = (xub[i] - x) / (xub[i] - xlb[i])
                rand = np.random.rand()
                mut_pow = 1.0 / (eta + 1.0)
                
                if rand < 0.5:
                    xy = 1.0 - delta1
                    val = 2.0 * rand + (1.0 - 2.0 * rand) * xy ** (eta + 1.0)
                    delta_q = val ** mut_pow - 1.0
                else:
                    xy = 1.0 - delta2
                    val = 2.0 * (1.0 - rand) + 2.0 * (rand - 0.5) * xy ** (eta + 1.0)
                    delta_q = 1.0 - val ** mut_pow
                
                mutated_individual[i] = x + delta_q * (xub[i] - xlb[i])
                mutated_individual[i] = np.clip(mutated_individual[i], xlb[i], xub[i])
        
        return mutated_individual

    # Selection
    parent_pairs = selection()
    
    # Crossover 
    offspring = crossover(parent_pairs)
    
    # Mutation
    new_pop = mutation(offspring)
    
    # Ensure variables are within bounds
    new_pop = np.clip(new_pop, xlb, xub)
    
    return new_pop


[2024-06-15 11:06:05,546][LLM_CodeGen_OP.py][line:104][INFO] 

import numpy as np

def next_generation(pops: {}, search_trajectory: {}, xlb: np.ndarray, xub: np.ndarray, POP_SIZE: int, N_P: int, current_gen: int, max_gen: int):
    """Evolve the next generation population for multi-objective optimization."""
    
    def select_parents():
        """Select parent pairs using a combination of current population and search trajectory."""
        num_pairs = POP_SIZE // 2
        parent_pairs = []
        
        # Select top-ranked individuals from current population
        num_top_ranked = int(0.2 * POP_SIZE)
        top_ranked = pops['individuals'][:num_top_ranked]
        
        # Select diverse individuals from search trajectory
        if search_trajectory['individuals'] is not None:
            unique_inds = np.unique(search_trajectory['individuals'], axis=0)
            diverse_inds = unique_inds[np.random.choice(len(unique_inds), size=num_pairs, replace=True)]
        else:
            diverse_inds = pops['individuals'][np.random.choice(POP_SIZE, size=num_pairs, replace=True)]
        
        for _ in range(num_pairs):
            p1 = top_ranked[np.random.choice(len(top_ranked))]
            p2 = diverse_inds[np.random.choice(len(diverse_inds))]
            parent_pairs.append((p1, p2))
        
        return parent_pairs

    def crossover(parent_pairs):
        """Perform intelligent crossover between each parent pair."""
        offspring = []
        
        for p1, p2 in parent_pairs:
            # SBX crossover
            rand = np.random.rand(N_P)
            gamma = np.empty(N_P)
            gamma[rand <= 0.5] = (2 * rand[rand <= 0.5]) ** (1 / (20 + 1))  
            gamma[rand > 0.5] = (1 / (2 * (1 - rand[rand > 0.5]))) ** (1 / (20 + 1))
            c1 = 0.5 * ((1 + gamma) * p1 + (1 - gamma) * p2)
            c2 = 0.5 * ((1 - gamma) * p1 + (1 + gamma) * p2)
            
            # Linear combination with archive
            if search_trajectory['individuals'] is not None:
                weights = np.random.rand(2)
                arc_ind = search_trajectory['individuals'][np.random.choice(len(search_trajectory['individuals']))]
                c1 = weights[0]*c1 + (1-weights[0])*arc_ind
                c2 = weights[1]*c2 + (1-weights[1])*arc_ind

            offspring.extend([c1, c2])
            
        return np.array(offspring)
    
    def mutate(new_pop):
        """Fine-tune new population with intelligent mutation."""
        # Adaptive mutation strength based on gen
        mutation_strength = 1 - current_gen / max_gen
        
        # Perform mutation
        mutation_mask = np.random.rand(*new_pop.shape) < 0.1
        mutation = np.random.normal(loc=0, scale=mutation_strength, size=new_pop.shape) 
        new_pop[mutation_mask] += mutation[mutation_mask]

        # Ensure bounds
        new_pop = np.clip(new_pop, xlb, xub)
        
        return new_pop
    
    # Select parents 
    parent_pairs = select_parents()
    
    # Crossover
    new_pop = crossover(parent_pairs)
    
    # Mutation
    new_pop = mutate(new_pop)

    return new_pop

[2024-06-15 11:07:54,927][LLM_CodeGen_OP.py][line:104][INFO] 

import numpy as np

def next_generation(pops: {}, search_trajectory: {}, xlb: np.ndarray, xub: np.ndarray, POP_SIZE: int, N_P: int, current_gen: int, max_gen: int):
    """
    Evolve the next generation population using intelligent search strategies.
    
    :param pops: Current population dictionary with 'individuals' and 'rankings'.
    :param search_trajectory: Trajectory of previous populations.
    :param xlb: Lower bounds of decision variables.
    :param xub: Upper bounds of decision variables.
    :param POP_SIZE: Population size.
    :param N_P: Number of decision variables per individual.
    :param current_gen: Current generation number.
    :param max_gen: Maximum number of generations.
    :return: Evolved next generation population.
    """
    def select_parents():
        """Select parent pairs for crossover."""
        num_pairs = POP_SIZE // 2
        parents = []
        for _ in range(num_pairs):
            p1_idx = np.random.randint(len(pops['individuals']))
            p2_idx = np.random.randint(len(pops['individuals']))
            while p2_idx == p1_idx:
                p2_idx = np.random.randint(len(pops['individuals']))
            parents.append((pops['individuals'][p1_idx], pops['individuals'][p2_idx]))
        return parents
    
    def crossover(parents):
        """Perform intelligent crossover on parent pairs."""
        offspring = []
        for p1, p2 in parents:
            mask = np.random.rand(N_P) < 0.5
            o1 = np.where(mask, p1, p2)
            o2 = np.where(mask, p2, p1)
            offspring.append(o1)
            offspring.append(o2)
        return np.array(offspring)
    
    def mutate(pop):
        """Apply mutation to fine-tune the population."""
        mutation_rate = 1 / N_P
        for i in range(POP_SIZE):
            for j in range(N_P):
                if np.random.rand() < mutation_rate:
                    pop[i, j] = np.random.uniform(xlb[j], xub[j])
        return pop
    
    def check_bounds(pop):
        """Ensure decision variables are within bounds."""
        pop = np.maximum(pop, xlb)
        pop = np.minimum(pop, xub)
        return pop

    parents = select_parents()
    offspring = crossover(parents)
    offspring = mutate(offspring)
    new_pop = check_bounds(offspring)
    
    return new_pop


[2024-06-15 11:10:00,357][LLM_CodeGen_OP.py][line:104][INFO] 

import numpy as np

def next_generation(pops: {}, search_trajectory: {}, xlb: np.ndarray, xub: np.ndarray, POP_SIZE: int, N_P: int, current_gen: int, max_gen: int):
    """Generate the next generation population using intelligent evolutionary strategies."""
    
    def select_parents(pops, search_trajectory, num_pairs):
        """Intelligently select parent pairs from current population and search trajectory."""
        combined_pop = np.vstack((pops['individuals'], search_trajectory['individuals'])) if search_trajectory['individuals'] is not None else pops['individuals']
        combined_ranks = np.hstack((pops['rankings'], search_trajectory['rankings'])) if search_trajectory['rankings'] is not None else pops['rankings']
        
        # Select parents using tournament selection biased towards higher ranked individuals
        indices = np.random.randint(len(combined_pop), size=(num_pairs * 2, 2))
        selected = np.array([combined_pop[i[0] if combined_ranks[i[0]] <= combined_ranks[i[1]] else i[1]] for i in indices])
        
        return selected.reshape(num_pairs, 2, N_P)

    def crossover(parents):
        """Perform intelligent crossover between each pair of parents."""
        offspring = np.empty((len(parents), 2, N_P))
        for i, (p1, p2) in enumerate(parents):
            # Perform simulated binary crossover
            u = np.random.rand(N_P)
            beta = np.where(u < 0.5, (2 * u) ** (1/3), (1 / (2 * (1 - u))) ** (1/3))
            offspring[i, 0] = 0.5 * ((1 + beta) * p1 + (1 - beta) * p2) 
            offspring[i, 1] = 0.5 * ((1 - beta) * p1 + (1 + beta) * p2)
        return offspring.reshape(POP_SIZE, N_P)
    
    def mutate(pop):
        """Fine-tune the population using intelligent mutation."""
        # Perform polynomial mutation
        prob_mut = 1/N_P
        eta_m = 5
        for i in range(POP_SIZE):
            if np.random.rand() < prob_mut:
                for j in range(N_P):
                    if np.random.rand() < 0.5:
                        delta = (2 * np.random.rand()) ** (1/(eta_m + 1)) - 1
                        pop[i,j] += delta * (pop[i,j] - xlb[j]) 
                    else:
                        delta = 1 - (2 * (1 - np.random.rand())) ** (1/(eta_m + 1))
                        pop[i,j] += delta * (xub[j] - pop[i,j])
        return pop
    
    # Select parents 
    parent_pairs = select_parents(pops, search_trajectory, POP_SIZE//2)
    
    # Generate offspring through crossover
    new_pop = crossover(parent_pairs)
    
    # Mutate the new population
    new_pop = mutate(new_pop)
    
    # Ensure new population is within variable bounds  
    new_pop = np.clip(new_pop, xlb, xub)
    
    return new_pop
    

[2024-06-15 11:11:45,616][LLM_CodeGen_OP.py][line:104][INFO] 

def next_generation(pops: {}, search_trajectory: {}, xlb: numpy.ndarray, xub: numpy.ndarray, POP_SIZE: int, N_P: int, current_gen: int, max_gen: int):
    """Generate a new population using intelligent evolutionary strategies."""
    
    def intelligent_selection(pops, search_trajectory, num_pairs):
        """Select parent pairs intelligently using current population and search history."""
        parents = []
        pop_individuals = pops['individuals']
        trajectory_individuals = search_trajectory['individuals']
        
        for _ in range(num_pairs):
            if trajectory_individuals is not None and numpy.random.rand() < 0.2:
                parent1 = trajectory_individuals[numpy.random.randint(len(trajectory_individuals))]
            else:
                parent1 = pop_individuals[numpy.random.randint(len(pop_individuals))]
            
            if trajectory_individuals is not None and numpy.random.rand() < 0.2:  
                parent2 = trajectory_individuals[numpy.random.randint(len(trajectory_individuals))]
            else:
                parent2 = pop_individuals[numpy.random.randint(len(pop_individuals))]
            
            parents.append((parent1, parent2))
        
        return parents

    def intelligent_crossover(parents):
        """Perform intelligent crossover between parent pairs."""
        offspring = []
        
        for parent1, parent2 in parents:
            crossover_point = numpy.random.randint(1, N_P)
            child1 = numpy.concatenate((parent1[:crossover_point], parent2[crossover_point:]))
            child2 = numpy.concatenate((parent2[:crossover_point], parent1[crossover_point:]))
            offspring.append(child1)
            offspring.append(child2)
        
        return numpy.array(offspring)

    def intelligent_mutation(new_pop, gen_ratio):
        """Fine-tune new population using intelligent mutation strategies."""
        mutate_mask = numpy.random.rand(POP_SIZE, N_P) < (1-gen_ratio)
        mutation_range = (xub - xlb) * 0.1 * (1-gen_ratio)
        mutation = numpy.random.uniform(-mutation_range, mutation_range, size=(POP_SIZE, N_P))
        new_pop[mutate_mask] += mutation[mutate_mask]
        return new_pop

    # Selection 
    gen_ratio = current_gen / max_gen
    num_pairs = POP_SIZE // 2
    parents = intelligent_selection(pops, search_trajectory, num_pairs)

    # Crossover
    new_pop = intelligent_crossover(parents)

    # Mutation
    new_pop = intelligent_mutation(new_pop, gen_ratio)

    # Check bounds
    new_pop = numpy.clip(new_pop, xlb, xub) 

    return new_pop


[2024-06-15 11:11:45,618][interaction.py][line:69][INFO] evolving-----------------------------------
[2024-06-17 04:12:44,064][interaction.py][line:69][INFO] evolving-----------------------------------
[2024-06-17 08:08:04,376][interaction.py][line:69][INFO] evolving-----------------------------------
[2024-06-17 20:20:23,994][interaction.py][line:129][INFO] finish
