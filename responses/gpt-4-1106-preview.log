[2024-03-11 13:01:29,249][interaction.py][line:26][INFO] start
[2024-03-11 13:02:12,591][utils.py][line:75][INFO] 
import numpy as np

def next_generation(pops: {}, search_trajectory: {}, xlb: np.ndarray, xub: np.ndarray, POP_SIZE: int, N_P: int, current_gen: int, max_gen: int):
    """
    Generate the next generation of individuals for a multi-objective evolutionary algorithm.
    
    :param pops: Current population and rankings.
    :param search_trajectory: Trajectory gained along the evolutionary search.
    :param xlb: Lower bound of decision variables.
    :param xub: Upper bound of decision variables.
    :param POP_SIZE: Number of individuals in each population.
    :param N_P: Number of decision variables.
    :param current_gen: Current generation number.
    :param max_gen: Maximum number of generations.
    :return: New population as a numpy.ndarray.
    """

    def selection(pops, search_trajectory):
        # Combine populations and search trajectory, then select individuals based on rankings
        combined_individuals = np.vstack((pops['individuals'], search_trajectory['individuals'])) if search_trajectory['individuals'] is not None else pops['individuals']
        combined_rankings = np.hstack((pops['rankings'], search_trajectory['rankings'])) if search_trajectory['rankings'] is not None else pops['rankings']
        
        # Sort combined population based on rankings
        sorted_indices = np.argsort(combined_rankings)
        sorted_individuals = combined_individuals[sorted_indices][:POP_SIZE]
        
        # Select parent pairs
        parent_pairs = [sorted_individuals[i:i+2] for i in range(0, POP_SIZE, 2)]
        return parent_pairs

    def crossover(parent_pairs):
        # Perform crossover on parent pairs to produce offspring
        offspring = []
        for parents in parent_pairs:
            # Uniform crossover as an example
            mask = np.random.rand(N_P) > 0.5
            child1 = np.where(mask, parents[0], parents[1])
            child2 = np.where(mask, parents[1], parents[0])
            offspring.extend([child1, child2])
        return np.array(offspring)

    def mutation(offspring):
        # Mutate the offspring population
        mutation_rate = 1.0 / N_P
        for i in range(POP_SIZE):
            if np.random.rand() < mutation_rate:
                mutation_point = np.random.randint(N_P)
                offspring[i, mutation_point] = np.random.uniform(xlb[mutation_point], xub[mutation_point])
        return offspring

    def bound_check(new_pop):
        # Ensure the new population is within the specified bounds
        return np.clip(new_pop, xlb, xub)

    # Part 1: Selection
    parent_pairs = selection(pops, search_trajectory)

    # Part 2: Crossover
    new_pop = crossover(parent_pairs)

    # Part 3: Mutation
    new_pop = mutation(new_pop)

    # Validate new population within bounds
    new_pop = bound_check(new_pop)

    return new_pop

[2024-03-11 13:03:13,592][utils.py][line:75][INFO] 
import numpy as np

def next_generation(pops: dict, search_trajectory: dict, xlb: np.ndarray, xub: np.ndarray, POP_SIZE: int, N_P: int, current_gen: int, max_gen: int):
    """
    Evolve a new generation of individuals for multi-objective optimization problems.
    
    :param pops: Current population and rankings
    :param search_trajectory: Trajectory of individuals and rankings
    :param xlb: Lower bounds of decision variables
    :param xub: Upper bounds of decision variables
    :param POP_SIZE: Size of the population
    :param N_P: Number of decision variables
    :param current_gen: Current generation number
    :param max_gen: Maximum number of generations
    :return: New population of individuals
    """
    
    def select_parents(pops, search_trajectory, POP_SIZE, N_P):
        # Combine current population with search trajectory if available
        if search_trajectory['individuals'] is not None and search_trajectory['rankings'] is not None:
            combined_individuals = np.vstack((pops['individuals'], search_trajectory['individuals']))
            combined_rankings = np.hstack((pops['rankings'], search_trajectory['rankings']))
        else:
            combined_individuals = pops['individuals']
            combined_rankings = pops['rankings']
        
        # Sort combined population by rankings
        sorted_indices = np.argsort(combined_rankings)
        sorted_individuals = combined_individuals[sorted_indices]
        
        # Select top individuals as parents
        parents = sorted_individuals[:POP_SIZE, :]
        return parents

    def crossover(parents, POP_SIZE, N_P):
        np.random.shuffle(parents)
        offspring = np.empty((POP_SIZE, N_P))
        
        for i in range(0, POP_SIZE, 2):
            parent1 = parents[i]
            parent2 = parents[(i + 1) % POP_SIZE]
            
            # Single point crossover
            cross_point = np.random.randint(1, N_P)
            offspring[i, :cross_point] = parent1[:cross_point]
            offspring[i, cross_point:] = parent2[cross_point:]
            offspring[(i + 1) % POP_SIZE, :cross_point] = parent2[:cross_point]
            offspring[(i + 1) % POP_SIZE, cross_point:] = parent1[cross_point:]
        return offspring
    
    def mutate(offspring, xlb, xub, POP_SIZE, N_P, current_gen, max_gen):
        mutation_rate = 1.0 / N_P  # Mutation rate could be adjusted dynamically
        scale = (xub - xlb) * (1 - (current_gen / max_gen))  # Decrease scale over generations
        
        for i in range(POP_SIZE):
            if np.random.rand() < mutation_rate:
                mutation = np.random.uniform(-scale, scale, N_P)
                offspring[i] += mutation
                # Ensure the offspring is within bounds
                offspring[i] = np.clip(offspring[i], xlb, xub)
        return offspring

    # Part 1: Selection
    parents = select_parents(pops, search_trajectory, POP_SIZE, N_P)
    
    # Part 2: Crossover
    new_pop = crossover(parents, POP_SIZE, N_P)
    
    # Part 3: Mutation
    new_pop = mutate(new_pop, xlb, xub, POP_SIZE, N_P, current_gen, max_gen)
    
    return new_pop

[2024-03-11 13:03:46,023][utils.py][line:75][INFO] 
import numpy as np

def next_generation(pops: {}, search_trajectory: {}, xlb: np.ndarray, xub: np.ndarray, POP_SIZE: int, N_P: int, current_gen: int, max_gen: int):
    """
    Evolves a new population using selection, crossover, and mutation strategies for multi-objective problems.
    
    :param pops: Current population with individuals and rankings.
    :param search_trajectory: Trajectory of individuals and rankings from the evolutionary search.
    :param xlb: Lower bounds of decision variables.
    :param xub: Upper bounds of decision variables.
    :param POP_SIZE: Number of individuals in each population.
    :param N_P: Number of decision variables.
    :param current_gen: Current generation number.
    :param max_gen: Maximum number of generations.
    :return: New population as a numpy.ndarray with shape (POP_SIZE, N_P).
    """
    
    def tournament_selection(pop, k=2):
        """
        Tournament selection for selecting the fittest individuals.
        """
        selected_indices = []
        for _ in range(POP_SIZE):
            participants = np.random.choice(pop['rankings'].shape[0], k, replace=False)
            selected_indices.append(participants[np.argmin(pop['rankings'][participants])])
        return pop['individuals'][selected_indices]
    
    def crossover(parent1, parent2):
        """
        Uniform crossover to generate two offspring from two parents.
        """
        mask = np.random.rand(N_P) < 0.5
        offspring1 = np.where(mask, parent1, parent2)
        offspring2 = np.where(mask, parent2, parent1)
        return offspring1, offspring2
    
    def mutate(individual):
        """
        Gaussian mutation to introduce variability into the offspring.
        """
        mutation_strength = (xub - xlb) * (1 - (current_gen / max_gen)) * 0.1
        individual += np.random.randn(N_P) * mutation_strength
        return np.clip(individual, xlb, xub)
    
    # Part 1: Selection
    selected_parents = tournament_selection(pops)
    
    # Part 2: Crossover
    new_pop = np.empty((POP_SIZE, N_P))
    for i in range(0, POP_SIZE, 2):
        parent1 = selected_parents[i]
        parent2 = selected_parents[(i + 1) % POP_SIZE]
        offspring1, offspring2 = crossover(parent1, parent2)
        new_pop[i] = offspring1
        new_pop[(i + 1) % POP_SIZE] = offspring2
    
    # Part 3: Mutation
    for i in range(POP_SIZE):
        new_pop[i] = mutate(new_pop[i])
    
    return new_pop

[2024-03-11 13:04:18,111][utils.py][line:75][INFO] 
import numpy as np

def next_generation(pops: {}, search_trajectory: {}, xlb: np.ndarray, xub: np.ndarray, POP_SIZE: int, N_P: int, current_gen: int, max_gen: int):
    """
    Evolves a new population for the next generation using intelligent evolutionary strategies.

    :param pops: Current population and rankings
    :param search_trajectory: Trajectory of individuals and rankings from the search history
    :param xlb: Lower bounds of decision variables
    :param xub: Upper bounds of decision variables
    :param POP_SIZE: Size of the population
    :param N_P: Number of decision variables
    :param current_gen: The current generation number
    :param max_gen: The maximum number of generations
    :return: New population as a numpy.ndarray
    """

    def tournament_selection(pop, k=2):
        """Select one individual using k-tournament selection."""
        best = None
        for _ in range(k):
            i = np.random.randint(0, len(pop))
            if best is None or pop['rankings'][i] < pop['rankings'][best]:
                best = i
        return pop['individuals'][best]

    def crossover(parent1, parent2):
        """Perform a simple crossover between two parents."""
        crossover_point = np.random.randint(1, N_P)
        child1 = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))
        child2 = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))
        return child1, child2

    def mutate(individual, mutation_rate=0.1):
        """Mutate an individual with a given mutation rate."""
        for i in range(N_P):
            if np.random.rand() < mutation_rate:
                individual[i] = individual[i] + np.random.normal(0, (xub[i] - xlb[i]) * 0.1)
                individual[i] = np.clip(individual[i], xlb[i], xub[i])
        return individual

    # **Part 1: Selection**
    parents = []
    for _ in range(POP_SIZE // 2):
        parent1 = tournament_selection(pops)
        parent2 = tournament_selection(pops)
        parents.append((parent1, parent2))

    # **Part 2: Crossover**
    new_pop = []
    for parent1, parent2 in parents:
        child1, child2 = crossover(parent1, parent2)
        new_pop.extend([child1, child2])

    # Ensure new_pop is a numpy array with the correct shape
    new_pop = np.array(new_pop).reshape((POP_SIZE, N_P))

    # **Part 3: Mutation**
    for i in range(POP_SIZE):
        new_pop[i] = mutate(new_pop[i])

    return new_pop

[2024-03-11 13:04:42,585][utils.py][line:75][INFO] 
import numpy as np

def next_generation(pops: {}, search_trajectory: {}, xlb: np.ndarray, xub: np.ndarray, POP_SIZE: int, N_P: int, current_gen: int, max_gen: int):
    """
    Evolves a new generation of individuals for multi-objective optimization problems.
    
    :param pops: Current population and rankings
    :param search_trajectory: Past search trajectory for data-driven strategies
    :param xlb: Lower bounds of decision variables
    :param xub: Upper bounds of decision variables
    :param POP_SIZE: Population size
    :param N_P: Number of decision variables
    :param current_gen: Current generation number
    :param max_gen: Maximum number of generations
    :return: New population of individuals
    """
    
    # Helper function to perform tournament selection
    def tournament_selection(ranks, k=2):
        selected_indices = []
        for _ in range(POP_SIZE):
            participants = np.random.choice(len(ranks), k, replace=False)
            selected_indices.append(participants[np.argmin(ranks[participants])])
        return selected_indices
    
    # Helper function to perform crossover
    def crossover(parent1, parent2):
        alpha = np.random.uniform(0, 1, size=N_P)
        offspring1 = alpha * parent1 + (1 - alpha) * parent2
        offspring2 = alpha * parent2 + (1 - alpha) * parent1
        return offspring1, offspring2

    # Helper function to perform mutation
    def mutation(individual, mutation_rate=0.1):
        for i in range(N_P):
            if np.random.rand() < mutation_rate:
                individual[i] = individual[i] + np.random.normal(0, (xub[i] - xlb[i]) / 10)
        return individual
    
    # Helper function to maintain the population within bounds
    def maintain_bounds(individual):
        return np.clip(individual, xlb, xub)
    
    # Part 1: Selection
    if search_trajectory['individuals'] is not None:
        combined_individuals = np.vstack((pops['individuals'], search_trajectory['individuals']))
        combined_rankings = np.hstack((pops['rankings'], search_trajectory['rankings']))
    else:
        combined_individuals = pops['individuals']
        combined_rankings = pops['rankings']
    
    selected_indices = tournament_selection(combined_rankings)
    parents = combined_individuals[selected_indices]
    
    # Part 2: Crossover
    np.random.shuffle(parents)
    new_pop = np.empty((POP_SIZE, N_P))
    for i in range(0, POP_SIZE, 2):
        p1, p2 = parents[i], parents[i+1]
        offspring1, offspring2 = crossover(p1, p2)
        new_pop[i], new_pop[i+1] = maintain_bounds(offspring1), maintain_bounds(offspring2)
    
    # Part 3: Mutation
    for i in range(POP_SIZE):
        new_pop[i] = maintain_bounds(mutation(new_pop[i]))
    
    return new_pop

[2024-03-11 13:05:22,894][utils.py][line:75][INFO] 
import numpy as np

def next_generation(pops: dict, search_trajectory: dict, xlb: np.ndarray, xub: np.ndarray, POP_SIZE: int, N_P: int, current_gen: int, max_gen: int):
    """
    Generate the next population for a multi-objective optimization problem using evolutionary strategies.
    """
    
    def tournament_selection(rankings, tournament_size=2):
        """
        Perform tournament selection based on the rankings.
        """
        selected_indices = []
        for _ in range(POP_SIZE):
            participants = np.random.choice(range(len(rankings)), tournament_size, replace=False)
            selected_indices.append(participants[np.argmin(rankings[participants])])
        return selected_indices
    
    def crossover(parent1, parent2):
        """
        Perform crossover between two parents to produce two offspring.
        """
        crossover_point = np.random.randint(1, N_P-1)
        offspring1 = np.concatenate([parent1[:crossover_point], parent2[crossover_point:]])
        offspring2 = np.concatenate([parent2[:crossover_point], parent1[crossover_point:]])
        return offspring1, offspring2
    
    def mutate(individual):
        """
        Mutate an individual.
        """
        mutation_rate = 1.0 / N_P
        for i in range(N_P):
            if np.random.rand() < mutation_rate:
                individual[i] = individual[i] + np.random.normal(0, (xub[i] - xlb[i]) * 0.1)
                individual[i] = np.clip(individual[i], xlb[i], xub[i])
        return individual
    
    # Part 1: Selection
    if search_trajectory['individuals'] is not None and search_trajectory['rankings'] is not None:
        combined_population = np.vstack((pops['individuals'], search_trajectory['individuals']))
        combined_rankings = np.concatenate((pops['rankings'], search_trajectory['rankings']))
    else:
        combined_population = pops['individuals']
        combined_rankings = pops['rankings']
    
    selected_indices = tournament_selection(combined_rankings)
    selected_parents = combined_population[selected_indices]
    
    # Part 2: Crossover
    new_pop = np.empty((POP_SIZE, N_P))
    for i in range(0, POP_SIZE, 2):
        parent1 = selected_parents[i]
        parent2 = selected_parents[i+1] if i+1 < POP_SIZE else selected_parents[0]
        offspring1, offspring2 = crossover(parent1, parent2)
        new_pop[i] = offspring1
        if i+1 < POP_SIZE:
            new_pop[i+1] = offspring2
    
    # Part 3: Mutation
    for i in range(POP_SIZE):
        new_pop[i] = mutate(new_pop[i])
    
    return new_pop

[2024-03-11 13:06:58,316][utils.py][line:75][INFO] 
import numpy as np

def next_generation(pops: {}, search_trajectory: {}, xlb: np.ndarray, xub: np.ndarray, POP_SIZE: int, N_P: int, current_gen: int, max_gen: int):
    """
    Evolves a population using an intelligent evolutionary strategy to tackle multi-objective problems.

    :param pops: Current population and rankings.
    :param search_trajectory: Trajectory of individuals and rankings throughout the search.
    :param xlb: Lower bounds of decision variables.
    :param xub: Upper bounds of decision variables.
    :param POP_SIZE: Number of individuals in each population.
    :param N_P: Number of decision variables.
    :param current_gen: Current generation number.
    :param max_gen: Maximum number of generations.
    :return: New population as a numpy.ndarray of shape (POP_SIZE, N_P).
    """

    def select_parents(pops, search_trajectory, POP_SIZE, N_P):
        # Combine current population with valid search trajectory if available
        if search_trajectory['individuals'] is not None:
            combined_individuals = np.vstack((pops['individuals'], search_trajectory['individuals']))
            combined_rankings = np.hstack((pops['rankings'], search_trajectory['rankings']))
        else:
            combined_individuals = pops['individuals']
            combined_rankings = pops['rankings']

        # Rank-based selection
        sorted_indices = np.argsort(combined_rankings)[:POP_SIZE]
        selected_parents = combined_individuals[sorted_indices]

        return selected_parents

    def crossover(parents, POP_SIZE, N_P):
        offspring = np.empty((POP_SIZE, N_P))

        # Pairwise crossover
        for i in range(0, POP_SIZE, 2):
            parent1_idx = np.random.randint(0, parents.shape[0])
            parent2_idx = np.random.randint(0, parents.shape[0])
            crossover_point = np.random.randint(1, N_P)

            offspring[i, :crossover_point] = parents[parent1_idx, :crossover_point]
            offspring[i, crossover_point:] = parents[parent2_idx, crossover_point:]
            offspring[i+1, :crossover_point] = parents[parent2_idx, :crossover_point]
            offspring[i+1, crossover_point:] = parents[parent1_idx, crossover_point:]

        return offspring

    def mutate(offspring, xlb, xub, current_gen, max_gen, N_P):
        mutation_rate = 1.0 / (N_P * (1 + current_gen / (max_gen / 2)))
        for i in range(offspring.shape[0]):
            for j in range(N_P):
                if np.random.rand() < mutation_rate:
                    mutation_value = np.random.uniform(-1, 1) * (xub[j] - xlb[j]) * mutation_rate
                    offspring[i, j] += mutation_value
                    offspring[i, j] = np.clip(offspring[i, j], xlb[j], xub[j])

        return offspring

    # Part 1: Selection
    parents = select_parents(pops, search_trajectory, POP_SIZE, N_P)

    # Part 2: Crossover
    new_pop = crossover(parents, POP_SIZE, N_P)

    # Part 3: Mutation
    new_pop = mutate(new_pop, xlb, xub, current_gen, max_gen, N_P)

    return new_pop

[2024-03-11 13:08:17,484][utils.py][line:75][INFO] 
import numpy as np

def next_generation(pops: dict, search_trajectory: dict, xlb: np.ndarray, xub: np.ndarray, POP_SIZE: int, N_P: int, current_gen: int, max_gen: int):
    """
    Generate the next generation population for a multi-objective optimization problem.

    :param pops: Current population and rankings
    :param search_trajectory: Trajectory gained along the evolutionary search
    :param xlb: Lower bounds of decision variables
    :param xub: Upper bounds of decision variables
    :param POP_SIZE: Number of individuals in each population
    :param N_P: Number of decision variables
    :param current_gen: Current generation number
    :param max_gen: Maximum number of generations
    :return: New population as a numpy.ndarray
    """

    def select_parents(pops, search_trajectory):
        """
        Select parent individuals for crossover.
        """
        # Check if search trajectory is not None and concatenate
        if search_trajectory['individuals'] is not None and search_trajectory['rankings'] is not None:
            combined_individuals = np.vstack((pops['individuals'], search_trajectory['individuals']))
            combined_rankings = np.hstack((pops['rankings'], search_trajectory['rankings']))
        else:
            combined_individuals = pops['individuals']
            combined_rankings = pops['rankings']

        # Sort based on rankings
        sorted_indices = np.argsort(combined_rankings)
        sorted_individuals = combined_individuals[sorted_indices]

        # Select top POP_SIZE individuals as parents
        parents = sorted_individuals[:POP_SIZE]
        return parents

    def crossover(parents):
        """
        Perform crossover between pairs of parent individuals.
        """
        np.random.shuffle(parents)
        offspring = np.empty((POP_SIZE, N_P))

        for i in range(0, POP_SIZE, 2):
            parent1 = parents[i]
            parent2 = parents[np.random.randint(POP_SIZE)]  # Ensure always having a pair

            # Uniform crossover
            mask = np.random.rand(N_P) > 0.5
            offspring[i] = mask * parent1 + ~mask * parent2
            offspring[i + 1] = ~mask * parent1 + mask * parent2

        return offspring

    def mutation(offspring):
        """
        Apply mutation to the offspring population.
        """
        mutation_rate = 1.0 / N_P
        for i in range(POP_SIZE):
            if np.random.rand() < mutation_rate:
                mutation_point = np.random.randint(N_P)
                mutation_value = np.random.uniform(xlb[mutation_point], xub[mutation_point])
                offspring[i, mutation_point] = mutation_value

        return offspring

    def enforce_bounds(pop):
        """
        Ensure that the population is within the specified bounds.
        """
        return np.clip(pop, xlb, xub)

    # Part 1: Selection
    parents = select_parents(pops, search_trajectory)

    # Part 2: Crossover
    new_pop = crossover(parents)

    # Part 3: Mutation
    new_pop = mutation(new_pop)

    # Enforce bounds
    new_pop = enforce_bounds(new_pop)

    return new_pop

[2024-03-11 13:08:43,794][utils.py][line:75][INFO] 
import numpy as np

def next_generation(pops: {}, search_trajectory: {}, xlb: np.ndarray, xub: np.ndarray, POP_SIZE: int, N_P: int, current_gen: int, max_gen: int):
    """
    Evolves a population for the next generation using intelligent evolutionary strategies.

    :param pops: Current population with individuals and their rankings.
    :param search_trajectory: Trajectory of the evolutionary search with individuals and their rankings.
    :param xlb: Lower bounds of decision variables.
    :param xub: Upper bounds of decision variables.
    :param POP_SIZE: Population size.
    :param N_P: Number of decision variables.
    :param current_gen: Current generation number.
    :param max_gen: Maximum number of generations.
    :return: New population as a numpy.ndarray with shape (POP_SIZE, N_P).
    """
    
    def tournament_selection(population, rankings, k=2):
        selected_indices = []
        for _ in range(POP_SIZE):
            participants = np.random.choice(POP_SIZE, k, replace=False)
            selected = participants[np.argmin(rankings[participants])]
            selected_indices.append(selected)
        return population[selected_indices]

    def crossover(parent1, parent2):
        alpha = np.random.rand(N_P)
        child1 = alpha * parent1 + (1 - alpha) * parent2
        child2 = alpha * parent2 + (1 - alpha) * parent1
        return child1, child2

    def mutation(individual):
        mutation_rate = 1.0 / N_P
        for i in range(N_P):
            if np.random.rand() < mutation_rate:
                individual[i] += np.random.normal(0, (xub[i] - xlb[i]) / 10)
                individual[i] = np.clip(individual[i], xlb[i], xub[i])
        return individual

    # Part 1: Selection
    if search_trajectory['individuals'] is not None and search_trajectory['rankings'] is not None:
        combined_population = np.vstack((pops['individuals'], search_trajectory['individuals']))
        combined_rankings = np.hstack((pops['rankings'], search_trajectory['rankings']))
    else:
        combined_population = pops['individuals']
        combined_rankings = pops['rankings']

    parents = tournament_selection(combined_population, combined_rankings)

    # Part 2: Crossover
    np.random.shuffle(parents)
    new_pop = []
    for i in range(0, POP_SIZE, 2):
        parent1, parent2 = parents[i], parents[i+1]
        child1, child2 = crossover(parent1, parent2)
        new_pop.append(child1)
        new_pop.append(child2)

    new_pop = np.array(new_pop)

    # Part 3: Mutation
    new_pop = np.apply_along_axis(mutation, 1, new_pop)

    return new_pop

[2024-03-11 13:09:48,194][utils.py][line:75][INFO]





[2024-03-26 08:42:06,758][interaction.py][line:38][INFO] evolving-----------------------------------
